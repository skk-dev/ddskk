;;; SKK-MK --- installer for SKK  -*- mode: emacs-lisp; coding: iso-2022-jp -*-

;; Copyright (C) 1999, 2000 NAKAJIMA Mikio <minakaji@osaka.email.ne.jp>
;; Copyright (C) 2003-2007  SKK Development Team <skk@ring.gr.jp>

;; Author: NAKAJIMA Mikio <minakaji@osaka.email.ne.jp>
;; Maintainer: SKK Development Team <skk@ring.gr.jp>
;; Version: $Id: SKK-MK,v 1.203 2014/09/10 11:11:11 skk-cvs Exp $
;; Last Modified: $Date: 2014/09/10 11:11:11 $

;;; Commentary:

;; Those values of variables below are default configurations.
;; If you would like to change some of those, you should edit SKK-CFG.
;;
;;              DO NOT EDIT THIS FILE DIRECTLY!
;;
;; Variable sections are all three parts.  GENERIC VARIABLE section,
;; NON-PACKAGE INSTALL RELATED VARIABLE section, and PACKAGE INSTALL
;; RELATED VARIABLE section.
;;
;; You can confirm target directories without an actual installation
;; by M-x SKK-MK-what-where or M-x SKK-MK-what-where-package after
;; load this program.

;;; Code:

(when (string-lessp emacs-version "19")
  (error "%s" "\
Emacs 18 or older is not supported by this version of SKK.
Try ddskk-e18 branch"))

(when (string-lessp emacs-version "20.3")
  (error "%s" "\
Emacs 20.2 and Mule 2.3 (Emacs 19) is not supported by this version of SKK.
Please install Daredevil SKK 11.6.0"))

(when (string-lessp emacs-version "21.0")
  (error "%s" "\
Emacs 20.7 is not supported by this version of SKK.
Please install Daredevil SKK 13.1 or 14.1"))

(when (and (featurep 'emacs)
	   (string-lessp emacs-version "22.0"))
  (error "%s" "\
GNU Emacs 21 is not supported by this version of SKK.
Please install Daredevil SKK 14.4"))

(unless (featurep 'mule)
  (error "%s" "\
This version of SKK requires MULE features"))

(set-language-environment "Japanese")

;; Variables.

(defvar APEL_DIR nil)

(defvar EMU_DIR nil)

(defvar PREFIX nil)

(defvar LISPDIR nil)

(defvar VERSION_SPECIFIC_LISPDIR nil)

(defvar ADDITIONAL_LISPDIR nil)

(defvar EMACS_SELF_CONTAINED nil)

(defvar running-gnu-emacs (or (featurep 'emacs)
			      (string-match "^GNU" (emacs-version))))

;; load user custom file.
(load (expand-file-name "./SKK-CFG") t nil nil)

;; install.el を読み込む前に APEL_DIR へのパスを保証する
(when (stringp APEL_DIR)
  (let ((dir (expand-file-name APEL_DIR)))
    (when (file-directory-p dir)
      (add-to-list 'load-path dir))))

(when (stringp EMU_DIR)
  (let ((dir (expand-file-name EMU_DIR)))
    (when (file-directory-p dir)
      (add-to-list 'load-path dir))))

(require 'install (expand-file-name "install.el"))

(setq install-prefix
  (cond	((eq system-type 'windows-nt)
	 ;; Meadow と NTEmacs は自己完結型。これらに対して APEL が標準で
	 ;; 設定する install-prefix は不自然なので、ここで修正する。
	 (setq EMACS_SELF_CONTAINED t)
	 (if (string-match "libexec" exec-directory)
	     (expand-file-name "share/emacs"
			       (expand-file-name "../../../../" exec-directory))
	   (expand-file-name ".." exec-directory)))

	((eq system-type 'darwin)
	 ;; Mac OS X (Carbon emacs, Cocoa Emacs または OS 付属の Emacs)
	 ;; で DDSKK を build する場合は自己完結型かどうかを選べる。
	 ;; ユーザが自己完結型を使っているかどうか調べる。
	 (let ((dir (expand-file-name ".." data-directory)))
	   (if (string-match "/.+\\.app/Contents/Resources/?$" dir)
	       ;; 自己完結型
	       (progn
		 (setq EMACS_SELF_CONTAINED t)
		 dir)
	     ;; UNIX 的環境と同様
	     (expand-file-name "../../../.." data-directory))))
	((featurep 'xemacs)
	 ;; running-xemacs
	 (expand-file-name "../../.." exec-directory))
	(t
	 (expand-file-name "../../../.." data-directory))))

;;;; User variables to control SKK-MK.
(defvar SKK-MK-debugging nil "*Non-nil means making verbose output.")

;;;; load-path related.

(setq load-path (cons (expand-file-name ".") load-path))

;; 変数 install-prefix は install.el で定義されており、
;; その値は UNIX 的環境では "/usr/local" のような値となる。
;; 非 UNIX 的環境のために上記の setq で install-prefix を再設定している。
;; 非 UNIX 的環境では通常自己完結型 (self-contained) のファイル配置を
;; とる。この場合、特定のディレクトリ下に etc, info, lisp, site-lisp
;; などのディレクトリが全て含まれている。
;; (実は Emacs 18 までは UNIX 環境でも自己完結型であった。)
(unless PREFIX
  (setq PREFIX install-prefix))

(unless LISPDIR
  (setq LISPDIR
	(cond (EMACS_SELF_CONTAINED
	       ;; Meadow, NTEmacs, Carbon Emacs, Cocoa Emacs
	       (expand-file-name "site-lisp" PREFIX))
	      (t
	       (install-detect-elisp-directory PREFIX)))))

(when (stringp LISPDIR)
  (setq LISPDIR (expand-file-name LISPDIR))
  (when (file-directory-p LISPDIR)
    (add-to-list 'load-path LISPDIR)))

(unless VERSION_SPECIFIC_LISPDIR
  (setq VERSION_SPECIFIC_LISPDIR
	(cond (EMACS_SELF_CONTAINED
	       ;; Meadow, NTEmacs, Carbon Emacs, Cocoa Emacs
	       (expand-file-name "site-lisp" PREFIX))
	      (t
	       (install-detect-elisp-directory
		PREFIX nil 'version-specific)))))

(when (stringp VERSION_SPECIFIC_LISPDIR)
  (setq VERSION_SPECIFIC_LISPDIR (expand-file-name VERSION_SPECIFIC_LISPDIR))
  (when (file-directory-p VERSION_SPECIFIC_LISPDIR)
    (add-to-list 'load-path VERSION_SPECIFIC_LISPDIR)))

(when (stringp ADDITIONAL_LISPDIR)
  (setq ADDITIONAL_LISPDIR (expand-file-name ADDITIONAL_LISPDIR))
  (when (file-directory-p ADDITIONAL_LISPDIR)
    (add-to-list 'load-path VERSION_SPECIFIC_LISPDIR)))

(when SKK-MK-debugging
  (princ (format "APEL_DIR=%s\n" APEL_DIR))
  (princ (format "load-path=%s\n" load-path)))

;; After determining APEL installed dirctory.

(when (featurep 'xemacs)
  (condition-case nil
      (require 'product)		; emu
    (error
     (error "%s"
	    "DDSKK requires APEL/10.7 or later for XEmacs")))
  (unless (product-version>= 'apel-ver
			     '(10 7))
    (error "%s"
	   "DDSKK requires APEL/10.7 or later for XEmacs")))

;; constants.
(defconst SKK-MK-texinfo-coding-system 'iso-2022-7bit)

;; GENERIC VARIABLE.
(defvar DOCDIR "./doc")
(defvar ETCDIR "./etc")
(defvar DICDIR "./dic")
(defvar SKK_PREFIX "skk")
(defvar SKK_INFO "skk.info")
(defvar SKK_INFO_DIR_FILE nil) 
(defvar SKK_TEXIS '("skk.texi"))
(defvar SKK_TUTORIALS '("SKK.tut" "SKK.tut.E" "NICOLA-SKK.tut" "skk.xpm"))
(defvar SKK_DICTIONARIES
  '("SKK-JISYO.L" "SKK-JISYO.ML" "SKK-JISYO.M" "SKK-JISYO.S" "SKK-JISYO.JIS2"
    "SKK-JISYO.JIS3_4" "SKK-JISYO.pubdic+" "SKK-JISYO.edict"
    "SKK-JISYO.okinawa" "SKK-JISYO.geo" "SKK-JISYO.jinmei" "SKK-JISYO.law"
    "SKK-JISYO.mazegaki" "SKK-JISYO.assoc" "SKK-JISYO.itaiji"
    "SKK-JISYO.itaiji.JIS3_4" "SKK-JISYO.china_taiwan"
    "SKK-JISYO.propernoun" "SKK-JISYO.station" "SKK-JISYO.requested"
    "SKK-JISYO.fullname" "SKK-JISYO.JIS2004"
    "SKK-JISYO.office.zipcode" "SKK-JISYO.zipcode" "SKK-JISYO.lisp"))

(setq SKK_DICTIONARIES
      (append SKK_DICTIONARIES
	      (mapcar (lambda (dic)
			(format "%s.cdb" dic))
		      SKK_DICTIONARIES)))

(defvar SKK_DEFAULT_JISYO nil)

(defvar SKK_MODULES
  ;; こんなもんコマンドラインで指定する人いないよね？
  (let ((list '(cdb
		context-skk
		skk-abbrev
		skk-act
		skk-annotation
		skk-auto
		skk-autoloads
		skk-azik
		skk-bayesian
		skk-cdb
		skk-comp
		skk-cursor
		skk-cus
		skk-dcomp
		skk-develop
		skk-gadget
		skk-hint
		skk-inline
		skk-isearch
		skk-jisx0201
		;; skk-jisx0213
		skk-jisyo-edit-mode
		skk-kakasi
		skk-kcode
		skk-leim
		skk-look
		;; skk-lookup
		skk-macs
		skk-num
		;; skk-obsolete
		skk-search-web
		skk-server-completion
		skk-server
		skk-show-mode
		skk-sticky
		skk-tankan
		skk-tut
		skk-vars
		skk-version
		skk
		;; EXPERIMENTAL
		skk-correct
		skk-exsearch
		skk-exserv
		skk-rdbms
		skk-study
		skk-tutcdef
		skk-tutcode
		skk-w3m
		;; VIP 3.7
		;; vip
		)))
    (cond
     ((featurep 'xemacs)
      ;; XEmacs
      (when (or (featurep 'gdbm)
		(featurep 'dbm)
		(featurep 'berkdb)
		(featurep 'berkeley-db))
	(add-to-list 'list 'skk-dbm))
      (add-to-list 'list 'skk-xemacs))
     (running-gnu-emacs
      ;; FSFmacs
      (add-to-list 'list 'ccc)
      (add-to-list 'list 'skk-emacs)))
    ;; skk-jisx0213.el
    (when (or (coding-system-p 'euc-jisx0213)
	      (and (fboundp 'find-coding-system)
		   (find-coding-system 'euc-jisx0213))
	      (condition-case nil
		  (and (require 'jisx0213)
		       (require 'un-define))
		(error)))
      (add-to-list 'list 'skk-jisx0213))
    ;; skk-lookup.el
    (when (condition-case nil
	      ;; you might have to add lookup installed directory
	      ;; to `load-path'.
	      (let ((lookup-byte-compile t))
		(require 'lookup))
	    (error))
      (add-to-list 'list 'skk-lookup))
    ;; skk-w3m.el
    ;;(when (condition-case nil
    ;;          (require 'w3m-search)
    ;;        (error))
    ;;  (add-to-list 'list 'skk-w3m))
    ;; skk-viper.el
    (when (condition-case nil
	      (require 'viper)
	    (error))
      (add-to-list 'list 'skk-viper))
    ;;
    list))

;; 消さなくともインストール上は問題がないが、what-where にてインストールされな
;; いプログラムが表示されるのを防ぐため、トップディレクトリにないプログラムは
;; 消しておく。
(let ((modules SKK_MODULES))
  (while modules
    (unless (or
	     ;; skk-autoloads.el は自動生成されるのでまだ存在しない。
	     (memq (car modules) '(skk-autoloads))
	     (file-exists-p (concat (symbol-name (car modules))
				    ".el")))
      (setq SKK_MODULES (delq (car modules) SKK_MODULES)))
    (setq modules (cdr modules))))

(defun SKK-MK-server-installed-p ()
  ;; Check whether we can talk to the server.
  (require 'skk-server (expand-file-name "skk-server.el"))
  (let ((skk-server-inhibit-startup-server t))
    (condition-case nil
	(prog1
	    (skk-server-live-p (skk-open-server))
	  (skk-disconnect-server))
      (error))))

(defvar SKK_SET_JISYO (not (SKK-MK-server-installed-p)))

;; NON-PACKAGE INSTALL RELATED VARIABLE.
(defvar SKK_DATADIR
  (cond ((and (eq system-type 'windows-nt)
	      (string-match "libexec" exec-directory))
	 (expand-file-name "skk" data-directory))
	(t
	 (let ((subdir (cond (EMACS_SELF_CONTAINED
			      ;; Meadow, NTEmacs, Carbon Emacs, Cocoa Emacs
			      "etc")
			     (t
			      "share"))))
	   (expand-file-name SKK_PREFIX (expand-file-name subdir PREFIX))))))

(defvar SKK_INFODIR
  (cond ((file-directory-p
	  (expand-file-name "info" (expand-file-name "share" PREFIX)))
	 (expand-file-name "info" (expand-file-name "share" PREFIX)))

	((file-directory-p (expand-file-name "info" PREFIX))
	 (expand-file-name "info" PREFIX))

	((file-directory-p
	  (expand-file-name "info" (expand-file-name ".." PREFIX)))
	 (expand-file-name "info" (expand-file-name ".." PREFIX)))

	(t
	 (let ((list Info-default-directory-list)
	       dir)
	   (while (and (not dir)
		       list)
	     (when (file-directory-p (car list))
	       (setq dir (car list)))
	     (setq list (cdr list)))
	   dir)))
  (expand-file-name "info" PREFIX))

(defvar SKK_LISPDIR
  (cond
   (VERSION_SPECIFIC_LISPDIR
    (expand-file-name SKK_PREFIX VERSION_SPECIFIC_LISPDIR))
   (PREFIX
    (expand-file-name SKK_PREFIX
		      (install-detect-elisp-directory
		       PREFIX)))
   (t
    nil)))

(defconst SKK_DAREDEVIL_NOT_USE '(skk-vip
				  skk-foreword
				  stack-m
				  skk-cursor2
				  skk-cursor3))

;; PACKAGE INSTALL RELATED VARIABLE.
(defvar PACKAGEDIR (install-get-default-package-directory))

(defvar PACKAGE_INFODIR (expand-file-name "info" PACKAGEDIR))

(defvar PACKAGE_DATADIR (expand-file-name
			 SKK_PREFIX
			 (expand-file-name "etc" PACKAGEDIR)))

(defvar PACKAGE_LISPDIR (expand-file-name
			 SKK_PREFIX
			 (expand-file-name "lisp" PACKAGEDIR)))

(when SKK-MK-debugging
  (princ (format "SKK_MODULES=%s\n" SKK_MODULES)))

;; This code is for skk-jisx0201.el.
(when (fboundp 'make-translation-table) ;; FSF Emacs 20.3 or later
  (setq standard-translation-table-for-decode
	(make-translation-table nil)))

;;; [FUNCTIONS]
(defun SKK-MK-make-setup-file (spec)
  ;; SPEC は交代リスト。
  (with-temp-buffer
    (save-excursion
      (insert-file-contents "skk-setup.el.in")
      (goto-char (point-min))
      (when (looking-at ";;; -\\*- emacs-lisp -\\*-")
	(delete-region (point) (progn
				 (forward-line 1)
				 (point))))
      (when (search-forward ";;; skk-setup.el --- initial setup for SKK")
	(forward-line 1)
	(insert ";; This file was generated automatically by SKK-MK at "
		(current-time-string)
		"\n"))
      (while spec
	(goto-char (point-min))
	(while (re-search-forward (concat "^;;[^@]+\\(" (car spec) "\\)")
				  nil t nil)
	  (delete-region (match-beginning 1)
			 (match-end 1))
	  (insert (nth 1 spec))
	  (beginning-of-line)
	  (while (looking-at ";")
	    (delete-char 1)))
	(setq spec (nthcdr 2 spec)))
      (write-region (point-min) (point-max) "skk-setup.el"))))

(defun SKK-MK-compile ()
  (let (enable-local-eval)
    (SKK-MK-generate-autoloads-el)
    (load (expand-file-name "skk-autoloads.el"))
    (require 'skk (expand-file-name "skk.el"))
    (compile-elisp-modules SKK_MODULES
			   (expand-file-name "."))))

(defun SKK-MK-compile-info ()
  (when (and SKK_INFO
	     (or (not (file-exists-p
		       (expand-file-name SKK_INFO DOCDIR)))
		 (file-newer-than-file-p
		  (expand-file-name (car SKK_TEXIS) DOCDIR)
		  (expand-file-name SKK_INFO DOCDIR))))
    (SKK-MK-texinfo-format SKK_TEXIS)))

(defun SKK-MK-compile-package ()
  (SKK-MK-generate-autoloads-el-package)
  (setq features (delq 'skk-autoloads features))
  (require 'skk-autoloads (expand-file-name "auto-autoloads.el"))
  (require 'skk (expand-file-name "skk.el"))
  (autoload 'custom-add-loads "cus-load")
  (compile-elisp-modules
   SKK_MODULES
   (expand-file-name ".")))

(defun SKK-MK-install ()
  (SKK-MK-install-elc)
  (SKK-MK-install-info))

(defun SKK-MK-install-elc ()
  (let ((dics SKK_DICTIONARIES)
	;;standard-output
	delete-target exists spec)
    ;; make target directories.
    (setq DOCDIR (expand-file-name DOCDIR)
	  ETCDIR (expand-file-name ETCDIR)
	  DICDIR (expand-file-name DICDIR))
    (unless (file-exists-p SKK_LISPDIR)
      (make-directory SKK_LISPDIR t))
    (unless (file-exists-p SKK_DATADIR)
      (make-directory SKK_DATADIR t))
    ;; delete already installed unnecessary files.
    (while SKK_DAREDEVIL_NOT_USE
      (setq SKK_MODULES (delq (car SKK_DAREDEVIL_NOT_USE)
			      SKK_MODULES)
	    delete-target (expand-file-name
			   (concat (prin1-to-string
				    (car SKK_DAREDEVIL_NOT_USE))
				   ".el")
			   SKK_LISPDIR)
	    SKK_DAREDEVIL_NOT_USE (cdr SKK_DAREDEVIL_NOT_USE))
      (when (file-exists-p delete-target)
	(delete-file delete-target))
      (setq delete-target (concat delete-target "c"))
      (when (file-exists-p delete-target)
	(delete-file delete-target)))
    ;; install Emacs Lisp programs.
    (SKK-MK-compile)
    (install-elisp-modules SKK_MODULES "." SKK_LISPDIR)
    (delete-file "./skk-autoloads.el")
    ;; make skk-setup.el.
    (while dics
      (when (file-exists-p (expand-file-name (car dics) DICDIR))
	(setq exists (cons (car dics) exists)))
      (setq dics (cdr dics)))
    (setq SKK_DICTIONARIES exists)
    ;; move existing largest dictionay to car of `SKK_DICTIONARIES'.
    (when (member "SKK-JISYO.M" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.M"
		  (delete "SKK-JISYO.M"
			  SKK_DICTIONARIES))))
    (when (member "SKK-JISYO.ML" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.ML"
		  (delete "SKK-JISYO.ML"
			  SKK_DICTIONARIES))))
    (when (member "SKK-JISYO.L" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.L"
		  (delete "SKK-JISYO.L"
			  SKK_DICTIONARIES))))
    (when SKK_TUTORIALS
      (setq spec (append
		  spec
		  (list "@TUT@"
			(expand-file-name
			 (car SKK_TUTORIALS) SKK_DATADIR)))))
    (cond
     (SKK_DICTIONARIES
      (setq spec
	    (append spec
		    (list "@AUXDIC@"
			  (expand-file-name
			   (car SKK_DICTIONARIES) SKK_DATADIR))))
      (when SKK_SET_JISYO
	(setq spec
	      (append spec
		      (list
		       "@DIC@"
		       (expand-file-name
			(car SKK_DICTIONARIES) SKK_DATADIR))))))
     (t
      ;; when dictionaries do not exist in ./dic subdirectory, check
      ;; already installed dictionary and detect largest one to setup
      ;; skk-setup.el.in.
      (setq dics '("SKK-JISYO.L"
		   "SKK-JISYO.ML"
		   "SKK-JISYO.M"
		   "SKK-JISYO.S"))
      (while (and dics
		  (not (file-exists-p (expand-file-name
				       (car dics)
				   SKK_DATADIR))))
	(setq dics (cdr dics)))
      (when dics
	(setq spec
	      (append spec
		      (list "@AUXDIC@"
			    (expand-file-name
			     (car dics)
			     SKK_DATADIR))))
	(when SKK_SET_JISYO
	  (setq spec
		(append spec
			(list "@DIC@"
			      (expand-file-name
			       (car dics)
			       SKK_DATADIR))))))))
    (if (not spec)
	;; merely copy without setup dictionary information.
	(copy-file "skk-setup.el.in"
		   "skk-setup.el"
		   'ok-if-already-exists)
      (SKK-MK-make-setup-file spec))
    (when SKK_DICTIONARIES
      ;; install dictionaries if the files exist in ./dic directory.
      (install-files SKK_DICTIONARIES
		     DICDIR
		     SKK_DATADIR
		     nil t nil))
    (when running-gnu-emacs
      (copy-file "./leim-list.el.in"
		 "./leim-list.el"
		 'overwrite)
      (install-elisp-modules (list 'leim-list)
			     "."
			     SKK_LISPDIR)
      (delete-file "./leim-list.el"))
    ;; install skk-setup.el
    (install-elisp-modules (list 'skk-setup) "." SKK_LISPDIR)
    ;; install tutorials.
    (install-files SKK_TUTORIALS ETCDIR SKK_DATADIR nil t nil)
    (SKK-MK-detect-shadow-directory)))

(defun SKK-MK-detect-shadow-directory ()
  (condition-case nil
      (progn
	(require 'shadow)
	(save-match-data
	  (let ((list (find-emacs-lisp-shadows load-path))
		shadowed)
	    (while list
	      (if (and (string-match "skk-autoloads"
				     (car list))
		       (setq list (cdr list))
		       (string-match "skk-autoloads"
				     (car list)))
		  (setq shadowed
			(substring
			 (file-name-directory (car list))
			 0 -1)
			list nil))
	      (setq list (cdr list)))
	    (when shadowed
	      (princ (format "\
** WARNING ** %s is shadowed.  You might want to remove it
"
			     shadowed))))))
    (error)))

(defun SKK-MK-install-info ()
  (when SKK_INFO
    (unless (file-exists-p SKK_INFODIR)
      (make-directory SKK_INFODIR t))
    (SKK-MK-compile-info)
    (install-files (list SKK_INFO)	;defun in install.el
		   DOCDIR
		   SKK_INFODIR
		   nil t nil)
    (when noninteractive
      (SKK-MK-install-info-1))))

(defun SKK-MK-install-info-1 ()
  "Updates info/dir entries."
  (when SKK_INFO
    ;; updates info/dir entries.
    (require 'install-info (expand-file-name "install-info.el"))
    (let ((info-file (expand-file-name SKK_INFO
				       SKK_INFODIR))
	  (dir-file (cond
		     ((file-exists-p (expand-file-name "dir" SKK_INFODIR))
		      (expand-file-name "dir" SKK_INFODIR))
		     ((file-exists-p (expand-file-name "dir.info" SKK_INFODIR))
		      (expand-file-name "dir.info" SKK_INFODIR))
		     (t
		      (expand-file-name "dir" SKK_INFODIR)))))
      (when (file-readable-p dir-file)
	(install-info info-file dir-file nil nil 'delete))
      (install-info info-file dir-file nil nil nil)
      (setq SKK_INFO_DIR_FILE dir-file))))

(defun SKK-MK-install-package ()
  (unless (featurep 'xemacs)
    (error "%s" "This directcive is only for XEmacs."))
  (let ((dics SKK_DICTIONARIES)
	delete-target exist spec)
    ;; make target directories.
    (unless (file-exists-p PACKAGE_LISPDIR)
      (make-directory PACKAGE_LISPDIR t))
    (unless (file-exists-p PACKAGE_DATADIR)
      (make-directory PACKAGE_DATADIR t))
    (unless (file-exists-p PACKAGE_INFODIR)
      (make-directory PACKAGE_INFODIR t))
    ;; delete already installed unnecessary files.
    (setq SKK_MODULES (delq 'skk-autoloads
			    (append
			     SKK_MODULES
			     '(auto-autoloads custom-load))))
    (while SKK_DAREDEVIL_NOT_USE
      (setq SKK_MODULES (delq
			 (car SKK_DAREDEVIL_NOT_USE)
			 SKK_MODULES)
	    delete-target (expand-file-name
			   (concat
			    (prin1-to-string
			     (car SKK_DAREDEVIL_NOT_USE))
			    ".el")
			   PACKAGE_LISPDIR)
	    SKK_DAREDEVIL_NOT_USE (cdr SKK_DAREDEVIL_NOT_USE))
      (when (file-exists-p delete-target)
	(delete-file delete-target))
      (setq delete-target (concat delete-target "c"))
      (when (file-exists-p delete-target)
	(delete-file delete-target)))
    ;; install Emacs Lisp programs.
    (SKK-MK-compile-package)
    (install-elisp-modules SKK_MODULES "." PACKAGE_LISPDIR)
    (delete-file "./auto-autoloads.el")
    (delete-file "./custom-load.el")
    ;; make skk-setup.el.
    (when SKK_TUTORIALS
      (setq spec (list
		  "@TUT@"
		  (expand-file-name
		   (car SKK_TUTORIALS)
		   PACKAGE_DATADIR))))
    (while dics
      (when (file-exists-p (expand-file-name
			    (car dics)
			    DICDIR))
	(setq exist (cons (car dics) exist)))
      (setq dics (cdr dics)))
    (setq SKK_DICTIONARIES exist)
    ;; move existing largest dictionay to car of `SKK_DICTIONARIES'.
    (when (member "SKK-JISYO.M" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.M" (delete "SKK-JISYO.M"
					SKK_DICTIONARIES))))
    (when (member "SKK-JISYO.ML" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.ML"
		  (delete "SKK-JISYO.ML"
			  SKK_DICTIONARIES))))
    (when (member "SKK-JISYO.L" SKK_DICTIONARIES)
      (setq SKK_DICTIONARIES
	    (cons "SKK-JISYO.L" (delete "SKK-JISYO.L"
					SKK_DICTIONARIES))))
    (cond
     (SKK_DICTIONARIES
      (setq spec
	    (append spec
		    (list "@AUXDIC@"
			  (expand-file-name
			   (car SKK_DICTIONARIES)
			   PACKAGE_DATADIR))))
      (when SKK_SET_JISYO
	(setq spec
	      (append spec
		      (list "@DIC@"
			    (expand-file-name
			     (car SKK_DICTIONARIES)
			     PACKAGE_DATADIR)))))
      ;; install dictionaries if the files exist in ./dic directory.
      (install-files SKK_DICTIONARIES
		     DICDIR
		     PACKAGE_DATADIR nil t nil))
     (t
      ;; when dictionaries do not exist in ./dic subdirectory, check
      ;; already installed dictionary and detect largest one to setup
      ;; skk-setup.el.in.
      (setq dics '("SKK-JISYO.L"
		   "SKK-JISYO.ML"
		   "SKK-JISYO.M"
		   "SKK-JISYO.S"))
      (while (and dics
		  (not (or (file-exists-p (expand-file-name
					   (car dics) PACKAGE_DATADIR))
			   (file-exists-p (expand-file-name
					   (car dics) SKK_DATADIR)))))
	(setq dics (cdr dics)))
      (when dics
	(let ((dic
	       (if (file-exists-p (expand-file-name
				   (car dics) PACKAGE_DATADIR))
		   (expand-file-name (car dics) PACKAGE_DATADIR)
		 (expand-file-name (car dics) SKK_DATADIR))))
	  (setq spec (nconc spec (list "@AUXDIC@" dic)))
	  (when SKK_SET_JISYO
	    (setq spec (nconc spec (list "@DIC@" dic))))))))
    (if (not spec)
	;; merely copy without setup dictionary information.
	(copy-file "skk-setup.el.in"
		   "skk-setup.el"
		   'ok-if-already-exists)
      (SKK-MK-make-setup-file spec))
    ;; install skk-setup.el
    (install-elisp-modules (list 'skk-setup) "." PACKAGE_LISPDIR)
    ;; install infos.
    (SKK-MK-compile-info)
    (when SKK_INFO
      (let ((files (list SKK_INFO))
	    (i 1)
	    file)
	(while (file-exists-p
		(expand-file-name
		 (setq file (format "%s-%d" SKK_INFO i))
		 DOCDIR))
	  (setq files (cons file files))
	  (setq i (1+ i)))
	(install-files (nreverse files) DOCDIR
		       PACKAGE_INFODIR nil t nil)))
    ;; install tutorials.
    (install-files SKK_TUTORIALS ETCDIR
		   PACKAGE_DATADIR nil t nil)
    (SKK-MK-detect-shadow-directory)))

(defun SKK-MK-texinfo-pre-format ()
  ;; (unless (and (featurep 'emacs)
  ;; 	       (>= emacs-major-version 23))
  ;;   (dolist (str '("\C-[$(Q\"1\C-[(B" "\C-[$(Q\"Q\C-[(B" "\C-[$(Q\"q\C-[(B"))
  ;;     (goto-char (point-min))
  ;;     (when (search-forward str nil t)
  ;; 	(replace-match " "))))
  nil)

(defun SKK-MK-texinfo-post-format ()
  (goto-char (point-min))
  (when (re-search-forward "-\\*-Text-\\*-" (point-at-eol) t)
    (replace-match (format "-*- mode: text; coding: %s -*-"
			   SKK-MK-texinfo-coding-system))))

(defun SKK-MK-texinfo-format (targets)
  (let (;; Emacs20.2's default is 'raw-text-unix.
	(coding-system-for-write SKK-MK-texinfo-coding-system)
	x obuf beg standard-output)
    (require 'ptexinfmt (expand-file-name "ptexinfmt.el"))
    (while targets
      (setq x (expand-file-name (car targets) DOCDIR))
      (find-file x)
      (setq obuf (current-buffer))
      (SKK-MK-texinfo-pre-format)
      (texinfo-every-node-update)
      (texinfo-format-buffer 'nosplit)
      (SKK-MK-texinfo-post-format)
      (basic-save-buffer)
      (kill-buffer (current-buffer))	; .info buffer
      (set-buffer-modified-p nil)	; .texi buffer
      (kill-buffer obuf)		; .texi buffer
      (setq targets (cdr targets)))))

(defun SKK-MK-what-where ()
  (interactive)
  (let ((string
	 (format "
Running in:
  %s

SKK modules:
  %s
  -> %s

SKK infos:
  %s
  -> %s

SKK tutorials:
  %s
  -> %s
"
		 (version)
		 (mapconcat 'symbol-name SKK_MODULES ", ")
		 SKK_LISPDIR
		 SKK_INFO
		 SKK_INFODIR
		 (mapconcat 'identity SKK_TUTORIALS ", ")
		 SKK_DATADIR)))
    (if noninteractive
	(princ string)
      (progn
	(with-output-to-temp-buffer
	    "*What where*" (princ string))
	(message "")))))

(defun SKK-MK-what-where-package ()
  (interactive)
  (unless (featurep 'xemacs)
    (error "%s" "This directive is only for XEmacs."))
  (let ((string
	 (format "
Running in:
  %s

SKK modules:
  %s
  -> %s

SKK infos:
  %s
  -> %s

SKK tutorials:
  %s
  -> %s
"
		 (version)
		 (mapconcat 'symbol-name
			    (delq 'skk-autoloads SKK_MODULES)
			    ", ")
		 PACKAGE_LISPDIR
		 SKK_INFO
		 PACKAGE_INFODIR
		 (mapconcat 'identity SKK_TUTORIALS ", ")
		 PACKAGE_DATADIR)))
    (if (interactive-p)
	(progn
	  (with-output-to-temp-buffer
	      "*What where*" (princ string))
	  (message ""))
      (princ string))))

(defun SKK-MK-generate-autoloads-el ()
  "Generate skk-autoload.el."
  (let ((modules SKK_MODULES)
	(buf (get-buffer-create
	      " *SKK-MK-generate-autoloads-el*"))
	(sort-min)
	(funcs)
	standard-output)
    (save-excursion
      (set-buffer buf)
      (erase-buffer)
      (insert "\
;;; skk-autoloads.el --- autoload settings for SKK  -*- coding: iso-2022-jp -*-

;; This file was generated automatically by SKK-MK at "
	      (current-time-string)
	      ".

;; This file is part of Daredevil SKK.

;; Daredevil SKK is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or
;; (at your option) any later version.

;; Daredevil SKK is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with Daredevil SKK, see the file COPYING.  If not, write to the
;; Free Software Foundation Inc., 51 Franklin Street, Fifth Floor, Boston,
;; MA 02110-1301, USA.

;;; Code:\n\n")
      (require 'autoload)
      (setq buffer-file-name "skk-autoloads.el")
      (while modules
	(let ((file (expand-file-name
		     (format "%s.el" (car modules)))))
	  (when (file-exists-p file)
	    (generate-file-autoloads file)))
	(setq modules (cdr modules)))
      (goto-char (point-max))
      (insert "(provide 'skk-autoloads)
;;; skk-autoloads.el ends here
")
      (let ((coding-system-for-write 'iso-2022-jp))
	(write-region (point-min) (point-max) "skk-autoloads.el" nil 'quiet))
      (set-buffer-modified-p nil)
      (kill-buffer buf))))

(defun SKK-MK-generate-autoloads-el-package ()
  "Generate auto-autoload.el."
  (let ((modules SKK_MODULES))
    (with-temp-buffer
      (dolist (module modules)
	(let ((file (expand-file-name
		     (format "%s.el" module))))
	  (when (file-exists-p file)
	    (generate-file-autoloads file))))
      (let ((generated-autoload-file
	     (expand-file-name "auto-autoloads.el")))
	(setq buffer-file-name generated-autoload-file)
	(if (fboundp 'autoload-featurep-protect-autoloads)
	    ;; XEmacs 21.5
	    (autoload-featurep-protect-autoloads "skk-autoloads")
	  ;; XEmacs 21.4
	  (fixup-autoload-buffer "skk-autoloads"))
	(goto-char (point-max))
	(unless (bolp)
	  (insert "\n"))
	(let ((coding-system-for-write 'iso-2022-jp))
	  (write-region (point-min) (point-max) generated-autoload-file))))
    (add-to-list 'command-line-args-left ".")
    (Custom-make-dependencies)))

;;; DDSKK Interactive Installer (Jan 2011)
;;;   Lookup の install.el を参考にさせていただきました。

(defun install-check-directory (directory)
  (and (not (file-exists-p directory))
       (y-or-n-p (format "Directory %s is not exist. Create it? " directory))
       (make-directory directory t))
  (if (not (file-directory-p directory))
      (error "%s is not directory" directory))
  (directory-file-name (expand-file-name directory)))

(defvar VERSION-STRING nil)
(setq VERSION-STRING
      (let (start)
	(with-temp-buffer
	  (insert-file-contents "skk-version.el")
	  (goto-char (point-min))
	  (search-forward "'version-string ")
	  (forward-char)
	  (setq start (point))
	  (search-forward (char-to-string 34))
	  (buffer-substring start (1- (point))))))

(if noninteractive
    nil
  (switch-to-buffer (generate-new-buffer "*DDSKK Installer*"))
  (insert (version))
  (insert "\n===================\n")
  (insert "DDSKK インストーラ\n")
  (insert "===================\n\n")
  (insert "DDSKK "
	  VERSION-STRING
	  " のインストールを始めます。\n")
  (insert "C-g をタイプすると、いつでも中断できます。\n\n")

  (insert "DDSKK のインストール先を入力してください:\n")
  (setq SKK_LISPDIR (install-check-directory
		     (read-file-name "SKK_LISPDIR: " SKK_LISPDIR SKK_LISPDIR)))
  (insert "  => " SKK_LISPDIR "\n\n") (sit-for 0)

  (insert "Info ファイルを置くディレクトリを入力してください:\n")
  (setq SKK_INFODIR (install-check-directory
		     (read-file-name "SKK_INFODIR: " SKK_INFODIR SKK_INFODIR)))
  (insert "  => " SKK_INFODIR "\n\n") (sit-for 0)

  (insert "チュートリアル・ファイルを置くディレクトリを入力してください:\n")
  (setq SKK_DATADIR (install-check-directory
		     (read-file-name "SKK_DATADIR: " SKK_DATADIR SKK_DATADIR)))
  (insert "  => " SKK_DATADIR "\n\n") (sit-for 0)

  (insert "確認してください。\n")
  (insert (format "SKK modules: %s\n  => %s\n\n"
		  (mapconcat 'symbol-name SKK_MODULES ", ")
		  SKK_LISPDIR))
  (insert (format "SKK infos: %s\n  => %s\n\n"
		  SKK_INFO
		  SKK_INFODIR))
  (insert (format "SKK tutorials: %s\n  => %s\n\n"
		  (mapconcat 'identity SKK_TUTORIALS ", ")
		  SKK_DATADIR))
  (insert "各ディレクトリを訂正するには、このインストーラを中断（C-g をタイプ）して最初からやり直してください（SKK-CFG で設定することも可能です）。\n")
  (if (yes-or-no-p "インストールを続行しますか？ ")
      nil
    (error "インストールを中断しました。")))

;; SKK-MK-compile
(if noninteractive
    nil
  (let (enable-local-eval)
    (insert "skk-autoloads.el を生成中...") (sit-for 0)
    (SKK-MK-generate-autoloads-el)
    (insert "done\n")

    (insert "skk-autoloads.el を読み込み中...") (sit-for 0)
    (load (expand-file-name "skk-autoloads.el"))
    (insert "done\n")

    (insert "skk.el を読み込み中...") (sit-for 0)
    (require 'skk (expand-file-name "skk.el"))
    (insert "done\n")

    (insert "elisp ファイルのコンパイル中...") (sit-for 0)
    (compile-elisp-modules SKK_MODULES
			   (expand-file-name "."))
    (switch-to-buffer (get-buffer "*DDSKK Installer*"))
    (insert "done\n")))

;; SKK-MK-install
;; SKK-MK-install-elc
(if noninteractive
    nil
  (insert "elisp ファイルのインストール中...") (sit-for 0)
  (SKK-MK-install-elc)
  (switch-to-buffer (get-buffer "*DDSKK Installer*"))
  (insert "done\n"))

;; SKK-MK-install-info
(if noninteractive
    nil
  (insert "info のインストール中...") (sit-for 0)
  (SKK-MK-install-info)
  (insert "done\n")

  (insert "info/dir ノード追加中...") (sit-for 0)
  (SKK-MK-install-info-1)
  (insert "done\n"))

;; Congratulations!
(if noninteractive
    nil
  (insert "\n\nCongratulations!\nDDSKK のインストールが完了しました。

load-path の設定
----------------
次のとおり 変数 load-path を設定してください。既にパスが通っているならば不要です。
  (setq load-path (cons \"" SKK_LISPDIR "\" load-path))

info ディレクトリの設定
-----------------------
次のとおり 変数 Info-default-directory-list を設定してください。既にパスが通っているならば不要です。
  (setq Info-default-directory-list
        (cons \"" SKK_INFODIR "\" Info-default-directory-list))

ディレクトリファイル " SKK_INFO_DIR_FILE " へのノード追加は完了しています。

以上で終了です。

Emacs を再起動すると DDSKK を使用することができます。
etc/dot.emacs と etc/dot.skk に設定例が挙げられていますので参考にしてください。
Info もお読みください。
"))

(if noninteractive
    nil
  (delete-other-windows)
  (recenter -1)
  (remove-hook 'kill-emacs-hook 'skk-save-jisyo))

;;; SKK-MK ends here
