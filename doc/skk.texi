\input texinfo @c -*-texinfo-*- coding: iso-2022-jp -*-
@setfilename skk.info
@settitle The SKK Manual
@c 
@c  Author: Masahiko Sato <masahiko@kuis.kyoto-u.ac.jp>
@c          Yukiyoshi Kameyama <kameyama@@kuis.kyoto-u.ac.jp>
@c          Mikio Nakajima <minakaji@osaka.email.ne.jp>
@c  Maintainer: SKK Development Team <skk@ring.gr.jp>
@c  Version: $Id: skk.texi,v 1.53 2000/10/22 16:46:44 czkmt Exp $
@c  Keywords: japanese
@c  Last Modified: $Date: 2000/10/22 16:46:44 $
@c
@set EDITION 1.4
@set SKK-VERSION 10.62
@set UPDATED $Date: 2000/10/22 16:46:44 $
@c @set UPDATED-MONTH Oct 1998

@direntry
* SKK: (skk).         Simple Kana to Kanji conversion program
@end direntry

@c Texinfo に追加できたら良いなぁと思う点を述べます。私、単なる LaTeX ユー
@c ザーで、Plain TeX マクロの組み方なんて全然知りませんので、ユーザーの立場
@c でやりたいことを卒直に、また無責任に述べるに留めます。あしからず。実現で
@c きる方法をご存知の方がいらっしゃいましたら、是非教えて下さい。
@c
@c (1)日本語の用語についてゴシック体でプリントアウトし、info では "「" 
@c    と "」" を自動的に付けるような@jdfn{}が欲しい。本書では、日本語
@c    の用語定義をとりあえず`「',`」' で囲み、@b コマンドでゴシック体を
@c    出力するようにしている。
@c
@c (2)アスキー文字と全角文字を連接して書いたとしても pTeX がその間に適切
@c    に空白を挿入して印刷してくれる。一方 info は連接したままで空白は挿
@c    入されないので少し見にくい気がする。info ではアスキー文字と全角文
@c    字との間に半角スペースを挿入してはどうか？
@c
@c (3)LaTeX の表を書くコマンドを実装して欲しい (なら Latexinfo を使えと
@c    は言わないでね。互換性が大きく損なわれるから嫌なんです)。

@synindex pg cp
@footnotestyle end
@iftex
@afourpaper
@end iftex
@ifinfo
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@title The SKK Manual
@subtitle Edition @value{EDITION}for SKK Version @value{SKK-VERSION}
@c @subtitle @value{UPDATED-MONTH}
@subtitle @value{UPDATED}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{}1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999
@w{Masahiko Sato}(佐藤雅彦), @*
@w{Yukiyoshi Kameyama}(亀山幸義) and @w{Mikio Nakajima}(中島幹夫).
Revised by @w{Kiyotaka Sakai}(酒井清隆) and @w{Satoshi Harauchi}(原内聡).

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.

@end titlepage
@page
@ifinfo
@node Top, はじめに, (dir), (dir)
@top SKK

(最終更新日: @value{UPDATED})

これは @cite{SKK マニュアル} 第 @value{EDITION} 版です。
SKK のバージョン @value{SKK-VERSION} に対応しています。


@menu
* はじめに::                    
* インストール::                
* はじめの設定::                
* 基本的な使い方::              
* 便利な応用機能::              
* 辞書ツール::                  
* 旧バージョンからの変更点::    
* 拡張アイディア::              
* SKKメーリングリスト::         
* SKKの入手方法::               
* SKK関連ソフトウェア::         
* 最新情報など::                
* 事項索引::                    
* 変数索引::                    
* 関数索引::                    
* キー索引::                    
@end menu
@end ifinfo

@node はじめに, インストール, Top, Top
@comment  node-name,  next,  previous,  up
@chapter はじめに

SKK version 10 は高速で効率的な日本語入力環境を提供するシステムです。
GNU General Public License に従ったフリー・ソフトウェアとして配布されます。

SKK 10 が動作を保証する Emacsen のバージョンは下記の通りです。

@itemize @minus
@item Emacs 19.28 以降をベースとした Mule 2.3 (Mule for Windows 1.21,
1.22 を含む)
@item Emacs 20.2 以降 (Meadow 1.00 以降 を含む)
@item Mule 機能付きでコンパイルされた XEmacs 20.4 以降
@end itemize

SKK は、Simple Kana to Kanji conversion program にちなんで名付けられました。

主な特徴は、次の通りです。

@itemize @bullet
@item ローマ字入力による、文法的知識を用いない高速変換可能な日本語入力/変換。
@item 辞書に登録されていない単語の登録が簡単。
@item 個人辞書への単語の自動登録による変換の高ヒット。
@item マイナーモードとして実装されているので、メジャーモードにほとんど影
響を与えない。つまり、Emacs との親和性が高い。
@item SKK 本体(Emacs Lisp) と辞書のみで動作(サーバは必須ではない)。辞
書サーバがダウンしていても使用できる。
@item 辞書サーバを使うことで、Emacs の SKK 使用メモリを削減可能。
@item ディスク容量に応じて選べる辞書。
@item SKK と同様の操作で行える日本語インクリメンタルサーチ。
@item Emacs Lisp で書かれたプログラムを変換候補にできる。
@item 個人の設定により、ローマ字入力の代わりに T-Code、TUT-code による入
力も可能。
@end itemize

@node インストール, はじめの設定, はじめに, Top
@comment  node-name,  next,  previous,  up
@chapter インストール
@cindex インストール

@menu
* APEL のインストール::         
* SKK のインストール::          
@end menu

@node APEL のインストール, SKK のインストール, インストール, インストール
@comment  node-name,  next,  previous,  up
@section APEL のインストール

SKK 10 は種々の Emacsen での動作を可能とするため APEL (A Portable Emacs
Library) を使用します。SKK 10 は APEL 9.22 での動作を確認していますが、
APEL は Emacs/XEmacs のバージョンアップに合わせて日進月歩なので、できる
だけ新しいバージョンをインストールすることをお勧めします。

@samp{ftp://ftp.jpl.org/pub/elisp/apel/}

 もしくは

@samp{ftp://ftp.m17n.org/pub/mule/apel/}

より入手できます。

SKK のインストールをする前に APEL をインストールして下さい。

@xref{Q.2-4 APEL って何ですか？, APEL}.

@node SKK のインストール,  , APEL のインストール, インストール
@comment  node-name,  next,  previous,  up
@section SKK のインストール

APEL をインストールしたら、 SKK をインストールしましょう。ここでは、
UNIX 上で make コマンドが用意されている場合を想定しています@footnote{
Windows 環境では、make.bat を使用することにより、同様の操作でインストール
できます。 @file{READMEs/README.win} ファイルを参照して下さい。
cygnus環境をインストールされている方は make コマンドが使用できるので、ここ
の説明がそのまま当てはまります。}。

まず、tar と gzip コマンドを使用して、 SKK を書庫
(@file{skk-VERSION.tar.gz})から取り出します。

  @w{@code{gzip -d skk-VERSION.tar.gz}}
  @w{@code{tar xf skk-VERSION.tar}}

SKK のトップディレクトリ(@file{ChangeLog} や @file{Makefile} の
あるディレクトリ)をカレントディレクトリにします。

  @w{@code{make what-where}}

と実行すると、どのディレクトリにインストールされるか確認できます。
ここで、SKK のインストール先ディレクトリが表示されない場合は、APEL の 
PATH を @file{SKK-CFG} に記入します。@file{SKK-CFG} に設定方法が書いてあり
ます。また、インストール先ディレクトリを変更したい場合も、@file{SKK-CFG} 
ファイルを編集することにより指定できます。

つぎにスーパーユーザになって、

 @w{@code{make install}}

とすると、実際にインストールされます。特定の Emacs を指定する場合は、

 @w{@code{make install EMACS=mule}}
  
とすると指定できます。

XEmacs でパッケージとしてインストールする場合は、 

 @w{@code{make what-where-package}}

を実行すると、パッケージのインストール先が表示されます。

 @w{@code{make install-packege}}

を実行すると実際にインストールします。

@node はじめの設定, 基本的な使い方, インストール, Top
@comment  node-name,  next,  previous,  up
@chapter はじめの設定

SKK を使い始める前に、あなたの @file{~/.emacs} に設定を書かなければなり
ません。ここではその方法を説明します。

@menu
* 最も基本的な設定::            
* インクリメント検索の設定::    
* 辞書サーバを使いたいときの設定::  
@end menu

@node 最も基本的な設定, インクリメント検索の設定, はじめの設定, はじめの設定
@comment  node-name,  next,  previous,  up
@section 最も基本的な設定
@cindex @file{skk-obsolete.el}

以下のように @file{.emacs} に書きます。

@lisp
@group
(require 'skk-autoloads)
(global-set-key "\C-x\C-j" 'skk-mode)
(global-set-key "\C-xj" 'skk-auto-fill-mode)
(global-set-key "\C-xt" 'skk-tutorial)
@end group
@end lisp

XEmacs でパッケージインストールをした場合は、
@lisp
(require 'skk-autoloads)
@end lisp
の記述は不要です。

サーバを使わない場合は、更に辞書ファイルを指定する必要があります。

@lisp
(setq skk-large-jisyo "/your/path/to/SKK-JISYO.L")
@end lisp

サーバを使わない場合は、@code{skk-large-jisyo} はEmacsのバッファに取り込
んで使用するので、これによりメモリが圧迫されすぎる場合は、上記の
@file{SKK-JISYO.L} を @file{SKK-JISYO.S} や @file{SKK-JISYO.M} に変更し
ます。

@node インクリメント検索の設定, 辞書サーバを使いたいときの設定, 最も基本的な設定, はじめの設定
@comment  node-name,  next,  previous,  up
@section インクリメント検索の設定
@vindex isearch-mode-hook
@vindex isearch-mode-end-hook

以下のように @file{.emacs} に書きます。

@lisp
@group
(add-hook 'isearch-mode-hook
          (function (lambda ()
                      (and (boundp 'skk-mode) skk-mode
                           (skk-isearch-mode-setup)))))

(add-hook 'isearch-mode-end-hook
	  (function
	   (lambda ()
	     (and (boundp 'skk-mode) skk-mode (skk-isearch-mode-cleanup))
	     (and (boundp 'skk-mode-invoked) skk-mode-invoked
		  (skk-set-cursor-properly)))))
@end group
@end lisp

上記の設定では、SKKが起動されているときのみ、付属のインクリメンタルサー
チを使用します。常に付属のインクリメンタルサーチを使用したかったら上記の 
 @code{isearch-mode-hook}、 @code{isearch-mode-end-hook} の設定を下記の
設定に変更します。

@lisp
@group
(add-hook 'isearch-mode-hook 'skk-isearch-mode-setup)
(add-hook 'isearch-mode-end-hook 
     	  (function (lambda ()
		      (skk-isearch-mode-cleanup)
		      (and skk-mode-invoked (skk-set-cursor-properly)))))
@end group
@end lisp

入力モードに応じカーソル色を変化させる機能を使わないのであれば
@code{isearch-mode-end-hook} の値はそれぞれ下記のようになります。

@w{@xref{入力モードを示すカーソル色に関する設定}}.

@lisp
@group
(add-hook 'isearch-mode-end-hook
	  (function
	   (lambda ()
	     (and (boundp 'skk-mode) skk-mode (skk-isearch-mode-cleanup)))))
@end group
@end lisp

@lisp
@group
(add-hook 'isearch-mode-end-hook 'skk-isearch-mode-cleanup)
@end group

@end lisp
@menu
* 古い設定のチェック::          
@end menu

@node 古い設定のチェック,  , インクリメント検索の設定, インクリメント検索の設定
@comment  node-name,  next,  previous,  up
@subsection 古い設定のチェック

@ftable @code

@item skk-obsolete-check-all-files

このコマンドは、各個人の設定ファイルの古い設定を調べて、可能な限り新しい
設定に書換えます。 SKK 9 と比較して、変数名、関数名が大幅に変更されたので、

@example
@file{skk-obsolete.el}
@end example

@noindent
をロードし、

@example
@kbd{M-x skk-obsolete-check-all-files} 
@end example

@noindent
を実行することを強くお勧めします。

@end ftable

@node 辞書サーバを使いたいときの設定,  , インクリメント検索の設定, はじめの設定
@comment  node-name,  next,  previous,  up
@section 辞書サーバを使いたいときの設定
@cindex @var{SKKSERVER}
@cindex @var{SKKSERV}
@cindex @var{SKK_JISYO}

辞書サーバを使いたいときは、@file{.emacs}や@file{.skk} で以下のように設
定します。
@footnote{辞書サーバを使ってみたい場合は

@xref{dbskkd-cdb}.

@noindent
を参照してください。}

@smalllisp
@group
(setq skk-server-host "hogehoge")
(setq skk-server-prog "/your/path/to/skkserv")
(setq skk-server-jisyo "/your/path/to/SKK-JISYO.L")
@end group
@end smalllisp

@vtable @code
@item skk-server-host
辞書サーバを走らせるホスト名、または IP アドレス。
@item skk-server-prog
辞書サーバプログラム(フルパスで指定する)。
@item skk-server-jisyo
サーバに渡す辞書(フルパスで指定する)。
@end vtable

@noindent
この設定は、環境変数を利用して下記のようにすることもできます。

@table @asis
@item Bシェルの場合 (sh, bash, ksh, zsh など)

@example
@group
export SKKSERVER=hogehoge
export SKKSERV=/your/path/to/skkserv
export SKK_JISYO=/your/path/to/SKK-JISYO.L
@end group
@end example

@item Cシェルの場合 (csh, tcsh など)

@example
@group
setenv SKKSERVER hogehoge
setenv SKKSERV /your/path/to/skkserv
setenv SKK_JISYO /your/path/to/SKK-JISYO.L
@end group
@end example
@end table

@node 基本的な使い方, 便利な応用機能, はじめの設定, Top
@comment  node-name,  next,  previous,  up
@chapter 基本的な使い方

本章では、SKKの基本的な使用方法を説明します。これを読めば、とりあえず
SKK を使ってみるには充分です。

SKK を使った入力方法に慣れるには、付属の@xref{チュートリアル}プログラムが最
適なので、お試しください。

なお、次章の「便利な応用機能とユーザーオプション」は、興味のある個所のみ
をピックアップしてお読みになるのがいいでしょう。

@menu
* 起動と終了::                  
* モード::                      入力モードと変換モード。
* インクリメンタル・サーチ::    
* チュートリアル::              
@end menu

@node 起動と終了, モード, 基本的な使い方, 基本的な使い方
@comment  node-name,  next,  previous,  up
@section 起動と終了
@cindex オートフィル
@cindex 個人辞書
@cindex Auto Fill
@kindex C-x C-j
@kindex C-x j

SKK モードに入るには @kbd{C-x C-j}、もしくは @kbd{C-x j} とタイプします。
マイナーモードの表示には、下記のように @w{@samp{かな}} が追加されます。
@footnote{次の設定をしているときはモードラインの左端に追加されます。

@lisp
(setq skk-status-indicator 'left) 
@end lisp
}。

@example
MULE/7bit----- Buffer-name (Major-mode かな)---
@end example

また、カーソルの色が変化します
@footnote{カラーディスプレイを使用し、カラー表示をサポートしている
Window System 下で対応する Emacs を使用している場合。

@w{@xref{入力モードを示すカーソル色に関する設定}}.}。

@kbd{C-x C-j}、もしくは @kbd{C-x j} を再度タイプすることで、SKK モードに
入る前のモードに戻り、カーソル色も元に戻ります。
@footnote{但し、@b{「アスキーモード」}を利用すれば SKK モードから抜ける
必要はほとんどありません。

@xref{入力モード, , アスキーモード}.}

@menu
* SKKオートフィルモード::       
* 辞書の保存::                  
@end menu

@node SKKオートフィルモード, 辞書の保存, 起動と終了, 起動と終了
@comment  node-name,  next,  previous,  up
@subsection SKKオートフィルモード
@kindex C-u -1 C-x j
@kindex C-u C-x j
@kindex C-x j
@kindex M-- C-x j
@kindex M-1 C-x j

@kbd{C-x j} とタイプすれば、SKK モードに入ると同時にオートフィルモード
@footnote{@xref{Auto Fill, , Auto Fill, emacs, GNU Emacs Manual}.}
をオンにします。

既にオートフィルモードがオンになっているバッファで @kbd{C-x j}をタイプす
ると、オートフィルモードは逆にオフになるので注意してください。

バッファの状態にかかわらず強制的にオートフィルモード付で SKK モードに入
りたい場合は、@kbd{M-1 C-x j} や @kbd{C-u C-x j} などとタイプし、このコ
マンドに正の引数を渡します
@footnote{「引数」については、

@xref{Arguments, , Arguments, emacs, GNU Emacs Manual}.

@noindent
を参照のこと。}。

オートフィルモードをオフにし、かつ SKK モードも終了したい場合には
@w{@kbd{M-- C-x j}} や @w{@kbd{C-u -1 C-x j}} などとタイプし、このコマン
ドに負の引数を渡します。

@node 辞書の保存,  , SKKオートフィルモード, 起動と終了
@comment  node-name,  next,  previous,  up
@subsection 辞書の保存
@kindex C-x C-c
@vindex skk-backup-jisyo
@vindex skk-jisyo

@kbd{C-x C-c} で Emacs を終了しようとすると @file{~/.skk-jisyo} に個人辞
書の内容を自動的に保存します。

@xref{辞書の種別, , 個人辞書}.

@file{~/.skk-jisyo.BAK} に保存を行なう前の辞書が退避されます。

@file{~/.skk-jisyo} や @file{~/.skk-jisyo.BAK} のファイル名を変更したけ
ればそれぞれ @code{skk-jisyo} や @code{skk-backup-jisyo} の値を変更して
下さい。

@ftable @code
@item  skk-kill-emacs-without-saving-jisyo

個人辞書を保存せず Emacs を終了させたい場合には、

@example
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end example

@noindent
とタイプします。
@end ftable

個人辞書の保存動作について更に詳しくは、

@ref{個人辞書の保存動作}

@noindent
を参照してください。

@node モード, インクリメンタル・サーチ, 起動と終了, 基本的な使い方
@comment  node-name,  next,  previous,  up
@section モード
@cindex マイナーモード
@cindex メジャーモード
@cindex SKKモード

SKK モードは、文字種類による 4 種類の@b{「入力モード」}と、辞書を用いた
変換の状態により 3 つの@b{「変換モード」}を持ちます。本章では、入力モー
ドと変換モードについて説明します。

@xref{Minor Modes, , マイナーモード, emacs, GNU Emacs Manual}.


@menu
* 入力モード::                  文字種別毎のモード
* 変換モード::                  辞書を用いた変換の状態毎のモード
* 後から▽モードに入る方法::    
* ▽モードを抜ける方法::        
* 送り仮名が無い場合::          
* 次候補・前候補::              
* 送り仮名が有る場合::          
* 送り仮名が無い場合の辞書登録::  
* 送り仮名が有る場合の辞書登録::  
* サ変動詞の辞書登録に関する注意::  
* 再帰的辞書登録::              
* 改行文字を含む辞書登録::      
@end menu

@node 入力モード, 変換モード, モード, モード
@comment  node-name,  next,  previous,  up
@subsection 入力モード
@cindex かなモード
@cindex アスキーモード
@cindex カナモード
@cindex 全英モード

入力モードは、文字種別により

@itemize @asis
@item 「かなモード」
@item 「カナモード」
@item 「全英モード」
@item 「アスキーモード」
@end itemize

の4種類に分類されます。

@menu
* 入力モードの説明::            
* 入力モードを切り替えるキー::  
@end menu

@node 入力モードの説明, 入力モードを切り替えるキー, 入力モード, 入力モード
@comment  node-name,  next,  previous,  up
@subsubsection 入力モードの説明

@table @b

@item 「かなモード」

@itemize @asis
@item ASCII の小文字をひらがなに変換するモード。
@item マイナーモードの表示: @w{@samp{かな}}
@item カーソル色: 赤系
@end itemize

@item 「カナモード」

@itemize @asis
@item ASCII 小文字をカタカナに変換するモード。
@item マイナーモードの表示: @w{@samp{カナ}}
@item カーソル色: 緑系
@end itemize

@item 「全英モード」

@itemize @asis
@item ASCII 小文字、大文字を全角アルファベットに変換するモード。
@item マイナーモードの表示: @w{@samp{全英}}
@item カーソル色: 黄系
@end itemize

@item 「アスキーモード」

@itemize @asis
@item 文字変換を行なわないモード。入力されたキーは @kbd{C-j} を除いて通
常のEmacsのコマンドとして解釈される。
@item マイナーモードの表示: @w{@samp{SKK}} 
@item カーソル色: 背景によりアイボリーかグレイ。
@end itemize
@end table

入力モードに伴なうカーソル色の変更方法については、

@w{@xref{入力モードを示すカーソル色に関する設定}.}

@noindent
を参照してください。

@node 入力モードを切り替えるキー,  , 入力モードの説明, 入力モード
@comment  node-name,  next,  previous,  up
@subsubsection 入力モードを切り替えるキー

@table @kbd

@item q
「かなモード」、「カナモード」間をトグルする。

@item l
「かなモード」または「カナモード」から「アスキーモード」へ。

@item L
「かなモード」または「カナモード」から「全英モード」へ。

@item C-j
「アスキーモード」または「全英モード」から「かなモード」へ。

@end table

実際にはカナモードや全英モードで長時間入力を続けることはほとんどないの
で、かなモードのままでカナ文字や全英文字を入力する便法が用意されています。

@xref{入力モードの一時変更}.

@node 変換モード, 後から▽モードに入る方法, 入力モード, モード
@comment  node-name,  next,  previous,  up
@subsection 変換モード

変換モードは、次の 3 種類のいずれかです。

@table @b

@item 「■モード(確定入力モード)」

あるキー入力に対応する文字列を、辞書を用いた文字変換を行なわずに直接バッ
ファへ入力するモード。入力モードに応じてローマ字からひらがな、ローマ字か
らカタカナ、あるいはアスキー文字から全角アルファベットへの文字変換を行な
う。

@item 「▽モード」

辞書変換の対象となる文字列、「見出し語」を入力するモード。

@item 「▼モード」

見出し語について、辞書変換を行うモード。

@end table
また、▽モードの変種として@dfn{SKK abbrev mode}があり、▼モードのサブモー
ドとして、@b{「辞書登録モード」}があります。

@menu
* ■モード::                    辞書変換を行なわない確定入力のモード。
* ▽モード::                    辞書変換のため見出し語の入力を行なうモード。
@end menu

@node ■モード, ▽モード, 変換モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ■モード
@cindex 確定入力
@cindex ローマ字入力

確定入力モードを@b{「■モード」}と呼びます。■モードでは、あるキー入力に
対応した特定の文字列への変換を行なうだけで、辞書変換は行いません。ASCII
文字列から、入力モードに応じて、ひらがな、カタカナ、あるいは全角アルファ
ベットへの文字変換を行ないます。変換を行なうカレントバッファにこのモード
特有のマークは表示されません。

かなモード、カナモードで、かつ ■モードである場合、ディフォルトの入力方法
はいわゆるローマ字入力です。訓令式、ヘボン式のどちらによっても入力するこ
とができます。主な注意点を以下に説明します。

@itemize @bullet

@item
@samp{ん}は @kbd{n n} または @kbd{n '} で入力する。直後に @samp{n}、
@samp{y} 以外の子音が続くときは @samp{n} だけで入力できる。

@item
促音は、@kbd{c h o t t o} @result{} @samp{ちょっと}、@kbd{m o p p a r a}
@result{} @samp{もっぱら}のように次の子音を重ねて入力する。

@item
促音や拗音(ひらがなの小文字)を単独で入力するときは、@kbd{x a} @result{}
@samp{ぁ}、@kbd{x y a} @result{} @samp{ゃ}などのように @samp{x} を用いる。

@item
長音には、@samp{-}を用いる。@samp{-}@result{}@samp{ー}。
@end itemize

@node ▽モード,  , ■モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ▽モード
@cindex 辞書変換対象の文字列の決定

@b{「▽モード」}では、辞書変換の対象となる文字列を入力します。かなモード、
もしくはカナモード@footnote{@xref{入力モード, , かなモード、カナモード}.}
で、かつ、■モードであるときに、キー入力を大文字で開始することで、▽モー
ドに入ります。例えば、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
のようにタイプすることで、▽モードに入り、続けて辞書変換の対象となる文字
列、「見出し語」を入力してゆくことができます。@samp{▽}マークは、▽モード
であるという表示ですが、見出し語開始点を示す表示でもあります。

@menu
* 後から▽モードに入る方法::
* ▽モードを抜ける方法::
@end menu

@node 後から▽モードに入る方法, ▽モードを抜ける方法, 変換モード, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 後から▽モードに入る方法
@cindex ▽マークの付け忘れ
@cindex 数字から始まる見出し語の入力
@kindex @samp{Q}

@samp{K} の文字を大文字で入力し忘れた場合は、辞書変換の対象としたい文字
列の先頭までポイント
@footnote{@xref{Point, ,ポイント, emacs, GNU Emacs Manual}.}を戻し 
@samp{Q}をタイプすることで▽モードに入ることができます。例えば、下記のよ
うに操作します (@point{} の地点にカーソルがあります)。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{C-u 3 C-b}, @kbd{Q}

@group
------ Buffer: foo ------
▽@point{}かんじ
------ Buffer: foo ------
@end group

@kbd{C-e}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

@samp{7がつ24にち} のように大文字から始めることができない文字列についても、
▽モードにしたい場合は @samp{Q} をタイプし、▽モードにしてから @samp{7が
つ24にち} の文字列を入力します。なお、▽モードでは、文字列の間に空白を含
めることはできません
@footnote{これは、辞書の見出し語に空白を含めることができない制限からきて
います。}。

@node ▽モードを抜ける方法, 送り仮名が無い場合, 後から▽モードに入る方法, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec ▽モードを抜ける方法
@kindex C-g
@kindex C-j

誤って▽モードに入ってしまったときは @kbd{C-j} とタイプし、■モードに戻
るか @kbd{C-g} とタイプし▽モードで辞書変換と対象となっている文字列を消
去するかの 2 通りの処理の方法があります。具体例を下記に示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
あるいは、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group
@end example

@menu
* ▼モード::                    
@end menu

@node ▼モード,  , ▽モードを抜ける方法, ▽モードを抜ける方法
@comment  node-name,  next,  previous,  up
@subsubsection ▼モード
@cindex Overlays
@cindex ハイライト
@cindex 暗黙の確定
@cindex 変換開始

@b{「▼モード」} では、▽モードで入力した見出し語を、辞書に従い変換する作
業を行ないます。▽モードで見出し語を入力した後 @key{SPC} をタイプするこ
とで▼モードに入ります。@samp{▽} マークから @key{SPC} をタイプしたとき
のポイントまでの文字列が見出し語として確定され、 @samp{▽} マークは
@samp{▼} マークで置き換えられ、この文字列が辞書の中で検索されます。

@menu
* 送り仮名が無い場合::
* 次候補・前候補::
* 送り仮名が有る場合::
@end menu

@node 送り仮名が無い場合, 次候補・前候補, ▽モードを抜ける方法, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が無い場合

仮に、辞書に

@example
かんじ /漢字/幹事/
@end example

@noindent
というエントリ
@footnote{本マニュアルでは、見出し語と候補群を合わせた一行を「エントリ」
と呼びます。詳細は、@ref{送りありエントリと送りなしエントリ}を参照してく
ださい。}を含むとして、例を示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼漢字@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、▽モードにおける @samp{▽} マークからポイントまでの間の文字列
@samp{かんじ} を辞書変換の対象文字列として確定し、それについて辞書内での
検索を行なっています。実際の変換動作では、候補部分がハイライト表示されます
@footnote{ハイライト表示はFSF EmacsのOverlays、XEmacs のextentの機能を使
用しています。}。

@samp{漢字} が求める語である場合は @kbd{C-j} をタイプすれば、この変換が
確定します。ハイライト表示も @samp{▼} マークも消えます。

また @kbd{C-j} をタイプせずに、新たな確定入力を続けて行なうか、または新
たな変換を開始すると、直前の変換は自動的に確定されます。これを @b{「暗黙
の確定」} と呼んでいます。副作用として確定を伴なうキーは、印字可能な文字
全てと @key{RET} です。ただし、

@ref{暗黙の確定のタイミング}

@noindent
を参照してください。

@node 次候補・前候補, 送り仮名が有る場合, 送り仮名が無い場合, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 次候補・前候補

求めるものがすぐに出なければ、更に続けて @key{SPC} をタイプすることで、
次候補を検索します。

@example
@group
------ Buffer: foo ------
▼漢字
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼幹事
------ Buffer: foo ------
@end group
@end example

候補が 5 つ以上あるときは 5 番目以降の候補は 7 つずつまとめてエコーエリ
アに表示されます。例えば、辞書が

@example
@group
きょ /距/巨/居/裾/嘘/拒/拠/虚/挙/許/渠/据/去/
@end group
@end example

@noindent
というエントリを含むときに @kbd{K y o} の後に @key{SPC} を 5 回続けて打
てば、

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

@noindent
がエコーエリア
@footnote{エコーエリアとミニバッファは視覚的には同一の場所にありますが、エコー
エリアが単にユーザーへのメッセージを表示するのみであるのに対し、ミニバッ
ファは独立のバッファとして機能する点が違います。}に表示されます。ここで仮に
@samp{許} を選択したければ、 @samp{k} を入力します。

@samp{A}, @samp{S}, @samp{D}, @samp{F}, @samp{J}, @samp{K}, @samp{L} の
各文字は、押し易さを考慮してキーボードのホームポジションから横方向に一直
線に配置されているキーが選ばれています。また、候補の選択のために押すキー
は、大文字、小文字のいずれでも構いません。候補の選択に用いるキーの変更に
ついては、

@ref{候補の選択に用いるキー}

@noindent
を参照してください。

@key{SPC} を連打してしまい、誤って求める候補を通過してしまったときは 
@samp{x} により前候補/前候補群に戻ることができます
@footnote{@samp{x} は小文字で入力する必要があります}。

候補を次々と探しても求めるものがなければ、自動的に辞書登録モードになります
(辞書登録モードは▼モードのサブモードです) 。
@ref{辞書登録モード}にて説明します。

@node 送り仮名が有る場合, 送り仮名が無い場合の辞書登録, 次候補・前候補, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が有る場合

次に送り仮名のある単語について説明します。

@samp{動く} を変換により求めたいときは @kbd{U g o K u} のように、まず ▽
モード に入るために @samp{U} を大文字で入力し、次に送り仮名の開始を SKK 
に教えるために @samp{K} を大文字で入力します。送り仮名の @samp{K} をタイ
プした時点で @key{SPC} をタイプすることなく、▼モード に入り辞書変換が行
なわれます。

送り仮名の入力時、ローマ字プレフィックスが挿入された瞬間に、プレフィック
スの直前に @samp{*} を一瞬挿入し、送り仮名の開始時点を明示します。プレフィッ
クスに続くキー入力で、かな文字が完成した時点で@samp{*}は消えます。

キー入力を分解して追いながらもう少し詳しく説明します。

@example
@kbd{U g o}

@group
------ Buffer: foo ------
▽うご
------ Buffer: foo ------
@end group

@kbd{K}

@group
------ Buffer: foo ------
▽うご*k
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
▼動く
------ Buffer: foo ------
@end group
@end example

SKK ではこのように、送り仮名の開始地点をユーザーが明示的に入力するので、
システム側で送り仮名を分解する必要がありません。これにより、高速でヒット
効率が高い変換が可能になります。

@xref{送り仮名の自動処理}.

但しサ変動詞の変換では、サ変動詞の語幹となる名詞を @b{「送りなし変換」}
@footnote{詳細は、@ref{送り仮名が無い場合}を参照してください。}
として変換し、その後 @samp{する} を■モードで入力した方が効率が良くなり
ます。 

@xref{サ変動詞の辞書登録に関する注意, , サ変動詞の入力}.

@menu
* 辞書登録モード::              
@end menu

@node 辞書登録モード,  , 送り仮名が有る場合, 送り仮名が有る場合
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録モード
@cindex 暗黙の確定
@cindex 辞書登録

SKK には独立の辞書登録モードはありません。その代わり、辞書にない単語につ
いての変換を行なった場合に、自動的に辞書登録モードに入ります。例えば辞書
に

@example
へんかんちゅう /変換中/
@end example

@noindent
のエントリがない場合に、@samp{変換中} を入力しようとして、@w{@kbd{H e n
k a n ty u u @key{SPC}}} とタイプすると、下記のように、カレントバッファ
は ▼モード のまま @samp{へんかんちゅう} に対して変換ができない状態で休
止し、同時にミニバッファに @samp{へんかんちゅう} というプロンプトが表示
されます。

@example
@group
------ Buffer: foo ------
▼へんかんちゅう
------ Buffer: foo ------

------ Minibuffer -------
へんかんちゅう@point{}
------ Minibuffer -------
@end group
@end example

@menu
* 送り仮名が無い場合の辞書登録::
* 送り仮名が有る場合の辞書登録::
* サ変動詞の辞書登録に関する注意::
* 再帰的辞書登録::
* 改行文字を含む辞書登録::
@end menu

@node 送り仮名が無い場合の辞書登録, 送り仮名が有る場合の辞書登録, 送り仮名が有る場合, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が無い場合の辞書登録

@noindent
辞書登録モードでは、入力はミニバッファに対して行われます。仮に辞書に

@example
@group
へんかん /変換/
ちゅう /中/
@end group
@end example

@noindent
のようなエントリがあるとして、ミニバッファで@samp{変換中}の文字列を
@samp{変換}と@samp{中}とに分けて作ります。

@example
@group
@kbd{H e n k a n @key{SPC}T y u u @key{SPC}}

------ Minibuffer -------
へんかんちゅう 変換▼中
------ Minibuffer -------
@end group
@end example

@noindent
ここで @key{RET} をタイプすれば @samp{変換中} が個人辞書に登録され、辞書
登録モードは終了します
@footnote{ここでも暗黙の確定が行なわれるので @kbd{C-j} をタイプする必要
はありません。ただし、@ref{▼モードでのRET} を参照してください。}。同時
に、変換を行なっているカレントバッファには、@samp{変換中} が挿入され確定さ
れます。 

@xref{辞書の種別, , 個人辞書}.

辞書登録モードを抜けたいときは @kbd{C-g} をタイプするか、または何も登録
せず @key{RET} をタイプすると▽モードに戻ります。

@node 送り仮名が有る場合の辞書登録, サ変動詞の辞書登録に関する注意, 送り仮名が無い場合の辞書登録, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が有る場合の辞書登録

送り仮名のある単語の登録では、ミニバッファで作る候補に送り仮名そのものを
登録しないように注意しなければいけません。仮に辞書に

@example
うごk /動/
@end example

@noindent
というエントリがないとして、例を挙げて説明します。

@example
@group
@kbd{U g o K u}

@end group
@group
------ Buffer: foo ------
▼うごく
------ Buffer: foo ------

------ Minibuffer -------
うご*く@point{}
------ Minibuffer -------
@end group
@end example

@noindent
ミニバッファで辞書登録すべき文字列は、@samp{動} だけで、送り仮名の
@samp{く} は含めてはいけません。 @samp{動く} を登録してしまうと、次に
@kbd{U g o K u} とタイプしたときに出力される候補が @samp{動くく} になっ
てしまいます。

@example
@group
@kbd{D o u @key{SPC}}

@end group
@group
------ Minibuffer -------
うご*く 動@point{}
------ Minibuffer -------

@end group
@key{RET}
@group

------ Buffer: foo ------
動く
------ Buffer: foo ------
@end group
@end example

@node サ変動詞の辞書登録に関する注意, 再帰的辞書登録, 送り仮名が有る場合の辞書登録, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec サ変動詞の辞書登録に関する注意,

サ変動詞 (名詞の後に @samp{する} を付けた形で構成される動詞) については、
@samp{する} を送り仮名とした送りあり変換
@footnote{送り仮名を伴なう変換。詳しくは、@ref{送り仮名が有る場合}を
参照してください。}をしないで、@samp{運動} と @samp{する} と分けて入力し
た方が効率が良くなります
@footnote{名詞とそのサ変動詞とを別々に辞書に持つと空間的な効率が悪いので、
基本的に、辞書がサ変動詞を送りありとして意識した作りとしていません。その
ため、@samp{する} を送り仮名とした送りあり変換では、辞書に候補がなく辞書
登録モードに入ってしまう可能性が高いので、名詞として分解して入力すること
をお勧めします。一方で、このように名詞に分解して入力することで、サ変動詞
になり得ない名詞が候補として出てくることもあるので (例えば @samp{孝行す
る} という変換を行ないたい場合に @samp{高校} が出てくるなど)、候補の絞り
込みという点では必ずしも効率が良くありません。将来のバージョンにおいてこ
の点を改善する方向で検討しています。詳しくは、@ref{拡張アイディア} を参
照してください。}。

例えば @samp{運動する} は @kbd{U n d o u @key{SPC} s u r u} とタイプする
ことにより入力できます。名詞から作られる形容詞等も同様です。

@node 再帰的辞書登録, 改行文字を含む辞書登録, サ変動詞の辞書登録に関する注意, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 再帰的辞書登録
@cindex 再帰的辞書登録

ミニバッファを再帰的に使い辞書登録を再帰的に行なうことができます。

仮に辞書に

@example
@group
さいきてき /再帰的/
さいき /再帰/
@end group
@end example

@noindent
のようなエントリがなく、かつ

@example
@group
さい /再/
き /帰/
てき /的/
@end group
@end example

@noindent
のようなエントリがあるとします。

ここで @kbd{S a i k i t e k i @key{SPC}} とタイプすると、文字列 @samp{さ
いきてき} に対する候補を見つけられないので、ミニバッファに @samp{さいき
てき} というプロンプトを表示して辞書登録モードに入ります。

@samp{さいきてき} に対する辞書エントリを作るため @kbd{S a i k i @key{SPC}}
とタイプすると、更にこの候補も見つけられないので、ミニバッファに
@samp{さいき} というプロンプトを表示して、再帰的に @samp{さいき} の辞書
登録モードに入るます。

@kbd{S a i @key{SPC}K i @key{SPC}}とタイプすると、ミニバッファは、

@example
------ Minibuffer -------
さいき 再▼帰
------ Minibuffer -------
@end example

@noindent
となります。ここで @key{RET} をタイプすると、個人辞書には

@example
さいき /再帰/
@end example

@noindent
というエントリが登録され、ミニバッファは @samp{さいきてき} の辞書登録モー
ドに戻り、プロンプトは @samp{さいきてき} となります。

今度は @samp{再帰} が変換可能なので @kbd{S a i k i @key{SPC}T e k i
@key{SPC}} とタイプすると、

@example
------ Minibuffer -------
さいきてき 再帰▼的
------ Minibuffer -------
@end example

@noindent
となります。ここで @key{RET} をタイプすることで、@samp{さいきてき} の辞
書登録モードから抜け、個人辞書に

@example
さいきてき /再帰的/
@end example

@noindent
というエントリが登録されます。カレントバッファのポイントには、@samp{再帰
的}が挿入されます。

@node 改行文字を含む辞書登録,  , 再帰的辞書登録, モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 改行文字を含む辞書登録
@cindex 改行文字を含む文字列の辞書登録

改行文字を含む文字列を辞書に登録するには、辞書登録モードで改行文字を 
@kbd{C-q C-j} により入力します。例えば、

@example
@group
〒980
仙台市青葉区片平2-1-1
東北大学電気通信研究所
@end group
@end example

@noindent
を辞書に登録するには、辞書登録モードで、

@example
@group
@samp{〒980},
@kbd{C-q C-j},
@samp{仙台市青葉区片平2-1-1},
@kbd{C-q C-j},
@samp{東北大学電気通信研究所},
@key{RET}
@end group
@end example

@noindent
と入力します。

@node インクリメンタル・サーチ, チュートリアル, モード, 基本的な使い方
@comment  node-name,  next,  previous,  up
@section インクリメンタル・サーチ
@cindex I-search
@cindex Incremental search

SKK では、専用のインクリメンタル・サーチプログラムを Emacs 添付の
isearch.el のラッパーとして実装しているため、日本語の文字列についてのイ
ンクリメンタル・サーチをアスキー文字と同様の操作で行なうことができます。

@menu
* skk-isearchの操作性::         
* skk-isearchと入力モード::     
@end menu

@node skk-isearchの操作性, skk-isearchと入力モード, インクリメンタル・サーチ, インクリメンタル・サーチ
@comment  node-name,  next,  previous,  up
@subsection skk-isearchの操作性
@kindex C-r
@kindex C-s
@kindex M-C-s
@kindex M-C-r

大部分の動作は、オリジナルのインクリメンタル・サーチのもののままですから、
オリジナルのインクリメンタル・サーチのコマンド
@footnote{@kbd{M-y} の @code{isearch-yank-kill} や @kbd{M-p} の 
@code{isearch-ring-retreat}, @kbd{M-n} の @code{isearch-ring-advance} など}やユーザー変数でのカスタマイズ
@footnote{@code{search-highlight} など}もそのまま利用できます。

オリジナルのインクリメンタル・サーチについては、

@xref{Incremental Search, ,Incremental Search, emacs, GNU Emacs Manual}.

@noindent
を参照してください。

インクリメンタル・サーチ中の入力方法は、通常のバッファにおける各入力モー
ド、変換モードでの入力方法と同一です。

@kbd{C-s} や @kbd{C-r}、あるいは @kbd{M-C-s} や @kbd{M-C-r} でインクリメ
ンタル・サーチを起動すると、インクリメンタル・サーチを起動したバッファの
入力モードと同一の入力モードで、キーとなる文字の入力が可能となります。

@node skk-isearchと入力モード,  , skk-isearchの操作性, インクリメンタル・サーチ
@comment  node-name,  next,  previous,  up
@subsection skk-isearchと入力モード

入力モードに合わせて、インクリメンタル・サーチのプロンプトが表示されます。
プロンプトの種類は、以下の5つです。

@table @asis

@item I-search: [aa]
アスキーモード

@item I-search: [か]
かなモード

@item I-search: [カ]
カナモード

@item I-search: [英]
全英モード

@item I-search: [--]
インクリメンタル・サーチモードで @kbd{C-x C-j} などをタイプしてSKKを終了
した場合は、このプロンプトが表示される。

@end table

@node チュートリアル,  , インクリメンタル・サーチ, 基本的な使い方
@comment  node-name,  next,  previous,  up
@section チュートリアル
@cindex チュートリアル
@vindex skk-tut-file
@findex skk-tutorial
@kindex M-x skk-tutorial

SKK には、チュートリアルが附属しています。チュートリアルでは、 SKK の基本的
な操作方法を学習できます。@kbd{M-x skk-tutorial} で実行します。チュートリア
ルは、日本語(@samp{Japanese})と英語(@samp{English})が用意されています。英語
を選択する場合は、@kbd{C-u M-x skk-tutorial [RET] English [RET]} を実行しま
す。

チュートリアルファイルが、標準の場所にない場合は、 @file{.emacs} で

@lisp
  (setq skk-tut-file "a:/user/local/share/skk/SKK.tut")
@end lisp

と書くことにより、指定したチュートリアルファイルを使用させることが
できます。英語のチュートリアルファイルは、 @samp{skk-tut-file} に @file{.E}
が付いたファイル名です。この場合であれば、
@file{a:/user/local/share/skk/SKK.tut.E} になります。


@node 便利な応用機能, 辞書ツール, 基本的な使い方, Top
@comment  node-name,  next,  previous,  up
@chapter 便利な応用機能

@menu
* 予備知識::                    応用機能を使いこなすために。
* 入力モードの一時変更::        使用頻度の低い入力モードを一時的に利用する。
* ■モードにおける文字入力::    かな/カナ/全英モードでの文字入力の設定。
* ポイントを戻して▽モードへ::  
* 確定変換とその取り消し::      確定操作なしに確定する変換方法とその取り消し。
* 確定アンドゥ::                候補の選択ミスに対する取り消し操作。
* 見出し語関連::                変換のキーとなる語の処理について。
* 送り仮名関連::                送り仮名の処理について。
* 自動変換開始::                @key{SPC} を押さずに変換開始。
* 特殊変換::                    ちょっと変った便利な変換方法。
* 接頭辞・接尾辞::              接頭辞・接尾辞を指定して候補を絞り込む。
* 暗黙の確定のタイミング::      変換の後、いつ確定するか。
* 領域一括変換::                スパッと領域一括変換。
* 漢字コード関連::              漢字コードにまつわる機能。
* ▼モードの特殊キー::          キーの動作、あるいはキー定義変更。
* 辞書関連::                    辞書にまつわる機能。
* 飾りつけ::                    様々な表示の設定。
* VIP/VIPERとの併用::           
* I-search関連::                インクリメンタル・サーチにまつわる機能。
* skk-init-fileのコンパイル::   設定ファイルの自動バイトコンパイル。
* picture-modeとの併用::        picture-mode との併用の際の問題点。
* サーバ関連::                  
@end menu

@node 予備知識, 入力モードの一時変更, 便利な応用機能, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 予備知識

本章では、応用機能とユーザーオプションについて述べています。それらを理解
するために必要な事柄について、本節で詳しく説明します。

@menu
* ファイル構成::                
* ユーザーオプションの設定方法::  
* 辞書の形式::                  辞書の形式と構成。
* 辞書に関する設定::            検索対象と検索順序の設定。
@end menu

@node ファイル構成, ユーザーオプションの設定方法, 予備知識, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ファイル構成
@cindex @file{queue-m.el}
@cindex @file{skk-auto.el}
@cindex @file{skk-autoloads.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-foreword.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-isearch.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-leim.el}
@cindex @file{skk-look.el}
@cindex @file{skk-num.el}
@cindex @file{skk-obsolete.el}
@cindex @file{skk-server.el}
@cindex @file{skk-tut.el}
@cindex @file{skk-viper.el}
@cindex @file{skk-vars.el}
@cindex @file{skk-lookup.el}
@cindex @file{skk-cursor.el}
@cindex @file{skk-develop.el}
@cindex @file{skk.el}

SKK バージョン 10 では、応用機能を提供するプログラムのほとんどを 
@file{skk.el} とは別のファイルに収めています。これらは、必要に応じオート
ロードするように設計されています。各応用機能の概略と該当のファイル名につ
いて説明します。

@table @file

@item skk-auto.el

送り仮名の自動処理を行なうプログラムを集めたファイル。

@xref{送り仮名の自動処理}.

@item skk-autoloads.el

オートロードの設定を記述したファイル。XEmacs で SKK をパッケージとしてイ
ンストールした場合は使用しない。

@item skk-comp.el

見出し語の補完を行なうプログラムを集めたファイル。

@xref{見出し語の補完}.

@item skk-cursor.el

カーソルの色を制御するプログラムを集めたファイル。

@item skk-develop.el

バクレポートのメールバッファを用意するプログラムファイル。

@item skk-foreword.el

他のファイルで共通して使用するマクロなどを中心にまとめたファイル。各ファイ
ルの冒頭部分に、あまりユーザーに興味がないものが並んでいたのでは、ユーザー
フレンドリーではないので、このファイルに集中させる仕様となっている。

@item skk-gadget.el

プログラム実行変換を行なうプログラムを集めたファイル。

@xref{プログラム実行変換}.

@item skk-isearch.el

SKK を併用したインクリメンタリサーチ機能を提供するファイル。

@xref{I-search関連}.

@item skk-kakasi.el

KAKASI インターフェイスプログラムを集めたファイル。

@xref{領域一括変換}.
@xref{KAKASI}.

@item skk-kcode.el

漢字コードまたはメニューによる文字入力を行なうプログラムを集めたファイル。

@xref{漢字コードまたはメニューによる文字入力}.

@item skk-leim.el

LEIM 関連プログラムファイル。

@item skk-look.el

look インターフェイスプログラムを集めたファイル。
@c @xref{lookを使用した補完・変換}. XXX

@item skk-lookup.el

Lookup で検索できる辞書を使って単語の候補を出力するプログラム。

@item skk-num.el

数値変換を行なうプログラムを集めたファイル。

@xref{数値変換}.

@item skk-obsolete.el

@file{.emacs} や @file{.skk} などのユーザー設定ファイル中の古い設定 (変
数、関数名など)の修正支援プログラム。
@c XXX

@item skk-server.el

SKK サーバインターフェイスプログラムを集めたファイル。

@xref{サーバ関連}.

@item skk-tut.el

SKK チュートリアルプログラム。

@item skk-vars.el

古い SKK 10 をダンプした XEmacs (XEmacs 20.4 以前) で SKK 10 を動かすた
めのダミーファイル。

@item skk-viper.el

VIPER インターフェイスプログラムを集めたファイル。

@end table

なお、Elibより @file{queue-m.el} ファイルを収録しています。

@node ユーザーオプションの設定方法, 辞書の形式, ファイル構成, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ユーザーオプションの設定方法
@cindex @file{skk-auto.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-num.el}
@cindex @file{skk-server.el}
@cindex @file{skk-viper.el}
@cindex @file{~/.emacs}
@cindex @file{~/.skk}

SKK のカスタマイズは、@file{~/.emacs} あるいは @file{~/.skk} に記述しま
す。また、各ファイルの提供するフックも利用します。上記のファイルやフック
を利用した設定がいつ有効になるのか、という点についてここで説明します
@footnote{以前のバージョンでは、どのようなカスタマイズが行なわれている場
合でもチュートリアル使用時に標準設定に戻す目的で、変数の宣言に
@code{defconst} を使用していたので、全てのカスタマイズは @file{~/.skk}
で行なう必要がありましたが、SKK 10 では、@code{defcustom} を使用した宣言
を行なっているので、この制限はなくなりました。}。

@table @asis

@item @file{.emacs}

Emacsを起動したときに一度だけ読みこまれます。

@xref{Init File, ,.emacs, emacs, GNU Emacs Manual}.

@item @file{.skk}

SKK を起動した最初の一度だけ読みこまれます。ファイル名の既定値は、OS の
種類により異なりますが、実際は Emacsの関数
@code{convert-standard-filename} により加工されます。
@file{~/.skk} のファイル名は変数 @code{skk-init-file} で変更することがで
きます。また、SKK にはこのファイルを自動的にバイトコンパイルする機能があ
ります。詳細は、

@ref{skk-init-fileのコンパイル}

@noindent
を参照してください。

@end table

@vtable @code

@item skk-mode-hook

@kbd{C-x C-j} と入力して SKK モードに入る度に呼ばれます。主にバッファロー
カルの設定などを行ないます。

@item skk-auto-fill-mode-hook

@kbd{C-x j} と入力してオートフィルモード付きで SKK モードに入る度に呼ば
れます。主にバッファローカルの設定などを行ないます。

@item skk-load-hook

@file{skk.el} の読みこみを完了した時点で呼ばれます。@file{.skk} は SKK
モードを起動しなければ読みこまれないのに対し、このフックは、
@file{skk.el} を読みこんたら SKK モードを起動しなくとも呼ばれます。

@item skk-auto-load-hook
@itemx skk-comp-load-hook
@itemx skk-gadget-load-hook
@itemx skk-kakasi-load-hook
@itemx skk-kcode-load-hook
@itemx skk-num-load-hook
@itemx skk-server-load-hook
@itemx skk-viper-load-hook

@file{skk-auto.el}, @file{skk-comp.el}, @file{skk-gadget.el},
@file{skk-kakasi.el}, @file{skk-kcode.el}, @file{skk-num.el},
@file{skk-server.el}, @file{skk-viper.el} の各ファイルの読みこみが完了し
た直後に呼ばれるフック。

@end vtable

@code{load-hook} が提供されていないプログラムであっても、ロード後に何らか
の設定を行ないたい場合は、関数 @code{eval-after-load} を使用します。例え
ば、

@example
@group
(eval-after-load "skk-look"
  '(
    ...
    ))
@end group
@end example

@noindent
のように記述します。

@node 辞書の形式, 辞書に関する設定, ユーザーオプションの設定方法, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書の形式

ここでは SKK 用辞書の形式について詳しく説明します。

@menu
* 辞書の種別::                  
* 送りありエントリと送りなしエントリ::  
* 送りありエントリのブロック形式::  
* エントリの配列::              
@end menu

@node 辞書の種別, 送りありエントリと送りなしエントリ, 辞書の形式, 辞書の形式
@comment  node-name,  next,  previous,  up
@subsubsection 辞書の種別

辞書の種別は大きく分けて@b{「共有辞書」}と@b{「個人辞書」}の 2 つがあり
ます。

@table @asis

@item 共有辞書
@cindex 共有辞書
@cindex L 辞書
@cindex M 辞書
@cindex S 辞書
@cindex @file{SKK-JISYO.L}
@cindex @file{SKK-JISYO.M}
@cindex @file{SKK-JISYO.S}

付属の @file{SKK-JISYO.S} (@b{「S 辞書」}), @file{SKK-JISYO.M} (@b{「M
辞書」}), @file{SKK-JISYO.L} (@b{「L 辞書」}) などがあります。通常、個人
辞書よりもサイズが大きく、省資源の面からユーザー間で共有して参照されます。
ユーザーの変換により内容が書き替えられることはありません。

@item 個人辞書
@cindex 個人辞書
@vindex skk-jisyo

変数 @code{skk-jisyo} で指定されるファイル。SKKを一番最初に使い始めたと
きにホームディレクトリに自動的に作られます。その後の使用により日々刻々と
エントリが追加され、更新されていきます。

@item @code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo}
@vindex skk-initial-search-jisyo
@vindex skk-kakutei-jisyo

これらは共有辞書、個人辞書という区分のいずれにも属しません。これらは個人
毎に持つものを使用するか、ユーザー間で共有しているものを使用します。その
性格から、辞書内容の更新は行なわれず、参照のみ行なわれます。また使用目的
から、通常は小さい辞書を使用します。

@end table

個人辞書、@code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo} は
Emacs のバッファに読み込んで検索を行ないます。共有辞書は設定により Emacs
のバッファに読み込んで使用するか、またはサーバ経由で使用します。

@node 送りありエントリと送りなしエントリ, 送りありエントリのブロック形式, 辞書の種別, 辞書の形式
@comment  node-name,  next,  previous,  up
@subsubsection 送りありエントリと送りなしエントリ
@cindex ;; okuri-ari entries.
@cindex ;; okuri-nasi entries.
@cindex エントリ
@cindex 送りありエントリ
@cindex 送りあり変換
@cindex 送りなしエントリ
@cindex 送りなし変換
@cindex ローマ字プレフィックス

以下は個人辞書の一例です。

@example
@group
;; okuri-ari entries.
たとe /例/[え/例/]/
もt /持/[つ/持/]/[って/持/]/[た/持/]/[て/持/]/[ち/持/]/[と/持/]/
たすk /助/[け/助/]/
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@dots{}
;; okuri-nasi entries.
てん /点/・/天/
ひつよう /必要/
さくじょ /削除/
へんこう /変更/
じゅんじょ /順序/
ぐん /群/郡/
こうほ /候補/
いち /位置/一/壱/
@dots{}
@end group
@end example

@noindent
@samp{てん /点/・/天/} を例にして説明します。これは @samp{てん} が見出し
語であり、その候補が、@samp{点}、@samp{・}、@samp{天} です。候補はそれぞ
れ、@samp{/} によって区切られています。SKK では、見出し語と候補群を合わ
せた @w{@samp{てん /点/・ /天/}} の一行を@b{「エントリ」}と呼びます。

辞書は単純なテキストファイルで、必ず下記の 2 つの行を持っています。

@example
@group
;; okuri-ari entries.
;; okuri-nasi entries.
@end group
@end example

@noindent
この 2 つの行は、それぞれ送り仮名あり、送り仮名なしのエントリの開始地点
を示すマークです。 @samp{;; okuri-ari entries.} までの行で @samp{;} を行
頭に持つ行はコメント行として無視されます。@samp{;; okuri-ari entries.}
以降にコメント行を含むことはできません。

@w{@samp{;; okuri-ari entries.}} と @w{@samp{;; okuri-nasi entries.}} の
間に囲まれた上半分の部分が送り仮名ありのエントリです。これを@b{「送りあ
りエントリ」}と呼びます。
@w{@samp{;; okuri-nasi entries.}}以下の下半分部分が送り仮名なしのエント
リです。これを@b{「送りなしエントリ」}と呼びます。

送りありエントリを検索する変換を@b{「送りあり変換」}、送りなしエントリを
検索する変換を@b{「送りなし変換」}と呼びます。SKK では送り仮名の有無が変
換方法の 1 つの種別となっています。送り仮名がある変換では送りありエント
リのみが検索され、送り仮名がない変換では送りなしエントリのみが検索されま
す。

1 つの見出し語についてのエントリは 1 行内に書かれます。2 行以上にまたが
ることはできません。改行を含む候補については、@code{(concat "改\n行")}
のように、評価すると改行を該当個所に挿入するような Lisp プログラム
(@w{@pxref{プログラム実行変換}}) に候補を変換して辞書に収めています。

送りありエントリは、基本的には @samp{もt /持/} のようになっています。送
り仮名部分は、送り仮名をローマ字表現したときの 1 文字目
@footnote{あるかな文字をローマ字表現したときの 1 文字目を@b{「ローマ字プ
レフィックス」}と呼びます。}で表現されています。　
この 1 エントリで @samp{持た}、@samp{持ち}、@samp{持つ}、@samp{持て}、
@samp{持と} の 5 つの候補に対応します。その 5 つの候補の送り仮名をローマ
字プレフィックスで表現すれば、いずれも @samp{t} になります。

@node 送りありエントリのブロック形式, エントリの配列, 送りありエントリと送りなしエントリ, 辞書の形式
@comment  node-name,  next,  previous,  up
@subsubsection 送りありエントリのブロック形式
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-henkan-strict-okuri-precedence
@vindex skk-process-okuri-early

個人辞書の送りありエントリには @samp{[} と @samp{]} に囲まれたブロックが
あります。これは、そのブロックの先頭にある平仮名を送り仮名に取る候補群で
す。

@example
@group
たとe /例/[え/例/]/
@dots{}
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@end group
@end example

この例で見ると、見出し語 @samp{たとe} の場合は @samp{え} を送り仮名とす
る 1 つのブロックから構成されています。見出し語 @samp{ふくm} の場合は、
@samp{ま}、@samp{み}、@samp{む}、@samp{め}、@samp{も} を送り仮名とする 5
ブロックに分けられています。

この送り仮名毎のブロック部分は、@code{skk-henkan-okuri-strictly} あるい
は @code{skk-auto-okuri-process} のいずれかの変数が @code{non-nil}で
ある場合に使用されます。その場合、検索において、見出し語の一致に加えて、
更に送り仮名もマッチするかどうかをテストします。例えば、

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
というエントリがあるとします。同じ見出し語 @samp{おおk} であっても、送り
仮名が @samp{き} であれば、候補は @samp{大} のみで @samp{多}は無視されま
す。

@footnote{@xref{送り仮名の自動処理, , skk-henkan-okuri-strictly}.

@xref{送り仮名の厳密なマッチ, , skk-auto-okuri-process}.}

現在のところ、SKK 付属の共有辞書では、@samp{[}と@samp{]}を使用した送り仮
名毎のブロックの形式に対応していません。個人辞書のみがこの形式で書き込ま
れていきます。@code{skk-henkan-okuri-strictly} が @code{nil} であっても
送り仮名のブロック形式で書き込まれます。
@footnote{ただし @code{skk-process-okuri-early} の値が @code{non-nil} で
あれば、送り仮名を決定する前に変換を開始することになるので、送り仮名を明
示的に入力していても個人辞書にはブロック形式は作られません。}

@node エントリの配列,  , 送りありエントリのブロック形式, 辞書の形式
@comment  node-name,  next,  previous,  up
@subsubsection エントリの配列
@cindex 辞書のソート方法

共有辞書では、送りありエントリは @w{@samp{;; okuri-ari entries.}} から順
に下方向に、見出し語をキーとして降順に配置されています。送りなしエントリ
は、@w{@samp{;; okuri-nasi entries.}} から順に下方向に、見出し語をキーと
して昇順に配置されています。

降順、昇順に配置されているのは、辞書サイズが大きいことに配慮して二分検索
を行なうためです。
@footnote{ソートする際には、見出し語を unsigned-char と見なしています。
この順序は Emacs が 関数 @code{string<} で文字列を比較するときの順序であ
り、UNIXの @file{sort} コマンドでの標準の順序とは異なります。
Emacsのコマンド @code{sort-lines}を用いればファイルをこの順序でソートす
ることができます。Emacsのコマンド @code{sort-columns} は内部的に UNIXコ
マンドの @code{sort} を使っているので、辞書のソートには使えません。}

一方、個人辞書は上の例でも見たように、それぞれ
@w{@samp{;; okuri-ari entries.}}, @w{@samp{;; okuri-nasi entries.}} を基
点として、一番最後に変換を行なったものがそれぞれの最小ポイント
@footnote{正確に言えば、送りあり変換では @w{@code{skk-okuri-ari-min}+ 1}
の位置、送りなし変換では @w{@code{skk-okuri-nasi-min}+ 1} の位置。}に挿
入され辞書が更新されます。個人辞書は通常は共有辞書程はサイズが大きくない
ので、検索時にはそれぞれの基点から直線的に検索が行なわれます。

個人辞書で見つけられなかった候補については共有辞書から検索されます。そこ
で見つかり確定された場合は、その候補が個人辞書に取り込まれますが、その際
送りありエントリまたは送りなしエントリの最小ポイントに挿入されます。これ
は、次に同じ見出し語の検索が行なわれた場合に同候補を最初に出力するように
するためです。

@node 辞書に関する設定,  , 辞書の形式, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書に関する設定
@cindex 確定変換
@cindex 二分検索
@cindex 直線的検索
@vindex skk-search-prog-list

@code{skk-search-prog-list} という変数があります。これは、ユーザーオプショ
ンとして設定するのはやや面倒な変数ですが、これを設定することによって、辞
書ファイルの指定、検索方法、検索される辞書の順序などを指定することができ
ます。

ここではまず、@code{skk-search-prog-list} の設定に使われる関数と変数を紹
介します。次に、@code{skk-search-prog-list} の具体例を示しながら、その設
定方法を解説します。


@menu
* 辞書検索のための関数::        
* 辞書ファイルを指定する変数::  
* 辞書検索の設定の具体例::      
@end menu

@node 辞書検索のための関数, 辞書ファイルを指定する変数, 辞書に関する設定, 辞書に関する設定
@comment  node-name,  next,  previous,  up
@subsubsection 辞書検索のための関数

@ftable @code
@item skk-search-kakutei-jisyo-file
@vindex skk-kakutei-flag

形式: (skk-search-kakutei-jisyo-file FILE LIMIT &optional NOMSG)

@b{「確定変換」}を行なう検索プログラム。検索対象の辞書ファイルは Emacs
のバッファに読み込まれます。検索対象のファイルから候補を見つけると、内部
変数 @code{skk-kakutei-flag} を立てて、いきなり確定します。このためユー
ザーが確定する必要はありません。

第 1 引数は検索対象辞書。

第 2 引数は領域の大きさを指定します。一つの見出し語に対する変換動作に対
し、検索対象の領域の大きさが第 2 引数に指定された大きさより小さくなるま
では二分検索が行なわれ、最後に直線的検索が 1 回行なわれます。第 2 引数に
0 を指定すると常に直線的検索のみが行なわれます。

第 3 引数が 非 nil であるとき、辞書をバッファに読み込むときにミニバッファ
に読み込んでいる旨のメッセージを出力します。

@item skk-search-jisyo-file

形式: (skk-search-jisyo-fileFILE LIMIT &optional NOMSG)

通常の検索を行なうプログラム。個人辞書の検索や、共有辞書でサーバを使わ
ない検索を行なう場合はこのプログラムを使用します。辞書ファイルは Emacs
のバッファに読み込まれます。

第 1 引数、第 2 引数、第 3 引数の意味はいずれも
@code{skk-search-kakutei-jisyo-file} の場合と同様です。

@item skk-okuri-search

形式: (skk-okuri-search)

自動送り処理を行なうプログラム。変数 @code{skk-auto-okuri-process} の値
が 非 nil のときだけ機能します。

個人辞書の送りありエントリを検索対象としているので、個人辞書のバッファを
流用します。そのため、専用の辞書バッファは作りません。

@item skk-search-server

形式: (skk-search-server FILE LIMIT &optional NOMSG)

サーバ経由で検索するプログラム。サーバが使用不能になると辞書ファイル
を Emacs のバッファに読み込んで検索を行ないます。

第 1 引数、第 2 引数、第 3 引数はいずれも
@code{skk-search-kakutei-jisyo-file}のそれと同じですが、第 2 引数及び第
3 引数は、辞書ファイルを Emacs のバッファに読み込んだときのみ利用されま
す。

@end ftable

@node 辞書ファイルを指定する変数, 辞書検索の設定の具体例, 辞書検索のための関数, 辞書に関する設定
@comment  node-name,  next,  previous,  up
@subsubsection 辞書ファイルを指定する変数

@vtable @code
@item skk-kakutei-jisyo

確定変換用の辞書。
@footnote{@xref{確定変換とその取り消し, , 確定変換}.}

この辞書は、標準の配布パッケージには含まれていないので、使用するのであれ
ばユーザー側で用意する必要があります。
@footnote{確定変換用辞書の見出し語の配列については、サイズが大きければ共
有辞書と同じ配列にして二分検索を行ない、サイズが小さければ適当な配置で直
線的検索を行なうことをお勧めします。

@xref{辞書の形式, , 共有辞書の配置}.

@noindent
を参照してください。}

@item skk-initial-search-jisyo

ふつう個人辞書の前に検索を行なう辞書。

変数 @code{skk-jisyo} に指定された辞書の前に検索が行なわれます。
@footnote{このため、この辞書を適当に切り替えることにより最初に出てくる候
補を操作することができます。例えば、複数の専門用語毎の辞書を用意しておい
て @code{skk-initial-search-jisyo} の値を切り替えることにより、専門分野
毎の専門用語を切り替えて入力することができます。}

この辞書は、標準の配布パッケージには含まれていないので、使用するのであれ
ばユーザー側で用意する必要があります。

@item skk-jisyo

個人辞書。SKK を一番最初に起動したときにファイルがなければ自動的に作られ
ます。

@code{skk-search-prog-list} の既定値では、個人辞書より先に検索するのは、
確定辞書と @code{skk-initial-search-jisyo} のみです。これはこのままにす
ることをお勧めします。

個人辞書の見出し語は、常に一番最近に変換された語が最小ポイントに挿入され
ます。
@footnote{その配列はバラバラなので、二分検索はできません。}

@item skk-large-jisyo

共有辞書。ユーザーの用途と資源に合わせて、S 辞書、M 辞書、L 辞書の中から選
びます。

ふつう、関数 @code{skk-search-jisyo-file} の第 1 引数として指定します。

@item skk-aux-large-jisyo

共有辞書。ユーザーの用途と資源に合わせて、S 辞書、M 辞書、L 辞書の中から選
びます。

ふつう、関数 @code{skk-search-server} の第 1 引数として指定します。

@item skk-backup-jisyo

個人辞書の予備 (バックアップ) 辞書。

これは、@code{skk-search-prog-list} に入れてはいけません。あくまで個人辞
書の予備辞書として指定してください。

@end vtable

@node 辞書検索の設定の具体例,  , 辞書ファイルを指定する変数, 辞書に関する設定
@comment  node-name,  next,  previous,  up
@subsubsection 辞書検索の設定の具体例

@code{skk-search-prog-list} の具体例を挙げると以下の様になります。

@lisp
@group
((skk-search-kakutei-jisyo-file skk-kakutei-jisyo 10000 t)
 (skk-search-jisyo-file skk-initial-search-jisyo 10000 t)
 (skk-search-jisyo-file skk-jisyo 0 t)
 (skk-okuri-search)
 (skk-search-jisyo-file skk-large-jisyo 10000)
 (skk-search-server skk-aux-large-jisyo 10000))
@end group
@end lisp

上記の例では、
@enumerate
@item
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}の順に検索を行ない、

@item
次に個人辞書を使って送り仮名の自動処理を行ない、

@item
その後、@code{skk-large-jisyo} の検索を行ない、

@item
最後に@code{skk-aux-large-jisyo} にサーバ経由でアクセスしています。

@end enumerate
もし確定辞書で候補が見つかったらそのまま自動的に確定されます。1 回
@key{SPC} を押す動作に対し、プログラム側では新たな候補を見つけるまで上記
の動作を進めます。例えば、
@enumerate

@item
確定辞書では候補は見つけられなかったが @code{skk-initial-search-jisyo}
に候補がある場合、そこで一旦止まりユーザーにその候補を表示します。

@item
更に @key{SPC} が押されると、次は個人辞書を検索します。そこで候補が見つ
かり、しかもその候補が@code{skk-initial-search-jisyo} で見つけた候補とは
異なるものであったときは、そこでまた一旦止まりその候補をユーザーに表示し
ます。

以降、共有辞書についても同様の繰り返しを行ないます。
@end enumerate

@code{skk-search-prog-list} の設定方法としては、例えば 
@code{skk-large-jisyo} に S 辞書か M 辞書を指定し、S 辞書、M 辞書はEmacs
のバッファに読み込んで検索して、@code{skk-aux-large-jisyo}に L 辞書を指
定し、L 辞書にはサーバ経由でアクセスする、という選択肢もあります。

@noindent
また、サーバ経由のアクセスも決して遅くはないので、

@lisp
(skk-search-jisyo-file skk-large-jisyo 10000)
@end lisp

@noindent
を削除するという選択肢もあります。
@footnote{ちなみに辞書ファイルを指定する変数の値が nil であれば、そのファ
イルを引数とした検索プログラムが @code{skk-search-prog-list} に指定されて
いても、その検索は行なわれません。例えば、@code{skk-search-prog-list} に
上記変更をする代わりに

@lisp
(setq skk-large-jisyo nil)
@end lisp

という設定をしてもふつう結果は同じです。}
@footnote{@file{skk-auto.el} を読みこむと、

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストが @code{skk-search-prog-list} に自動的に追加されます。実際
には、skk-auto.el は必要に応じてオートロードされるので明示的に読みこむ必
要はありません。オートロードされるのは、具体的には
@code{skk-auto-okuri-process} を非 nil に設定したとき、 あるいは

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストを @code{skk-search-prog-list} に明示的に指定したときなどで
す。}

@footnote{@file{skk-server.el}を読みこむと、

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストが @code{skk-search-prog-list} に自動的に追加されます。実際
には、skk-server.el は必要に応じてオートロードされるので明示的に読みこむ
必要はありません。オートロードされるのは、具体的には
@code{skk-server-host} または @code{skk-servers-list}を非 nil に設定
したとき、あるいは

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストを @code{skk-search-prog-list} に明示的に指定したときなどで
す。}

@node 入力モードの一時変更, ■モードにおける文字入力, 予備知識, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 入力モードの一時変更

SKK には、カタカナの入力にはカナモードを、全角アルファベットの入力には全
英モードを用いる
@footnote{@xref{入力モード, , カナモード、全英モード}.}普通のやり方のほ
かに、一時的にカナ文字、全英文字を入力して、また、かなモードに戻る方法が
あります。

また、アスキー文字を見出し語として使用するために、かなモードから一時
的にアスキー文字を入力する機能が提供されています。それは▽モードの変種で
あり、 @dfn{SKK abbrev mode} と呼ばれています。この機能を使用することに
より、

@samp{is}@result{}@samp{インクリメンタル・サーチ}

のような変換を行なうことができます。

ここではこれらの方法について説明します。

@menu
* ひらがな/カタカナの一時的入力::  
* 全英文字の一時的入力::        
@end menu

@node ひらがな/カタカナの一時的入力, 全英文字の一時的入力, 入力モードの一時変更, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection ひらがな/カタカナの一時的入力
@kindex @samp{q}
@cindex トグル変換

まず、かなモードもしくはカナモードに入ります。@samp{Q} キーで一旦▽モー
ドにして
@footnote{@samp{/}キーで SKK abbrev mode に入ってしまうと @samp{q} キー
入力が @samp{q} 文字の入力として扱われるのでこの場合は使いません。}なに
か文字列を入力し、その文字列の末尾で @samp{q} をタイプすると、 @samp{▽}
マークから @samp{q} を入力した位置までの文字列が、変換され確定されます。
変換は、@samp{▽} とポイント間の文字列の種類
@footnote{正確には @samp{▽} の次の位置にある文字列によって文字種の判別
を行なっているので、途中で文字種類の違う文字が混在していても無視されます。}
をキーとして、以下の規則に基づいて行なわれます。

@itemize @bullet
@item カタカナはひらがなへ
@item ひらがなはカタカナへ
@item 全英文字はアスキー文字へ
@item アスキー文字は全英文字へ
@end itemize

このような変換を、トグル変換と呼びます。以下はトグル変換の例です。

@example
@kbd{K a t a k a n a}

@group
------ Buffer: foo ------
▽かたかな@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
カタカナ@point{}
------ Buffer: foo ------
@end group
@end example

このトグル変換を上手く利用することにより、かなモードのまま一時的にカタカ
ナを入力したり、またその逆を行うことができます。こうすると、例えばひらが
な/カタカナ混じり文を書くときに、その都度 @samp{q} キーを押して入力モー
ドを切り換える必要がありません。
@footnote{全英文字とアスキー文字のトグルでの変換を行なうこともできます。
ただし、全英モードやアスキーモードでは @samp{Q} やその他の大文字により▽
モードに入ることができないので、かな ⇔ カナ のときと同様にドグル変換で
きるわけではありません。かなモード/カナモードにおいて、既に入力さ
れた全英文字、アスキー文字に対してトグル変換をするような設計になっていま
す。}

トグル変換は、領域を対象としたコマンドによって行なうこともできます。

@xref{領域一括変換}.

@node 全英文字の一時的入力,  , ひらがな/カタカナの一時的入力, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection 全英文字の一時的入力
@kindex @samp{/}
@kindex C-q

まず、かなモードに入ります。次に、@samp{/} を入力すると、SKK abbrev モー
ドに入ります。
続いて、全角アルファベットとして入力したい文字列を挿入し、その文字列の末
尾で @kbd{C-q}
@footnote{@kbd{C-q} は @code{skk-abbrev-mode-map} にて特別な動作をするよ
うに定義されています。
@xref{アスキー文字を見出し語とした変換}.}を入力することで、@samp{▽}マー
クから @kbd{C-q} を入力した位置までの文字列が全角アルファベットに変換さ
れ確定されます。

@example
@kbd{/ f i l e}

@group
------ Buffer: foo ------
▽file@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
ｆｉｌｅ@point{}
------ Buffer: foo ------
@end group
@end example

なお、この変換を行なうために、

@example
file /ｆｉｌｅ/
@end example

@noindent
のような辞書エントリを持つ必要はありません。なぜなら、辞書を参照せず、ア
スキー文字を 1 文字づつ全英文字に変換しているからです。

@node ■モードにおける文字入力, ポイントを戻して▽モードへ, 入力モードの一時変更, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section ■モードにおける文字入力

@menu
* かなモード/カナモードにおける入力::  
* skk-rom-kana-base-rule-listの具体例::  
* skk-rom-kana-rule-listの利用例::  
* ■モードに関連するその他の変数::  
* 全英モードにおける入力::      
* 1回の取り消し操作(undo)の対象::  
* 対になる文字列の一括入力::    
@end menu

@node かなモード/カナモードにおける入力, skk-rom-kana-base-rule-listの具体例, ■モードにおける文字入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection かなモード/カナモードにおける入力

@menu
* ■モードにおける文字変換::    
@end menu

@node ■モードにおける文字変換,  , かなモード/カナモードにおける入力, かなモード/カナモードにおける入力
@comment  node-name,  next,  previous,  up
@subsubsection ■モードにおける文字変換
@cindex T-code
@cindex TUT-code

@vtable @code
@item skk-rom-kana-base-rule-list
@item skk-rom-kana-rule-list
@end vtable

SKK の■モードにおける文字変換は、上記 2 変数を用いて行なわれます。

これらは、1 種の規則であり、「入出力の状態がいかに移り変わるべきか」を決
定します。その内容は、

@example
(入力される文字列 出力後に自動的に入力に追加される文字列 出力)
@end example

@noindent
という形のリストを列挙したものです。

@samp{入力される文字列} とは変換される前の ASCII 文字の文字列をいいます。

@samp{出力} は次の入力状態に移るときにバッファに挿入される文字列の組み合
わせであり、 @w{("ア" . "あ")} のようなコンスセルです。

2 変数のうち、@code{skk-rom-kana-rule-list} は使用者が独自の規則を定義す
るために用意されていて、@code{skk-rom-kana-base-rule-list} の規則より優
先されます。

@menu
* skk-rom-kana-base-rule-listの具体例::
* skk-rom-kana-rule-listの利用例::
* ■モードに関連するその他の変数::
@end menu

@node skk-rom-kana-base-rule-listの具体例, skk-rom-kana-rule-listの利用例, かなモード/カナモードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec skk-rom-kana-base-rule-listの具体例

@code{skk-rom-kana-base-rule-list} には

@example
("a" nil ("ア" . "あ"))
("ki" nil ("キ" . "き"))
("tt" "t" ("ッ" . "っ"))
("nn" nil ("ン" . "ん"))
("n'" nil ("ン" . "ん"))
@end example

@noindent
のような規則があります。これによると

@example
a @expansion{}あ
ki @expansion{}き
tt @expansion{}っt
nn @expansion{}ん
n' @expansion{}ん
@end example

@noindent
のようになります。

@node skk-rom-kana-rule-listの利用例, ■モードに関連するその他の変数, skk-rom-kana-base-rule-listの具体例, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec skk-rom-kana-rule-listの利用例

@code{skk-rom-kana-base-rule-list} の規則に従うと

@example
hannou @expansion{}はんおう
han'ou @expansion{}はんおう
hannnou @expansion{}はんのう
@end example

@noindent
のようになります。ここで

@lisp
@group
(setq rom-kana-rule-list
      (append rom-kana-rule-list
              '(("nn" "n" ("ン" . "ん"))
@end group
@end lisp

のような設定にすることで

@example
hannou @expansion{}はんのう
@end example

@noindent
のようにローマ字かな変換が行われるようになります。

もうひとつ利用例を挙げます。

@example
tp @expansion{}東北大学
skk @expansion{}skk
skK @expansion{}SKK
@end example

@noindent
といった変換は、

@lisp
@group
("tp" nil ("東北大学" . "東北大学"))
("sk" "sk" ("" . ""))
("skk" nil ("skk" . "skk"))
("skK" nil ("SKK" . "SKK"))
@end group
@end lisp

@noindent
のような規則を追加することで実現されます。自分の名前を入力することはよく
あるので、適当な省略形を用いて、このリストに追加しておく、といった利用を
お勧めします。

更に @code{skk-rom-kana-rule-list} を用いれば T-code や TUT-code による
日本語入力を実現することもできます。例えば TUT-code による入力については
ソースアーカイブの @samp{experimental/tut-code} ディレクトリに収録されて
いるソースコードを参照してください。

@node ■モードに関連するその他の変数, 全英モードにおける入力, skk-rom-kana-rule-listの利用例, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec ■モードに関連するその他の変数

@vtable @code
@item skk-kana-input-search-function

ルールリストの中に記せない変換ルールを処理する関数。これは

@example
ohs @expansion{}おおs
@end example

@noindent
のような変換を実現するために用意されています。これにより

@example
ohsaka @expansion{}おおさか
ohta @expansion{}おおた
@end example

@noindent
のように変換されますが、一方

@example
ohhonn @expansion{}おっほん
ohhira @expansion{}おっひら
@end example

@noindent
となる場合もあります。これは @code{skk-rom-kana-rule-list} の既定値に

@example
("hh" "h" ("ッ" . "っ"))
@end example

@noindent
が入っているためです。これを削除すれば

@example
ohhonn @expansion{}おおほん
ohhira @expansion{}おおひら
@end example

@noindent
となります。
@end vtable

@menu
* 数字や記号文字の入力::        
@end menu

@node 数字や記号文字の入力,  , ■モードに関連するその他の変数, ■モードに関連するその他の変数
@comment  node-name,  next,  previous,  up
@subsubsection 数字や記号文字の入力

かなモード/カナモードにおける次のキーは、かつては @code{skk-self-insert} 
関数にバインドされていました。現在は他のキーと同様に @code{skk-insert}
関数にバインドされています。

@example
@group
!  #  %  &  '  *  +

-  0  1  2  3  4  5

6  7  8  9  :  ;  <

=  >  ?  "  (  )  [

]  @{  @}  ^  _  `  |

~
@end group
@end example

これらの数字や記号文字のキーに対応し挿入される文字は、変数
@code{skk-input-vector} の値により決定されていましたが、このバージョンの
SKK ではこの変数は廃止されました。カスタマイズするためには、代わりに変数
@code{skk-rom-kana-rule-list} を利用します。例えば、SKK 9.6 以前において、

@lisp
(aset skk-input-vector ?! nil)
(aset skk-input-vector ?, nil)
(aset skk-input-vector ?. nil)
(aset skk-input-vector ?: nil)
(aset skk-input-vector ?; nil)
(aset skk-input-vector ?? nil)
@end lisp

このような設定をしていた場合、本バージョンの SKK で同様の入力をするため
には、

@lisp
(setq skk-rom-kana-rule-list
      (nconc skk-rom-kana-rule-list
             '(("!" nil "!")
               ("," nil ",")
               ("." nil ".")
               (":" nil ":")
               (";" nil ";")
               ("?" nil "?"))))
@end lisp

のような設定に変更する必要があります。

@code{skk-insert} は、Emacs のオリジナル関数 @code{self-insert-command}
をエミュレートしています。具体的には、引数を渡すことによって同じ文字を複
数、一度に挿入することが可能です
@footnote{かつては、@samp{▽あ}などを入力する場合には引数渡しができなかっ
たのですが、本バージョンでばこれもできるように拡張されています。}。

@example
@group

@kbd{C-u 2 !}

------ Buffer: foo ------
！！
------ Buffer: foo ------
@end group
@end example

@node 全英モードにおける入力, 1回の取り消し操作(undo)の対象, ■モードに関連するその他の変数, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 全英モードにおける入力

全英モードにおける印字可能な全てのキーはコマンド
@code{skk-jisx0208-latin-insert} に割り付けられています。また、変数
@code{skk-jisx0208-latin-vector} の値により挿入される文字が決定されます。
@code{skk-jisx0208-latin-vector} の既定値は以下のようになっています。

@lisp
@group
[nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 "　"  "！" "”" "＃" "＄" "％" "＆" "’"
 "（" "）" "＊" "＋" "，" "−" "．" "／"
 "０" "１" "２" "３" "４" "５" "６" "７"
 "８" "９" "：" "；" "＜" "＝" "＞" "？"
 "＠" "Ａ" "Ｂ" "Ｃ" "Ｄ" "Ｅ" "Ｆ" "Ｇ"
 "Ｈ" "Ｉ" "Ｊ" "Ｋ" "Ｌ" "Ｍ" "Ｎ" "Ｏ"
 "Ｐ" "Ｑ" "Ｒ" "Ｓ" "Ｔ" "Ｕ" "Ｖ" "Ｗ"
 "Ｘ" "Ｙ" "Ｚ" "［" "＼" "］" "＾" "＿"
 "‘" "ａ" "ｂ" "ｃ" "ｄ" "ｅ" "ｆ" "ｇ"
 "ｈ" "ｉ" "ｊ" "ｋ" "ｌ" "ｍ" "ｎ" "ｏ"
 "ｐ" "ｑ" "ｒ" "ｓ" "ｔ" "ｕ" "ｖ" "ｗ"
 "ｘ" "ｙ" "ｚ" "｛" "｜" "｝" "〜" nil]
@end group
@end lisp

挿入される文字の変更方法を知りたい場合は、

@ref{数字や記号文字の入力}

@noindent
を参照してください。

@code{skk-jisx0208-latin-insert} も Emacs オリジナルの関数 
@code{self-insert-command} をエミュレートしています。つまり、引数を渡す
ことにより同じ文字を複数、一度に挿入することができます。
@code{skk-insert}における動作と同じですから、

@xref{数字や記号文字の入力}.

@noindent
における例を参考にしてください。

@node 1回の取り消し操作(undo)の対象, 対になる文字列の一括入力, 全英モードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 1回の取り消し操作(undo)の対象
@cindex @file{keyboard.c}
@findex self-insert-command
@findex skk-abbrev-comma
@findex skk-abbrev-period
@findex skk-kana-input
@findex skk-insert
@findex skk-set-henkan-point
@findex skk-jisx0208-latin-insert
@vindex skk-self-insert-non-undo-count

Emacs では本来、連続する 20 文字の挿入が一回の取り消し操作 (アンドゥ) の
対象となっています。そこで SKK のかな・カナ・全英モードにおける入力も、
これと同様の動作をするように設計されています。
@footnote{@code{buffer-undo-list}にEmacsが挿入したアンドゥの境目の目印を
取り除く方法でエミュレートしています。}。正確に言えば、
@code{skk-kana-input}, @code{skk-self-insert},
@code{skk-set-henkan-point}, @code{skk-jisx0208-latin-insert}
@footnote{SKK abbrev モードでは、アスキー文字入力が Emacs オリジナルの
@code{self-insert-command} により行なわれているので、エミュレーションの
ための内部変数である@code{skk-self-insert-non-undo-count}をインクリメン
トすることができず、アンドゥをエミュレートできません。しかも、カンマやピ
リオドを挿入した時点で、コマンド @code{skk-abbrev-comma} や
@code{skk-abbrev-period} を使うことになるので、オリジナルのアンドゥの機
能も損なってしまいます。ただし、現実問題として、元来 SKK abbrev モードは
省略形としての見出し語を挿入するためのモードですから、長い見出し語を挿入
することはあまりないと考えられます。}の各関数にバインドされたキー入力に
ついては、連続して入力された 20 文字を 1 つのアンドゥの対象としています
@footnote{`20' は Emacs のソースファイルの一部である @file{keyboard.c}
に定められたマジックナンバーと一致します。}。

ただし、これらの SKK のコマンドと Emacs 本来の
@code{self-insert-command} を織り混ぜてキー入力した場合
@footnote{かなモードでの入力中、アスキーモードに移行してタイプした場合な
どがこれにあたります。}は、このエミュレーションは正常に動作しませんが、
これは現在の仕様です。

@example
@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o}

------------------------- Buffer: foo -------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{連続する20文字。}
------------------------- Buffer: foo -------------------------
@end group
@group

@kbd{C-_}

------------------------- Buffer: foo -------------------------
                       ;@r{20文字全てがアンドゥの対象となる。}
------------------------- Buffer: foo -------------------------
@end group

@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o n a}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてとな ;@r{連続する21文字。}
-------------------------- Buffer: foo --------------------------
@end group
@group

@kbd{C-_}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{最後の1文字のみがアンドゥの対象となる。}
-------------------------- Buffer: foo --------------------------
@end group
@end example

@node 対になる文字列の一括入力,  , 1回の取り消し操作(undo)の対象, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 対になる文字列の一括入力
@vindex skk-auto-insert-paren
@vindex skk-auto-paren-string-alist
@vindex skk-rom-kana-rule-list
@vindex yatex-mode
@vindex tex-mode-hook

@c @samp{「}や@samp{」}が上手く処理されない...。
ふつう、`「' を入力したら、`」' を後で入力する必要があります。`「' の入
力時点で、対になる文字を自動挿入してくれると打鍵数を減らすことができます
し、同時に入力忘れの防止にもなるでしょう。

そのために変数 @code{skk-auto-insert-paren} が用意されています。この値を
非 nil にすると、上記の自動挿入を行ないます、

@example
@group
------ Buffer: foo ------
彼はこう言った@point{}
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
彼はこう言った「@point{}」
------ Buffer: foo ------
@end group
@end example

@noindent
@c @samp{「}や@samp{」}が上手く処理されない...。
上記のように `「' の入力時点で対となる`」'を自動挿入し、`「'と`」'の間に
ポイントを再配置するので、その位置からかぎかっこに囲まれた文字列を即始め
ることができます。

自動挿入すべきペアの文字列は、変数 @code{skk-auto-paren-string-alist} で
指定します。既定値は下記のようになっています。

@lisp
@group
(("「" . "」") ("『" . "』") ("(" . ")") ("（" . "）") ("{" . "}")
 ("｛" . "｝") ("〈" . "〉") ("《" . "》") ("[" . "]") ("［" . "］")
 ("〔" . "〕") ("【" . "】") ("\"" . "\"") ("“" . "”") ("`" . "'"))
@end group
@end lisp

@noindent
これは、ひと言でまとめると、「開き括弧と閉じ括弧とのコンスセルを集めたリ
スト」です。各コンスセルの @code{car} にある文字列を挿入したときに、
@code{cdr} にある文字列が自動挿入されます。
@footnote{このリストの各要素の @code{car} の文字列は、必ず変数
@code{skk-rom-kana-rule-list} の規則によって入力されなければなりません。
例えば、@samp{(} に対する @samp{)} の自動挿入をするには

@lisp
@group
(setq skk-rom-kana-rule-list
      (nconc skk-rom-kana-rule-list
            '(("(" nil "("))))))
@end group
@end lisp

のような設定をする必要があります。}
@footnote{既に SKK モードになっているバッファで変数
@code{skk-auto-paren-string-alist} を変更した場合は、@kbd{C-x C-j} もし
くは @kbd{C-x j} を 2 度タイプして @code{skk-mode} もしくは
@code{skk-auto-fill-mode} を起動し直す必要があります。}

キーとなる文字の挿入が行なわれても、その挿入後のポイントに自動挿入すべき
文字が既に存在している場合には、自動挿入は行なわれないように設計されてい
ます。

@example
@group
------ Buffer: foo ------
@point{}」
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
「@point{}」
------ Buffer: foo ------

@end group
@end example

対になる文字を複数挿入したい場合は、引数を渡して文字を指定します。

@example
@group

@kbd{C-u 2 [}

------ Buffer: foo ------
「「@point{}」」
------ Buffer: foo ------
@end group
@end example

@code{yatex-mode} など、既に同種の機能が付いているモードがあります。その
ようなモードにおいてもこの自動挿入の機能が邪魔になることはないでしょうが、
そのモードにおいてのみこの機能をオフにしたい場合は、該当のモードに入った
ときにコールされるフック変数を利用して設定を行なうことができます。

@lisp
@group
(add-hook 'yatex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (set (make-local-variable 'skk-auto-insert-paren) nil)))))
@end group
@end lisp

特定のモードにおいて、自動挿入すべき文字を変更したい場合にも同様にフック
変数を用いて操作できます。

@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (cons '("$" . "$") skk-auto-paren-string-alist)))))))
@end group
@end lisp

@noindent
同様に、特定のペアを削除したい場合は、例えば下記のように設定します
@footnote{何故関数 @code{copy-sequence} を使用するのかについては、

@ref{数字や記号文字の入力}

@noindent
を参照してください。}。

@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (delete
                          '("$" . "$")
                          (copy-sequence skk-auto-paren-string-alist))))))))
@end group
@end lisp

@node ポイントを戻して▽モードへ, 確定変換とその取り消し, ■モードにおける文字入力, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section ポイントを戻して▽モードへ
@cindex ▽マークの付け忘れ
@kindex M-Q
@vindex skk-allow-spaces-newlines-and-tabs

▽モードに入り忘れた場合の▽マークの付け方については、前述しました
@footnote{@xref{▽モード, , ▽マークの付け忘れ}.}。ここでは、これを簡略
化し、一回の操作で行なう方法について説明します。

@kbd{M-Q}
@footnote{ここで @samp{Q} は大文字で入力する必要があります。}とタイプす
ると現在位置の直前の文字列について走査し、同種の文字
@footnote{ひらがな、カタカナ、全角アルファベット、アルファベットの 4 種
類のいずれか。}が続く限り 後方にポイントを戻して▽モードに入り、またポイ
ントを元の地点に戻します。
@footnote{後方にポイントを戻す途中で行頭に到達した場合は、更に上の行につ
いて、行末の文字列から同様の走査を行ない、必要があれば更にポイントを戻し
ます。こうした「行を超えての走査」をやめるためには、変数
@code{skk-allow-spaces-newlines-and-tabs} の値を nil に設定します。}

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{M-Q}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

変換開始位置を決定するとき、スペース文字、タブ文字、長音を表わす @samp{ー}
は無条件に無視されます。ただし、ひらがなの場合は @samp{を} が、カタカナ
の場合は@samp{ヲ}が見つかった時点で変換開始位置の走査を止め、▽モードに
入ります。変換開始ポイントを@samp{を}、@samp{ヲ}の直前で止めるのは、たい
ていその直後から単語が始まるからです。

以上は @kbd{M-Q} を引数を与えないで実行した場合です。一方で、@kbd{C-u 5
M-Q} のように引数を渡して実行すると、変換開始位置から現在位置までの文字
数を指定することができます。この場合は文字種別を問わず、与えられた文字数
だけ無条件にポイントを戻します。

@node 確定変換とその取り消し, 確定アンドゥ, ポイントを戻して▽モードへ, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 確定変換とその取り消し
@cindex 暗黙の確定
@findex skk-search-kakutei-jisyo-file
@vindex skk-kakutei-jisyo

確定変換を行なう関数 @code{skk-search-kakutei-jisyo-file}と 確定辞書を指
定するための変数 @code{skk-kakutei-jisyo} については先に説明しました。
@footnote{@ref{辞書検索のための関数}}ここではその動作についてより詳しく
説明します。

例えば、

@example
せつめい /説明/
@end example

@noindent
というエントリが確定辞書にあったとします。このとき、

@example
@group
@kbd{S e t u m e i}

@group
------ Buffer: foo ------
▽せつめい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
説明
------ Buffer: foo ------
@end group
@end group
@end example

@noindent
のように確定動作をすることなしに(暗黙の確定もなく) いきなり確定します。
仮に確定辞書に

@example
じしょ /辞書/
@end example

@noindent
というエントリを挿入してしまったが、@samp{自署}に変換したい場合は、確定
直後に @samp{x} をタイプすることにより確定変換を取り消して▽モードに戻る
ことができます。この場合は、次に @key{SPC} をタイプしたときは、確定辞書
の検索を行なわないません。そのため個人辞書、あるいは共有辞書に

@example
じしょ /自署/
@end example

@noindent
のエントリがあれば @samp{自署} への変換を行なうことができます。

@example
@group
@kbd{Z i s y o @key{SPC}}

@group
------ Buffer: foo ------
辞書
------ Buffer: foo ------
@end group

@kbd{x}

@group
------ Buffer: foo ------
▽じしょ
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼自署
------ Buffer: foo ------
@end group

@end group
@end example

@node 確定アンドゥ, 見出し語関連, 確定変換とその取り消し, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 確定アンドゥ
@cindex 暗黙の確定
@cindex 確定アンドゥ
@findex skk-undo-kakutei

一番最後に行なった変換についての確定を取り消して、再変換を行なうことがで
きます。これを@b{「確定アンドゥ」}と呼びます。これは確定変換の取り消しと
は異なる概念です。

例えば、辞書エントリが

@example
こうこう /高校/孝行/航行/
@end example

@noindent
のようになっているとします。

@example
@kbd{K o u k o u @key{SPC}}

@group
------ Buffer: foo ------
▼高校
------ Buffer: foo ------
@end group

@kbd{s u r u}

@group
------ Buffer: foo ------
高校する@point{}
------ Buffer: foo ------
@end group

@kbd{M-x skk-undo-kakutei}

@group
------ Buffer: foo ------
▼孝行@point{}する
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、@samp{高校} の確定について取り消しています。すると、辞書の第
一候補である @samp{高校} をとばして、次候補である @samp{孝行} が現れます。
ここで更に @key{SPC} を押せば次候補である @samp{航行} が現れ、更にもう一
度 @key{SPC} を押せば辞書登録モードに入ります。

この例に見られるように、確定アンドゥは、確定した直後でなくとも有効です。
より正確には、次の新たな確定
@footnote{@kbd{C-j} をタイプして明示的に確定した場合は勿論、暗黙の確定を
行なった場合も同様です。}を行なうまでは確定に関する情報が保持されている
ので、確定アンドゥすることができます。

また、変換、確定に関連しない文字列は、確定アンドゥを行なっても削除されな
いように設計されています。上記の例では、@samp{する} がそのままカレントバッ
ファに残っています。

@node 見出し語関連, 送り仮名関連, 確定アンドゥ, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 見出し語関連

@menu
* 見出し語の補完::              
* 見出し語を補完しながら▼モードへ::  
* 空白・改行・タブを含んだ見出し語の変換::  
* カタカナの見出し語::          
@end menu

@node 見出し語の補完, 見出し語を補完しながら▼モードへ, 見出し語関連, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語の補完
@cindex 読みの補完
@cindex 見出し語の補完
@kindex @samp{,}
@kindex @samp{.}
@kindex @key{TAB}

▽モードで @key{TAB} を押すと、見出し語 (▽モードにおける入力文字列) に
対する補完が行われます。今、@key{TAB}を押す直前に▽モードで入力された文
字列をσと呼ぶことにします。このとき、個人辞書
@footnote{共有辞書は検索されません。それは、共有辞書では一般的に先頭の文
字を共通にする見出し語が多すぎて、望みの補完が行なえる確率が低いからです。}
の送りなしエントリの中で、先頭がσと一致し長さがσよりも長い見出し語を捜
して、そのような語がもしあれば、σの代わりにその語が表示されます。

見出し語の補完を上手に利用すると、打鍵数を減らすことができます。

個人辞書では最近更新されたエントリほど上位に来るようになっています
@footnote{@ref{辞書ファイルを指定する変数}}。したがって、▼モードで変換
を行なった語の見出し語について、時間的に新しいものから先に補完が行なわれ
ます。例えば、@samp{斉藤}、@samp{佐藤} の順で変換した後、@samp{さ} をキー
にして見出し語の補完を行なうと、最初に @samp{さとう} が、その次に @samp{
さいとう} が補完されます。補完が意図したものでなかったときには @key{TAB}
の直後に @samp{.} (ピリオド) をタイプすると 2 番目の見出し語が表示されま
す。以降、同様に @samp{.} を続けてタイプすると、見出し語の候補が順次表示
されます。意図した見出し語を通りすぎたときは @samp{,} (コンマ) で前の候
補に戻ります。

@example
@kbd{S a t o u @key{SPC} C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group

@kbd{S a}

@group
------ Buffer: foo ------
▽さ
------ Buffer: foo ------
@end group

@key{TAB}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@samp{.}

@group
------ Buffer: foo ------
▽さいとう@footnote{@samp{さとう} の次に補完される見出し語は、個人辞書の
内容に依存します。}
------ Buffer: foo ------
@end group

@samp{,}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼佐藤
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group
@end example

なお、個人辞書の検索は、見出し語を得るために行なわれるので、一旦 
@key{SPC} を入力して▼モードに入れば普通の変換動作に入ります。

@vtable @code
@item skk-dabbrev-like-completion

この変数の値を 非 nil にすると、見出し語補完の動作が変化します。具体的
には、@samp{.} で 2 番目以降の補完を行なったときに、最初に補完された語に
ついて補完が行われます。つまり上記の例では @samp{さ} に対し、最初に補完
された語は、@samp{さとう} なので、以後の補完は、@samp{さとう} を含む語 (
例えば、@samp{さとうせんせい}など) について行なわれます。
@end vtable


@node 見出し語を補完しながら▼モードへ, 空白・改行・タブを含んだ見出し語の変換, 見出し語の補完, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語を補完しながら▼モードへ
@cindex 見出し語の補完
@cindex 読みの補完
@kindex M-@key{SPC}

前節で見出し語の補完について述べました。本節では、見出し語の補完動作を行
なった後、@key{SPC} を入力し、▼モードに入るまでの動作を一回の操作で行な
う方法について説明します。

やり方は簡単。@key{TAB}・@key{SPC}と打鍵していたところを、
@kbd{M-@key{SPC}} に換えると、補完した上で変換を開始します。

この方法によると、補完される見出し語があらかじめ分かっている状況では、キー
入力を一回分省略できるので、長い見出し語の専門用語を連続して入力する場合
などに威力を発揮します。

@example
@group
@kbd{K a s i t a n n p o s e k i n i n n}

@group
------ Buffer: foo ------
▽かしたんぽせきにん
------ Buffer: foo ------
@end group

@key{SPC}, @key{RET}

@group
------ Buffer: foo ------
瑕疵担保責任
------ Buffer: foo ------
@end group

@kbd{K a}

@group
------ Buffer: foo ------
▽か
------ Buffer: foo ------
@end group

@kbd{M-@key{SPC}}

@group
------ Buffer: foo ------
▼瑕疵担保責任
------ Buffer: foo ------
@end group

@end group
@end example

@node 空白・改行・タブを含んだ見出し語の変換, カタカナの見出し語, 見出し語を補完しながら▼モードへ, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 空白・改行・タブを含んだ見出し語の変換

以下のようにオートフィルモードで折り返された文字列に対し、折り返された状
態のまま変換を行なう方法があります。

@example
@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムをさ
くせいしました。@point{}
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 10 C-b Q}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽@point{}さ
くせいしました。
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 5 C-f}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽さ
くせい@point{}しました。
---------------- Buffer: foo ------------------
@end group

@key{SPC}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▼作成@point{}しました。
---------------- Buffer: foo ------------------
@end group
@end example

ここでは改行を越えて見出し語を探し、変換する例を示しました。同様に、空白、
タブ文字を中間に含む文字列に対しても変換を行なうことができます。

@vtable @code
@item skk-allow-spaces-newlines-and-tabs

この変数を nil に設定すると、本節で説明したような 2 行以上にまたがる文字
列に対する変換を禁止します。
@end vtable

@node カタカナの見出し語,  , 空白・改行・タブを含んだ見出し語の変換, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection カタカナの見出し語
@kindex C-u @key{SPC}

@samp{q} によりかなモード、カナモードを度々切り替えて入力を続けていると、
カナモードで誤って▼モードに入ってしまうことがあります。そのため、カナモー
ドで▼モードに入った場合、まず見出し語をひらがなに変換してから、辞書の検
索に入るよう設計されています。

この場合、送りあり変換での送り仮名も平仮名になります。もし、送り仮名をカ
タカナにしたい場合には、@ref{カナモードでの変換の送り仮名の処理}を参照し
てください。

また、もしカタカナの文字列をそのまま見出し語として変換を行ないたい場合に
は、@key{SPC} で変換に入る代わりに @kbd{C-u @key{SPC}} と入力します。

@node 送り仮名関連, 自動変換開始, 見出し語関連, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 送り仮名関連

@menu
* 送り仮名の厳密なマッチ::      
* 送り仮名の自動処理::          
* 送りあり変換の変換開始のタイミング::  
* カナモードでの変換の送り仮名の処理::  
@end menu

@node 送り仮名の厳密なマッチ, 送り仮名の自動処理, 送り仮名関連, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の厳密なマッチ
@vindex minibuffer-exit-hook
@vindex minibuffer-setup-hook

今、個人辞書に

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
という送りありエントリがあると仮定します。

ここで @kbd{O o K i i @key{SPC}} と入力した場合、普通は @samp{大きい} と
@samp{多きい} という 2 通りの候補が出力されますが、このうち @samp{多きい}
は現代の日本語として正しくありません。このような場合に、出力される候補を
正しい表現のみに絞りこむ方法について、説明します。

@vtable @code
@item skk-henkan-okuri-strictly
@vindex skk-process-okuri-early

この変数の値を 非 nil に設定すると、見出し語がマッチするかどうかのチェッ
クの上に、送り仮名がマッチするかどうかのチェックが行なわれます。結果とし
て送り仮名がマッチしない候補は出力されません。上記の例では、送り仮名
@samp{き} がマッチする @samp{大きい} は出力されますが、@samp{多きい}は出
力されません。
@footnote{この機能は、変数 @code{skk-process-okuri-early} の値を非 nil
に設定した状態と共存できません。この理由を知りたい場合は
@ref{送りあり変換の変換開始のタイミング}を参照してください。ただしメニュー
バーを使用してこのユーザーオプションをオンにすると、自動的に
@code{skk-process-okuri-early} の値を nil にするよう設計されています。}

個人辞書の送りありエントリが充実していれば、標準の設定よりも候補が絞り込
まれるので変換効率がアップしますが、さもなければ、すぐに辞書登録モードに
入ってしまうため逆に不便になります。
@end vtable

変数 @code{skk-henkan-okuri-strictly} の値を 非 nil にすると、辞書登録モー
ドに入っても送り仮名のマッチが厳密に行なわれます。これは辞書登録の際希望
する候補を得るためには障害となります。そのような障害を避けるためには、下
記のようにフック変数を設定します。これにより、辞書登録時だけは、一時的に
送り仮名の厳密なマッチをしないようになります。
@footnote{実は変数 @code{skk-henkan-okuri-strictly} の値は辞書バッファで
参照されるので、ミニバッファのバッファローカル値を変更してもうまくいきま
せん。
将来のバージョンでは、これを改良し、辞書バッファでの動作に影響するユーザー
変数をバッファローカル化できるようにする予定です。

@xref{拡張アイディア}.}

@lisp
@group
(add-hook 'minibuffer-setup-hook
          (function
           (lambda ()
             (if (and (boundp 'skk-henkan-okuri-strictly)
                      skk-henkan-okuri-strictly
                      (not (eq last-command 'skk-purge-jisyo)))
                 (progn
                   (setq skk-henkan-okuri-strictly nil)
                   (put 'skk-henkan-okuri-strictly 'temporary-nil t))))))

@end group
@group
(add-hook 'minibuffer-exit-hook
          (function
           (lambda ()
             (if (and (get 'skk-henkan-okuri-strictly 'temporary-nil)
                      (<= (minibuffer-depth) 1))
                 (progn
                   (put 'skk-henkan-okuri-strictly 'temporary-nil nil)
                   (setq skk-henkan-okuri-strictly t))))))
@end group
@end lisp

@node 送り仮名の自動処理, 送りあり変換の変換開始のタイミング, 送り仮名の厳密なマッチ, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の自動処理
@vindex skk-auto-okuri-process

@menu
* どのように変換されるか::      
* 辞書登録の際に注意すべきこと::  
@end menu

@node どのように変換されるか, 辞書登録の際に注意すべきこと, 送り仮名の自動処理, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection どのように変換されるか

@vtable @code
@item skk-auto-okuri-process

この変数の値を 非 nil に設定すると、送り仮名の自動処理が行なわれます。
@end vtable

例えば、@kbd{T a t i a g e r u @key{SPC}} と入力した場合を考えます。

@samp{たちあげる} という見出し語に対し、送り仮名を明示していないので、ま
ず送りなし変換として扱い辞書を検索します。このときは、通常の変換同様、個
人辞書及び指定された共有辞書他を検索します。その後、送りありの検索に移り
ます。ここでは個人辞書のみを検索の対象とします。見出し語を最後尾から1文
字づつ切り詰め、「切り詰めの結果残った文字列」と、「切り捨てられた先頭の
文字のローマ字プレフィックス」を連結した文字列を送りあり変換の見出し語と
して、検索します。

この例において検索される見出し語の変化を追うと、

@example
@samp{たちあげる}@result{}@samp{たちあげr}@result{}@samp{たちあg}
@result{}@samp{たちa}@result{}@samp{たt}
@end example

@noindent
のようになります。仮に個人辞書エントリが、

@example
@group
たちあg /立ち上/[げ/立ち上/]/[が/立ち上/]/
たt /建/断/経/立/[つ/建/断/経/立/]/[ち/建/断/経/立/]/[て/経/立/建/]/
@end group
@end example

@noindent
の 2 つのエントリを含むとすると、見出し語を後方から順に切り詰める過程で
@samp{たちあg} と @samp{たt} の 2 つの見出し語の検索時にこれらの辞書エン
トリがマッチします。

@noindent
次に、マッチしたエントリの各候補に対し、切り捨てられた先頭の文字を送り仮
名として取るかどうかをチェックします。この判断には、辞書の送り仮名ブロッ
ク部分
@footnote{@ref{送りありエントリのブロック形式}.}を利用します。

@samp{たちあg} の場合の送り仮名チェックの対象は、切り捨てられた最初の文
字の @samp{げ} です。辞書に

@example
[げ/立ち上/]
@end example

@noindent
の部分があることから、送り仮名として取るべきと判断します。また、@samp{た
t} の場合の送り仮名チェックの対象は、@samp{ち} です。辞書に

@example
[ち/建/断/経/立/]
@end example

@noindent
の部分があることから、送り仮名として取るべきと判断します。

@noindent
こうして、送り仮名がマッチする候補が @samp{立ち上}、@samp{建}、@samp{断}、
@samp{経}、@samp{立} の 5 つに絞られます。これらは文字列の長さ順に昇順に
ソートされ
@footnote{長さ順にソートするのは、変換された部分がより長い候補を先順位
として出力するためです。}、それぞれの候補と該当の見出し語から切り捨てら
れた文字列と連結したもの
@footnote{@samp{該当の見出し語から切り捨てられた文字列} を送り仮名とみな
して処理しています。}を、送り仮名の自動処理の最終候補として返します。上
記の例では、@samp{立ち上げる}、@samp{建ちあげる}、@samp{断ちあげる}、
@samp{経ちあげる}、@samp{立ちあげる} の 5 つが最終候補になります。

ここで、自動送り機能の長所を考えてみると、

@itemize @bullet
@item 送り仮名の最初のローマ字表現を大文字で始める必要がない。
@item 送り仮名を正確に思い出せない場合に送り仮名を指定しなくとも変換でき
る。
@end itemize

などがあります。一方短所としては、

@itemize @bullet
@item 意図しない変換をされる割合が増える。
@item 個人辞書の送りありエントリが貧弱な場合は、自動処理ができない可能性
が高い。
@end itemize

などが考えられます。変数 @code{skk-auto-okuri-process} の値を非 nil に設
定しても、従来通りの送りあり変換も同時にできますから、一度この機能を試し
てみることをお勧めします。
@footnote{専ら補完的に自動送り処理を利用するのであれば、
@code{(skk-okuri-search)}を @code{skk-search-prog-list}の最後にもってく
るという手もあります。}

@node 辞書登録の際に注意すべきこと,  , どのように変換されるか, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録の際に注意すべきこと

個人辞書に見出し語 @samp{わたs} についてのエントリが全くない場合、あるい
は個人辞書のエントリが

@example
わたs /渡/[し/渡/]/
@end example

@noindent
のような送り仮名のブロックを持たない場合を考えてみます。ここで、@kbd{W a
t a s i t a @key{SPC}}と入力すると、送り仮名の自動処理においては送り仮名
がマッチしないので、候補が見つからずに辞書登録モードに入ります。

@example
@group
@kbd{W a t a s i t a @key{SPC}}

------ Buffer: foo ------
▼わたした
------ Buffer: foo ------

------ Minibuffer -------
わたした@point{}
------ Minibuffer -------
@end group
@end example

@noindent
辞書登録モードで @kbd{W a t a S i t a @key{RET}} と送り仮名を明示的に入
力し、@samp{渡した} と変換して登録したとします。この場合、登録する語の最
後が平仮名で終わるので、その最後の平仮名の文字列 (上記の例では、@samp{し
た}) が見出し語の最後と一致するかを調べます。一致する場合には、辞書の登
録を送りありエントリとして行なうのかどうかの確認を求めます。

@example
@group
@kbd{W a t a S i t a}
------ Minibuffer -------
わたした 渡した
------ Minibuffer -------
@end group
@group

@key{RET}

-------------------------- Echo Area --------------------------
Shall I register this as okuri-ari entry: わたs /渡/ ? (y or n)
-------------------------- Echo Area --------------------------
@end group
@end example

@noindent
この確認に対し、@samp{y} と回答した場合は、

@example
わたs /渡/[し/渡/]/
@end example

@noindent
という辞書エントリが個人辞書の送りありエントリに書き込まれます。一方
@samp{n} と回答した場合は、個人辞書の送りなしエントリに

@example
わたした /渡した/
@end example

@noindent
というエントリが書き込まれます。本例の場合は、@samp{y} と回答するのが正
解です。

@vtable @code
@item skk-kana-rom-vector
 
この変数は、送り仮名部分をローマ字プレフィックスに分解する際に、参照され
ます。その既定値は以下のようになっています。

@example
@group
["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
 "k" "g" "k" "g" "s" "z" "s" "j" "s" "z" "s" "z" "s" "z" "t" "d"
 "t" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
 "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
 "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
 "x" "w" "n"]
@end group
@end example

このベクトルは、それぞれ下記のかな文字をそのローマ字プレフィックスで現わ
したものです。

@example
@group
ぁ  あ  ぃ  い  ぅ  う  ぇ  え  ぉ  お  か  が  き  ぎ  く  ぐ
け  げ  こ  ご  さ  ざ  し  じ  す  ず  せ  ぜ  そ  ぞ  た  だ
ち  ぢ  っ  つ  づ  て  で  と  ど  な  に  ぬ  ね  の  は  ば
ぱ  ひ  び  ぴ  ふ  ぶ  ぷ  へ  べ  ぺ  ほ  ぼ  ぽ  ま  み  む
め  も  ゃ  や  ゅ  ゆ  ょ  よ  ら  り  る  れ  ろ  ゎ  わ  ゐ
ゑ  を  ん
@end group
@end example

@noindent
これに従うと、見出し語中の送り仮名がローマ字プレフィックスに分解される際、
例えば @samp{じ} は @samp{j} に、@samp{ち} は @samp{t} に、@samp{ふ} は
@samp{h} に、それぞれ分解されます。これらをそれぞれ @samp{z}、@samp{c}、
@samp{f} に変更することもできます。それには変数
@code{skk-kana-rom-vector} の該当部分を "z"、"c"、"f" に変更します。

@lisp
@group
(setq skk-rom-kana-vector
      ["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
       "k" "g" "k" "g" "s" "z" "s" "z" "s" "z" "s" "z" "s" "z" "t" "d"
       "c" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
       "p" "h" "b" "p" "f" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
       "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
       "x" "w" "n"])
@end group
@end lisp
@end vtable

次にもうひとつ例を挙げます。 @samp{ありがさつき} に対し @samp{有賀さつき}
を登録したい場合は、上記と同様に辞書登録をし、

@example
@group
Shall I register this as okuri-ari entry: ありがs /有賀/ ? (y or n)
@end group
@end example

@noindent
の確認に対し @samp{n} と回答します。この結果、個人辞書の送りなしエントリ
には、

@example
ありがさつき /有賀さつき/
@end example

@noindent
というエントリが書き込まれます。

@node 送りあり変換の変換開始のタイミング, カナモードでの変換の送り仮名の処理, 送り仮名の自動処理, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換の変換開始のタイミング
@kindex C-x C-j
@kindex C-x j

@vtable @code
@item skk-process-okuri-early
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-kakutei-early

この変数の値を 非 nil に設定すると、送りあり変換の変換開始のタイミングが
早められます。つまり、送り仮名のローマ字プレフィックスの入力時点で変換を
開始します。

@example
@group
@kbd{U g o K}

------ Buffer: foo ------
▼動k
------ Buffer: foo ------
@end group
@end example

送り仮名が分らないまま変換しているため、個人辞書が送り仮名に対応した形に
成長しません。つまり @samp{うごk /動/} のような形態のままとなります。た
だし、

@example
@group
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
@end group
@end example

@noindent
のようなエントリが既に個人辞書にある場合、それを破壊することはありません。
@footnote{@ref{辞書の形式}を参照してください。}。

このユーザーオプションを 非 nil に設定して SKK モードを起動すると、両立
できないオプションである下記オプションは自動的に nil に設定されます。

@example
@group
@code{skk-kakutei-early}, @c ここに footnote を持ってきても脚注が表われない...
@code{skk-auto-okuri-process}, @code{skk-henkan-okuri-strictly}
@end group
@end example

既に SKK モードに入った後で この変数の設定を変更した場合は、カレントバッ
ファで @kbd{C-x C-j} もしくは @kbd{C-x j} を 2 回タイプして SKK モードを
起動し直すことで、これらの変数間の衝突を調整します。またはメニューバーか
らこのユーザーオプションをオンにすると、自動的に上記の衝突を調整するよう
に設計されています。

@xref{暗黙の確定のタイミング, , skk-kakutei-early}.

@xref{送り仮名の自動処理, , skk-auto-okuri-process}.

@xref{送り仮名の厳密なマッチ, , skk-henkan-okuri-strictly}.
@end vtable

@node カナモードでの変換の送り仮名の処理,  , 送りあり変換の変換開始のタイミング, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection カナモードでの変換の送り仮名の処理
@vindex skk-convert-okurigana-into-katakana

カナモードのまま変換を行なうと、見出し語をひらがなに変換してから辞書の検
索を行います(@pxref{カタカナの見出し語})。このことは、カナモードで送りあ
り変換を行なうと、

@example
@group
------ Buffer: foo ------
考えル。
------ Buffer: foo ------
@end group
@end example

@noindent
のように、送り仮名の第 1 文字だけがひらがなのまま残ってしまうことを意味
します。そこで以下の変数が用意されています。

@vtable @code
@item skk-convert-okurigana-into-katakana

この変数の値を非 nil に設定すると、カナモードで送りあり変換を行なった場
合、送り仮名の第 1 文字もカタカナに変換します。
@end vtable

@node 自動変換開始, 特殊変換, 送り仮名関連, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 自動変換開始
@vindex skk-auto-okuri-process

▽モードで見出し語の入力中に、単語や文節の区切りとなるような文字を打鍵す
ると、▽マークからポイントの直前の文字までを見出し語とし
@footnote{最後に入力された文字は見出し語には含まれません。}、@key{SPC}
を打鍵することなく自動的に変換を開始し、▼モードに入るようになっています。
@footnote{某メーカーの MS-DOS 上の FEP の仕様を参考にしています。}。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@group

@kbd{w o}
------ Buffer: foo ------
▼漢字を
------ Buffer: foo ------
@end group
@end example

変数 @code{skk-auto-okuri-process} の値を非 nil に設定して 送り仮名の自
動処理(@pxref{送り仮名の自動処理})を行なっている場合は、以下のような変換
も可能です。ただし、辞書に @samp{できr /出来/[る/出来/]/} というようなエ
ントリがあると仮定します。

@example
@kbd{D e k i r u n n d e s u}

@group
------ Buffer: foo ------
▽できるんです
------ Buffer: foo ------
@end group
@group

@kbd{.}
------ Buffer: foo ------
▼出来るんです。
------ Buffer: foo ------
@end group
@end example

@vtable @code
@item skk-auto-start-henkan-keyword-list

この変数の値は、単語や文節の区切りとなるような文字列のリストです。
既定値は以下のようになっています。

@lisp
@group
("を" "、" "。" "．" "，" "？" "」" "！" "；" "：" ")" ";" 
 ":" "）" "”" "】" "』" "》" "〉" "｝" "］" "〕" "@}"
 "]" "?" "." "," "!" )
@end group
@end lisp

@item skk-auto-start-henkan

この変数の値を nil に設定すると、本節で説明した自動変換開始機能を無効に
します。
@end vtable

@node 特殊変換, 接頭辞・接尾辞, 自動変換開始, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 特殊変換

@menu
* 数値変換::                    数を含む文字列の変換。
* アスキー文字を見出し語とした変換::  アスキー文字を使った省略形からの変換。
* 今日の日付の入力::            今日の日付を一発入力。
* プログラム実行変換::          Emacs Lisp プログラムを使った変換。
@end menu

@node 数値変換, アスキー文字を見出し語とした変換, 特殊変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 数値変換
@cindex #0
@cindex #1
@cindex #2
@cindex #3
@cindex #4
@cindex #5
@cindex #9
@cindex 数をパラメータとする語の変換
@cindex 数値再変換

@samp{第１２回} というような表現において、数字の部分を @samp{#} で置きか
えてみると、@samp{第#回} となります。ここで、@samp{#} の部分にはあらゆる
整数が代入できます。のみならず、例えば @samp{第12回}、@samp{第一二回}、
@samp{第十二回} など、様々な形式があてはめられます。

そこで、@samp{#} をパラメータ (媒介変数) と考えて、@samp{第#回} という文
字列を操作する、というのが、SKK における数値変換の基本的な発想です。

辞書のエントリの例によって具体的に説明します。SKK の L 辞書には、次のよ
うなエントリがあります。

@example
だい#かい /第#1回/第#0回/第#2回/第 #0 回/第#3回/
@end example

@noindent
@samp{だい12かい} のような見出し語で変換しようとした場合、見出し語の数字
の部分は自動的に @samp{#} に置き換えられるようになっているので、上記の例
にマッチします。

次に上記の例の各候補の意味について説明します。いずれも @samp{#} の次に 1
桁の数字が続く部分があります。これは、これらが候補として出力される前に数
値変換によって加工されることを意味します。そして、0 から 9 の数字はその
候補にかけられる数値変換のタイプを表しています。

以下、数値変換の各タイプについて説明します。

@table @samp
@item #0

タイプ 0。無変換。入力されたアスキー文字をそのまま出力します。例えば、
@samp{第12回} のような変換を得るために使われます。

@item #1

タイプ 1。全角文字での数字。@samp{12} を @samp{１２}に変換します。

@item #2

タイプ 2。漢数字で位取りなし。@samp{5500} を @samp{五五〇〇} に変換しま
す。

@item #3

タイプ 3。漢数字で位取りあり。@samp{5500} を @samp{五千五百} に変換しま
す。

@item #4

タイプ 4。数値再変換。見出し語中の数字そのもの
@footnote{@samp{p125} という見出し語であれば、その数値部分である
@samp{125} が再変換の見出し語となります。}をキーとして辞書を再検索し、
@samp{#4} の部分を再検索の結果の文字列で入れ替えます。これについては後で
例を挙げて説明します。

@item #5

タイプ 5。小切手や手形の金額記入の際用いられる表記で変換します。例えば、
@samp{1995} を @samp{壱阡九百九拾伍} に変換します。

@item #9

タイプ 9。将棋の棋譜の入力用。@samp{全角数字 + 漢数字} に変換します。こ
れについては後で例を挙げて説明します。
@end table

以下にいくつか例を示します。辞書に

@example
# /#3/
@end example

@noindent
というエントリがあるときに、

@example
@group
@kbd{Q 1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}@footnote{または@kbd{/
1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}。}
@end group
@end example

@noindent
と入力すれば、@samp{百兆二千三億四十万五百}と変換されます
@footnote{数字を大文字で入力し始めることはできないので、@samp{Q} または
@samp{/} で▽モードに入る必要があります。}。

辞書に

@example
#m#d /#0月#0日/
@end example

@noindent
というエントリがあるときに、@kbd{/ 2 m 2 5 d @key{SPC}} と入力すれば、
@samp{2月25日}と変換されます
@footnote{@samp{m} や @samp{d} などアスキー文字を見出し語として入
力する場合は @samp{/} キーを最初に入力して SKK abbrev mode に入ってから
入力する必要があります。

@xref{アスキー文字を見出し語とした変換, , SKK abbrev mode}.}。

辞書に

@example
#kin /#9金/
@end example

@noindent
というエントリがあるときに、@kbd{/ 3 4 k i n @key{SPC}} と入力すれば、
@samp{３四金}と変換されます。

辞書に

@example
@group
p# /#4/
125 /東京都葛飾区/
@end group
@end example

@noindent
というエントリがあるときに、@kbd{/ p 1 2 5 @key{SPC}} と入力すれば、見出
し語 @samp{p125} の候補が @samp{#4} なので、見出し語の数字部分の
@samp{125} に対し辞書が再検索され、@samp{東京都葛飾区} と変換されます。

次に、辞書登録の例を 1 つ挙げます。@samp{２月２５日}を得るために、

@example
@kbd{Q 2 g a t u 2 5 n i t i @key{SPC}}
@end example

@noindent
と入力したときに、辞書に見出し語

@example
#がつ#にち
@end example

@noindent
がないときは、辞書登録時のプロンプトは、@w{@samp{#がつ#にち}}となります。
全角数字のタイプは、@samp{#1} なので、@samp{２月２５日}の全角数字部分を 
@samp{#1} で置き換えた文字列 @w{@samp{#1月#1日}} をミニバッファで作り登
録します。辞書には

@example
#がつ#にち /#1月#1日/
@end example

@noindent
というエントリが追加されます。

@vtable @code
@item skk-num-convert-float

この変数の値を非 nil に設定すると、浮動小数点数を使った見出し語に対応し
て数値変換を行ないます。ただし、辞書において

@example
#.# /#1．#1/#0月#0日/
@end example

などの見出し語が使用できなくなります。

@item skk-use-numeric-conversion

この変数を nil に設定すると、本節で説明した数値変換の機能を全て無効にし
ます。
@end vtable

@node アスキー文字を見出し語とした変換, 今日の日付の入力, 数値変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection アスキー文字を見出し語とした変換
@cindex SKK abbrev mode

@dfn{SKK abbrev mode}では、アスキー文字を見出し語とした変換を行なうこと
ができます。

まず、かなモードに入ります。@samp{/} を入力すると、見出し語入力の間だけ
一時的に SKK abbrev mode に入ります。続けて入力する文字は、アスキー文字
としてカレントバッファに挿入される。見出し語となるアスキー文字を入力し終っ
た時点で @key{SPC} を押すと、その見出し語についての変換が得られます。

仮に、

@example
is /インクリメンタル・サーチ/
@end example

@noindent
というようなエントリが辞書にあるとして、例を示します。

@example
@kbd{/}

@group
------ Buffer: foo ------
▽
------ Buffer: foo ------
@end group

@kbd{is}

@group
------ Buffer: foo ------
▽is
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼インクリメンタル・サーチ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
インクリメンタル・サーチ
------ Buffer: foo ------
@end group
@end example

@noindent
入力したアスキー文字をそのまま全角アルファベットに変換する方法については、

@xref{全英文字の一時的入力,, 全角アルファベットへの変換}.

@noindent
を参照してください。

なお、SKK abbrev mode においても見出し語の補完を行なうことができます。

@ref{見出し語の補完}.

@node 今日の日付の入力, プログラム実行変換, アスキー文字を見出し語とした変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 今日の日付の入力
@kindex @@
@cindex プログラム実行変換

かな/カナモードで @kbd{@@} を入力すれば、今日の日付が入力されます。

日付の形式は以下の変数により決定されます。

@vtable @code
@item skk-date-ad

この変数の値が非 nil であれば西暦で、nil であれば元号で表示します。既定
値は nil です。

@item skk-number-style

この変数の値は以下のように解釈されます。

@table @code
@item 0
@itemx nil

半角数字。@samp{1996年7月21日(日)} のようになります。

@item 1
@itemx t

全角数字。@samp{１９９６年７月２１日(日)} のようになります1。

@item 2

漢数字。@samp{一九九六年七月二一日(日)} のようになります。
@end table

上記の @samp{1996年}、@samp{１９９６年}、@samp{一九九六年} の部分は、変
数 @code{skk-date-ad} の値が nil であれば @samp{平成8年} のように元号で
表示されます。 @code{skk-number-style} の既定値は、@samp{1} です。
@end vtable

L 辞書
@footnote{@xref{辞書の形式, , L辞書}.}には、見出し語 @samp{today} の
候補として、@code{skk-date-ad} と @code{skk-number-style} の全ての組合わ
せがプログラム実行変換機能
@footnote{@ref{プログラム実行変換}.}を用いて登録されています。従って、
@kbd{/ t o d a y @key{SPC}} と入力すると、今日の日付が上記の形式で順次候
補として表示されます。

@kbd{@@} によって日付けを挿入するのではなく、文字通り @kbd{@@} を挿入し
たい場合には、

@lisp
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("@@" nil "@@"))))
@end lisp

@noindent
のようにします。全角文字の @samp{＠} を挿入したい場合は、

@lisp
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("@@" nil "＠"))))
@end lisp

@noindent
のようにします。

@node プログラム実行変換,  , 今日の日付の入力, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection プログラム実行変換
@cindex @file{skk-gadget.el}
@findex skk-calc

辞書の候補に Emacs Lisp のプログラムが書いてあれば、そのプログラムを
Emacs に実行させ、返り値をカレントバッファに挿入します。これを @b{「プロ
グラム実行変換」}と読んでいます。例えば、辞書に

@example
now /(current-time-string)/
@end example

@noindent
というエントリがあるとします。このとき @kbd{/ n o w @key{SPC}} と入力す
れば、現在のバッファに @code{current-time-string} の返り値である 

@example
Sun Jul 21 06:40:34 1996
@end example

@noindent
のような文字列が挿入されます。

ここで、プログラムの返り値は文字列である必要があります。また、プログラム
実行変換の辞書登録は通常の単語と同様に行なうことができますが、その中に改
行を含まないように書く必要があります
@footnote{通常の単語では、改行を含むことが可能です。それは、評価するとそ
の位置に改行を挿入するような実行変換プログラムに変換して辞書に書き込んで
いるからなのです。

@pxref{辞書の形式}.

しかし、実行変換されるプログラムを辞書登録する際にはこの機能を利用できな
いため、改行を含むことができません。}。

今日の日付の入力
@footnote{@ref{今日の日付の入力}.} で説明した @samp{today} の辞書エント
リは、実際は下記のようなプログラムを候補にもっています。

@lisp
@group
today /(let ((skk-date-ad) (skk-number-style t)) (skk-today))/@dots{}/
@end group
@end lisp

@file{skk-gadget.el}
@footnote{@samp{gadget}は「上手く工夫した道具」の意味。「色々飛び出す気
のきいたおもちゃ箱」というような意味で名付けられています。
因みに、X Windowで使用される @samp{Widget} という言葉は、 @samp{window}
+ @samp{gadget} から作られた造語のようです。}には、西暦/元号変換プログラ
ムや、簡単な計算プログラムなど、実行変換用のプログラムが集められています。
ここではその中の 1 つを取り上げて説明します。

下記は、引数を 1 つ取り、見出し語の数字に対しその演算を行なう簡単な計算
プログラムです。

@lisp
@group
(defun skk-calc (operator)
  ;;@r{2つの引数を取って operator の計算をする。}
  ;;@r{注意: '/ は引数として渡せないので (defalias 'div '/) などとし、別の形で}
  ;;@r{skk-calc に渡す。}
  ;;@r{辞書見出し例; #*# /(skk-calc '*)/}
  (number-to-string (apply operator (mapcar 'string-to-number skk-num-list))))
@end group
@end lisp

この関数を実際にプログラム実行変換で利用するには、辞書に以下のようなエン
トリを追加します
@footnote{@ref{数値変換}.}。

@example
#*# /(skk-calc '*)/
@end example

@noindent
@kbd{Q 1 1 0 * 4 5 @key{SPC}} と入力します。ここで、@samp{111} と
@samp{45} の 2 つの数字は、変換時に @w{@code{("111" "45")}} のような文字
列のリストにまとめられ、変数 @code{skk-num-list} の値として保存されます。
次に関数 @code{skk-calc} が呼ばれます。この中で、@code{skk-num-list} の
各要素に対し演算を行うため、各要素は数に変換されます。その上で、
@code{skk-calc} に与えられた引数 (この場合は @samp{*}) を演算子として演
算を行います。

@node 接頭辞・接尾辞, 暗黙の確定のタイミング, 特殊変換, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 接頭辞・接尾辞
@cindex 接頭辞
@cindex 接尾辞

接頭辞 (prefix)、接尾辞 (suffix)の入力のために特別な方法が用意されていま
す。

辞書の見出し語の一部に @samp{>}, @samp{<}, @samp{?} を用いている場合があ
ります。例えば

@example
>し /氏/
@end example

@noindent
というエントリがあるとき、@samp{小林氏}を接尾辞入力を用いて、以下のよう
に入力することができます。

@example
@kbd{K o b a y a s h i}

@group
------ Buffer: foo ------
▽こばやし@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼小林@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
小林▽>@point{}
------ Buffer: foo ------
@end group

@kbd{s i}

@group
------ Buffer: foo ------
小林▽>し@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
小林▼氏@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
小林氏@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
このように入力することで、見出し語 @samp{し} に対応する語でも接尾辞にな
り得ないものは候補に現れないので、変換効率がよくなります。

また、辞書に

@example
ちょう> /超/
@end example

@noindent
というエントリがあるとき、@samp{超大型} を接頭辞入力を用いて、以下のよう
に入力することができます。

@example
@kbd{T y o u}

@group
------ Buffer: foo ------
▽ちょう@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
▼超@point{}
------ Buffer: foo ------
@end group

@kbd{O o g a t a}

@group
------ Buffer: foo ------
超▽おおがた@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
超▼大型@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
超大型@point{}
------ Buffer: foo ------
@end group
@end example

@vtable @code
@item skk-special-midashi-char-list

▽モードまたは▼モードにおいて、この変数の値に含まれる文字の入力があった
場合、接頭辞・接尾辞の入力を開始します。この変数の既定値は、

@lisp
(?> ?< ??)
@end lisp

です。@samp{?} を入力したときに接頭辞・接尾辞入力を行わない場合は
@samp{?} を外して

@lisp
@group
(setq skk-special-midashi-char-list '(?> ?<))
@end group
@end lisp

とします。
@end vtable

@node 暗黙の確定のタイミング, 領域一括変換, 接頭辞・接尾辞, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 暗黙の確定のタイミング
@cindex 暗黙の確定
@vindex skk-process-okuri-early

標準の設定では、▼モードにおいて印字可能な文字または @key{RET} が入力さ
れると、暗黙の確定が行なわれ直ちに確定されます。具体的には以下のようにな
ります。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
確定s
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
確定す
------ Buffer: foo ------
@end group
@end example

@vtable @code
@item skk-kakutei-early

この変数の値を非 nil にすると、暗黙の確定が行なわれるタイミングが変化し
ます。具体的には、括弧 (@samp{(}, @samp{)}, @samp{[}, @samp{]}) または句
読点 (@samp{,}, @samp{.}) の入力時、次の変換開始 (@samp{A}から@samp{Z}ま
での大文字の入力) 時、あるいは @key{RET} 入力時まで暗黙の確定が遅延され
ます。
@footnote{@code{skk-kakutei-early} の機能と
@code{skk-process-okuri-early} の機能を同時に有効にすることはできません。
@code{skk-kakutei-early} の 値を非 nil にする場合は
@code{skk-process-okuri-early} の値を nil にする必要があります。メニュー
バーからこのユーザーオプションをオンにしたときは、これらのユーザーオプショ
ン間の衝突は自動的に調整されます。}

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
▼確定s
------ Buffer: foo ------
@end group

@kbd{u r u}

@group
------ Buffer: foo ------
▼確定する
------ Buffer: foo ------
@end group

@kbd{.}

@group
------ Buffer: foo ------
確定する。
------ Buffer: foo ------
@end group
@end example
@end vtable

@node 領域一括変換, 漢字コード関連, 暗黙の確定のタイミング, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 領域一括変換
@cindex Menu Bars
@cindex メニューバー
@cindex 逆引き

以下のコマンドを @kbd{M-x} により呼ぶことで領域一括変換を行なうことがで
きます
@footnote{メニューバーが使用できる環境では、メニューバーを使ってこれらの一括変換コマ
ンドを呼び出すことができます。

@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.}。

@table @asis
@item @kbd{M-x skk-hiragana-region}
@kindex M-x skk-hiragana-region
@findex skk-hiragana-region

カタカナをひらがなへ変換。

@item @kbd{M-x skk-katakana-region}
@kindex M-x skk-katakana-region
@findex skk-katakana-region

ひらがなをカタカナへ変換。

@item @kbd{M-x skk-ascii-region}
@kindex M-x skk-ascii-region
@findex skk-ascii-region

全英文字をアスキー文字へ変換。

@item @kbd{M-x skk-zenkaku-region}
@kindex M-x skk-zenkaku-region
@findex skk-zenkaku-region

アスキー文字を全英文字へ変換。
@end table

以下に紹介するコマンドについては、外部プログラム KAKASI に依存しています。
KAKASI がインストールされていなければ使用することができません。

@ref{KAKASI}.

@table @asis
@item @kbd{M-x skk-gyakubiki-region}
@kindex M-x skk-gyakubiki-region
@findex skk-gyakubiki-region

漢字をひらがなへ変換。具体的な変換例をあげると、

@example
``漢字をひらがなへ変換。''@expansion{}``かんじをひらがなへへんかん。''
@end example

@noindent
のようになります。引数を渡して、

@kbd{C-u M-x skk-gyakubiki-region}

のようにすると、複数の候補がある場合に、`@{@}' で囲って表示します。例え
ば

@example
``中島''@expansion{}``@{なかしま|なかじま@}''
@end example

@noindent
のようになります。

送り仮名がある語は、送り仮名まで含めて領域に指定します (さもないと誤変換
の原因となります)。 例えば、@samp{五月蝿い} について、送り仮名 @samp{い}
を含めずにこのコマンドを実行すると、@samp{ごがつはえ} に変換されてしまい
ます。

@item @kbd{M-x skk-gyakubiki-katakana-region}
@kindex M-x skk-gyakubiki-katakana-region
@findex skk-gyakubiki-katakana-region

漢字をカタカナへ変換。

引数を渡して、@kbd{C-u M-x skk-gyakubiki-katakana-region} のようにすると、
複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-hurigana-region}
@kindex M-x skk-hurigana-region
@findex skk-hurigana-region

漢字にふりがなを付ける。例えば、

@example
``漢字の脇に''@expansion{}``漢字[かんじ]の脇[わき]に''
@end example

@noindent
のようになります。引数を渡して @kbd{C-u M-x skk-hurigana-region} のよう
にすると、複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-hurigana-katakana-region}
@kindex M-x skk-hurigana-katakana-region
@findex skk-hurigana-katakana-region

漢字にカタカナのふりがなを付ける。

引数を渡して、@kbd{C-u M-x skk-hurigana-katakana-region}のようにすると、
複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-romaji-region}
@kindex M-x skk-hurigana-region
@findex skk-romaji-region
@vindex skk-romaji-*-by-hepburn

漢字、ひらがな、カタカナ、全英文字を全てローマ字へ変換。標準では、ローマ
字への変換様式にヘボン式です。例えば、

@example
``し''@expansion{}``shi''
@end example

@noindent
となります。変数 @code{skk-romaji-*-by-hepburn} の値を nil に設定すると、
訓令式を用います。例えば、

@example
``し''@expansion{}``si''
@end example

@noindent
のようになります
@footnote{昭和 29 年 12 月 9 日付内閣告示第一号によれば、原則的に訓令式
(日本式) を用いるかのように記載されていますが、今日一般的な記載方法は、
むしろヘボン式であるようです。}。
@end table

以下のコマンドは、領域の文字列を置き換えるの代わりに、変換結果をエコーエ
リアに表示します。

@itemize @bullet
@item @kbd{M-x skk-gyakubiki-message}
@kindex M-x skk-gyakubiki-message
@findex skk-gyakubiki-message
@item @kbd{M-x skk-gyakubiki-katakana-message}
@kindex M-x skk-gyakubiki-katakana-message
@findex skk-gyakubiki-katakana-message
@item @kbd{M-x skk-hurigana-message}
@kindex M-x skk-hurigana-message
@findex skk-hurigana-message
@item @kbd{M-x skk-hurigana-katakana-message}
@kindex M-x skk-hurigana-katakana-message
@findex skk-hurigana-katakana-message
@item @kbd{M-x skk-romaji-message}
@kindex M-x skk-romaji-message
@findex skk-romaji-message
@end itemize

@node 漢字コード関連, ▼モードの特殊キー, 領域一括変換, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 漢字コード関連

@menu
* 漢字コードまたはメニューによる文字入力::  
* 漢字コードを知る方法::        
@end menu

@node 漢字コードまたはメニューによる文字入力, 漢字コードを知る方法, 漢字コード関連, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードまたはメニューによる文字入力
@cindex JISコード
@cindex EUCコード
@kindex @samp{\}

まずかなモードに入ります。@samp{\} キーを入力すると、漢字コード (JIS ま
たは EUC コード) またはメニューによる文字入力が行われます。ミニバッファ
には、

@example
@group
JIS or EUC code (00nn or CR for Jump Menu): 
@end group
@end example

@noindent
というプロンプトが表示されます。

ここで、漢字コードがあらかじめ分かっている場合には、その漢字コードを入力
します。例えば @samp{℃} の漢字コードは、JIS コードでは @samp{216e}、EUC
コードでは @samp{a1ee} なので、いずれかの漢字コードを入力すれば @samp{℃}
が現在のバッファに挿入されます。

漢字コードが不明の文字の入力をする場合は、漢字コードを入力せずにそのまま
@key{RET} キーを入力します。すると以下のような表示が現れます。

@example
@group
A:　  S:￣  D:〜  F:｝  G:＝  H:¢  Q:◆  W:  E:∩  R:  T:≡  Y:  
@end group
@end example

これを第 1 段階のメニューと呼びます。第 1 段階のメニューでは、JIS 漢字を
コードの順に 16 文字毎に 1 文字抽出し、ミニバッファに一度に 12 文字づつ
表示しています
@footnote{上記の例では、JISコード 2121 (全角スペース)、2131、2141、2151、
@dots{} の文字がそれぞれ表示されています。}。ここで @key{SPC} を入力する
と、次の候補群を表示します
@footnote{漢字コードの値を@w{16x12 @equiv{}192}づつ増やします。}。
@samp{x} により 1 つ前の候補群に戻ります。

キー @samp{a}, @samp{s}, @samp{d}, @samp{f}, @samp{g}, @samp{h},
@samp{q}, @samp{w}, @samp{e}, @samp{r}, @samp{t}, @samp{y} のいずれかを
入力すると
@footnote{大文字でも小文字でも構いません。なお、第 1 段階・第 2 段階とも
に、メニューのキーは変更することができます。これについては、

@ref{候補の選択に用いるキー}

@noindent
を参照してください。}、そのキーに対応する文字から始まる 16 個の文字が漢
字コード順に表示されます。これを第 2 段階のメニューと呼びます。例えば、
第 1 段階のメニューが上記の状態のときに @samp{d} を入力すると 第 2 段階
のメニューは以下のようになります。

@smallexample
@group
A:〜 S:‖ D:｜ F:… G:‥ H:‘ J:’ K:“ L:” Q:（ W:） E:〔 R:〕 T:［ Y:］ U:｛ 
@end group
@end smallexample

ここでタイプすると、キー @samp{a}, @samp{s}, @samp{d}, @samp{f}, @samp{g}, @samp{h},
@samp{q}, @samp{w}, @samp{e}, @samp{r}, @samp{t}, @samp{y} のいずれかを
入力すると、対応する文字がカレントバッファに挿入されてメニューによる入力
が終了します。

第 2 段階のメニューが表示されているときも @key{SPC} と @samp{x} キーによ
り第 2 段階のメニューが前進、後退します。

また @samp{<}、@samp{>} によりメニューを 1 文字分だけ移動します。例えば、
第 2 段階のメニューが上記の状態のときに@samp{<} を入力すると、メニューは
以下のようになります。

@smallexample
@group
A:＼ S:〜 D:‖ F:｜ G:… H:‥ J:‘ K:’ L:“ Q:” W:（ E:） R:〔 T:〕 Y:［ U:］
@end group
@end smallexample

第 1 段階あるいは第 2 段階のメニューが表示されているときに @samp{?} を入
力すると、そのときのキー @samp{A} に対応する文字 (上記の例では、@samp{＼})
の文字コードが表示されます。

@node 漢字コードを知る方法,  , 漢字コードまたはメニューによる文字入力, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードを知る方法
@kindex @samp{$}
@cindex JISコード
@cindex EUCコード

かな/カナモードで @samp{$}を入力すると、現在位置の直後にある文字の漢字コー
ドをミニバッファに表示します。例えば、カーソルを文字 @samp{А} の上に置
いて @samp{$}を入力すると、

@example
『А』  EUC: a7a1 (167, 161), JIS: 2721 ( 39,  33)
@end example

@noindent
がエコーエリアに表示され、この文字がロシア文字であることがわかります。

@node ▼モードの特殊キー, 辞書関連, 漢字コード関連, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section ▼モードの特殊キー

@menu
* 確定動作を行なうキー::        
* 候補の選択に用いるキー::      
* ▼モードでのRET::             
* ▼モードでのBS::              
* 送りあり変換中のC-g::         
@end menu

@node 確定動作を行なうキー, 候補の選択に用いるキー, ▼モードの特殊キー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 確定動作を行なうキー
@kindex C-j

@vtable @code
@item skk-kakutei-key

この変数の値は、明示的な確定動作を行うキーを指定します。標準設定では
@kbd{\C-j} となっています。
@end vtable

@node 候補の選択に用いるキー, ▼モードでのRET, 確定動作を行なうキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 候補の選択に用いるキー

変換において、候補が 5 つ以上あるときは、 5 番目以降の候補は 7 つずつま
とめてエコーエリアに下記のように表示されます
@footnote{@ref{▼モード}.}。

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

この際、候補の選択に用いるキーは、次の変数によって決定されます。

@vtable @code
@item skk-henkan-show-candidates-keys

7 つの異なる文字のリスト。文字は必ず小文字とする
@footnote{@samp{x}, @key{SPC} および @kbd{C-g} は、それぞれ候補選択中に
おける前候補群の表示、次候補群の表示、取り止めのために割り付けられている
ので、@code{skk-henkan-show-candidates-keys} の中に含めてはいけません。}。
既定値は、以下の通り。

@lisp
(?a ?s ?d ?f ?j ?k ?l)
@end lisp
@end vtable

メニューによる文字入力
@footnote{@ref{漢字コードまたはメニューによる文字入力}.}の際に候補の選択
に用いられるキーは、下記の 2 変数により変更されます。

@vtable @code
@item skk-input-by-code-menu-keys1

第 1 段階のメニューにおける候補の選択キー。既定値は、

@lisp
(?a ?s ?d ?f ?g ?h ?q ?w ?e ?r ?t ?y)
@end lisp

です。このリストには 12 個の異なる文字を含む必要があります。

@item skk-input-by-code-menu-keys2

第 2 段階のメニューにおける候補の選択キー。既定値は、

@lisp
(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u)
@end lisp

です。このリストには 16 個の異なる文字を含む必要があります。
@end vtable

上記 2 変数のすべての要素を、全て小文字で指定することを強くお勧めします
@footnote{小文字が指定された場合は、候補の選択の際に対応する大文字キーが
入力されても候補の選択が可能となるように設計されています。その一方で、大
文字が指定された場合、候補の選択の際に対応する小文字キーが入力されても候
補の選択ができません。これは現在の仕様です。}。

@node ▼モードでのRET, ▼モードでのBS, 候補の選択に用いるキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{RET}

標準設定では、

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定
@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
のように、▼モードで @key{RET} を入力すると、確定し、かつ改行を行います。
この挙動を変えるためのユーザーオプションが用意されています。

@vtable @code
@item skk-egg-like-newline

この変数の値を非 nil にすると、▼モードで @key{RET} を入力したときに確定
のみ行い、改行はしません
@footnote{従って、辞書登録モードにおいて▼モードであるときの @key{RET}
入力時の挙動も変化します。標準の確定、登録の動作については、

@ref{辞書登録モード}

@noindent
を参照してください。}。

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定@point{}
------ Buffer: foo ------
@end group
@end example
@end vtable

@node ▼モードでのBS, 送りあり変換中のC-g, ▼モードでのRET, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{BS}
@kindex @key{BS}

標準設定では、▼モードで @key{BS} を押すと、前の一文字を削除した上で確定
します。

@example
@kbd{D e n k i y a @key{SPC}}

@group
------ Buffer: foo ------
▼電気屋
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
電気
------ Buffer: foo ------
@end group
@end example

@vtable @code
@item skk-delete-implies-kakutei

この変数の値を非 nil に設定すると、▼モードで @key{BS} を押した時に一つ
前の候補を表示します。例えば、

@example
でんき /電気/伝記/
@end example

@noindent
という辞書エントリがあるとき、以下のようになります。

@example
@kbd{D e n k i @key{SPC}@key{SPC}}

@group
------ Buffer: foo ------
▼伝記
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▼電気
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▽でんき
------ Buffer: foo ------
@end group
@end example
@end vtable

@node 送りあり変換中のC-g,  , ▼モードでのBS, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換中の@kbd{C-g}
@kindex C-g

送りありの変換中に @kbd{C-g} を入力すると、▼モードを抜け、その見出し語
と送り仮名を現在のバッファに挿入し、■モードに入ります。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
なく
------ Buffer: foo ------
@end group
@end example

@vtable @code
@item skk-delete-okuri-when-quit

この変数の値を非 nil に設定すると、送りありの変換中に @kbd{C-g} を入力し
たときの挙動が変化します。具体的には、送り仮名を消し、▽モードになります
@footnote{送り仮名の入力間違いを修正するのには便利です。}。例えば、以下
のようになります。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
▽な
------ Buffer: foo ------
@end group
@end example
@end vtable

@node 辞書関連, 飾りつけ, ▼モードの特殊キー, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 辞書関連

@menu
* 個人辞書中の単語の削除::      
* 個人辞書の保存動作::          
* 変換及び個人辞書に関する統計::  
* 辞書候補数の数えあげ::        
* 辞書バッファの文字コードの設定::  
* 辞書バッファのメジャーモード::  
* 辞書バッファのbuffer-file-name::  
@end menu

@node 個人辞書中の単語の削除, 個人辞書の保存動作, 辞書関連, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書中の単語の削除
@cindex 個人辞書エントリの削除
@cindex 誤登録

誤って個人辞書
@footnote{@xref{辞書の形式, 個人辞書}.}に登録した単語を削除する機能があ
ります。

削除したい単語を変換により求め、その単語が得られた時点で @samp{X} を入力
します。ミニバッファに確認が出るので、それに対し @kbd{y e s}と答えます。
すると、個人辞書の対応するエントリが削除されます。現在のバッファに先程入
力した誤りの変換結果も削除されます。

@example
さいきてき /再起的/
@end example

@noindent
というエントリを誤って登録したという仮定で、その誤登録を削除する場合を例
にとって説明します。

@example
@kbd{S a i k i t e k i @key{SPC}}

@group
------ Buffer: foo ------
▼再起的
------ Buffer: foo ------
@end group

@samp{X}

@group
------------------ MiniBuffer ------------------
Really purge ``さいきてき /再起的/''?(yes or no)
------------------ MiniBuffer ------------------
@end group

@kbd{y e s @key{RET}}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group

@end example

@node 個人辞書の保存動作, 変換及び個人辞書に関する統計, 個人辞書中の単語の削除, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書の保存動作
@cindex 個人辞書
@cindex 個人辞書のオートセーブ
@kindex C-x C-c

個人辞書の保存動作について説明します。

個人辞書の保存が行われる場合として、次の 3 通りがあります。

@enumerate
@item
@kbd{C-x C-c} (または @kbd{M-x save-buffers-kill-emacs}) により Emacs を
終了させようとした場合。

@item
@kbd{M-x skk-save-jisyo} と入力するか、メニューバーより @samp{Save
Jisyo} を選択した場合。

@item
変数 @code{skk-jisyo-save-count} で指定された回数辞書の更新を行なった結
果として、自動保存 (オートセーブ) 機能が働くとき。
@end enumerate

保存動作を分析して考えます。まず、 Emacs に読み込んだ個人辞書が更新され
ているかどうかを調べます。更新されていたら保存動作に入ります。Emacs の個
人辞書バッファを一時ファイルに保存して、そのファイルサイズが現存の (セー
ブ前の) 個人辞書より小さくないかどうかをチェックします。個人辞書より小さ
いときは、保存動作を継続するかどうか、確認のための質問がされます。
@footnote{通常の使用の範囲では@kbd{M-x skk-purge-from-jisyo}した場合、あ
るいは個人辞書をユーザーが意図的に編集した場合、複数の Emacs で SKK を使
用した場合などに、個人辞書が小さくなることがあります。他の場合はバグの可
能性があります。}

@example
@group

--------------------------- Minibuffer -----------------------------
New ~/.skk-jisyo will be 11bytes smaller.  Save anyway?(yes or no)
--------------------------- Minibuffer -----------------------------

@end group
@end example

@noindent
ここで @kbd{n o @key{RET}} と答えた場合は、そこで保存動作が中止され、個
人辞書は以前の状態のままになります。@kbd{y e s @key{RET}} と答えた場合は
元の個人辞書を退避用の辞書に退避し、一時ファイルに保存した新しい個人辞書
を @code{skk-jisyo} に保存します。

もし、一時ファイルのサイズが 0 である場合は、なんらかの異常と考えられる
ので、保存動作は直ちに中止されます。その場合は

@lisp
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end lisp

@noindent
で Emacsを終了させ、個人辞書 (@code{skk-jisyo})、および個人辞書の退避用
辞書 (@code{skk-backup-jisyo}) をチェックするよう強くお勧めします
@footnote{@code{skk-jisyo} が既に壊れていても、@code{skk-backup-jisyo}
にそれ以前の個人辞書が残っている可能性があります}。

@vtable @code
@item skk-compare-jisyo-size-when-saving

この変数の値を nil に設定すると、一時ファイルが 0 でないかどうかのチェッ
クは行いまずか、保存前の個人辞書とのサイズ比較は行ないません。

@item skk-jisyo-save-count

この変数で指定された回数、個人辞書の更新を行なった場合に個人辞書の自動保
存が行なわれます。既定値は 50 です。また、この値を nil にすると、個人辞
書の自動保存機能が無効になります。

ここで、個人辞書の更新回数は確定回数と一致します。また、同じ候補について
確定した場合でもそれぞれ 1 回と数えられます。
@footnote{これは、個人辞書の最小ポイントに、常に最後に変換を行なったエン
トリを移動させるために、エントリ数、候補数が全く増えていなくとも、確定に
より個人辞書が更新されているからです。}
@end vtable

@node 変換及び個人辞書に関する統計, 辞書候補数の数えあげ, 個人辞書の保存動作, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 変換及び個人辞書に関する統計

SKK では、Emacs の終了時に変換及び個人辞書に関する統計を取っています。そ
の結果は ファイル @file{~/.skk-record} に保存されます。保存される内容は
以下のような形式です。

@example
@group
Sun Jul 28 09:38:59 1996  登録:   4  確定:  285  確定率:  98%  語数:  3042
@end group
@end example

上記の「語数」の欄は 1 行を 1 語として数えているので、1 つの見出し語に対
し複数の候補を持っている場合、2 つ目以降の候補を無視しています。

@vtable @code
@item skk-record-file

統計の結果を保存するファイル名を指定します。

@item skk-keep-record

この変数の値を nil に設定すると、本節で説明した統計機能を無効にします。

@item skk-count-private-jisyo-candidates-exactly

この変数の値を非 nil に設定すると、「語数」の数え方を変更します。具体的
には、 1 行を 1 語として数えるのではなく、正確に語数を数えます。なお、そ
の分時間がかかります。また、この場合でも @samp{[} と @samp{]} に囲まれた
送り仮名毎のブロック形式内は数えません。
@end vtable

@node 辞書候補数の数えあげ, 辞書バッファの文字コードの設定, 変換及び個人辞書に関する統計, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書候補数の数えあげ
@cindex Menu Bars
@cindex メニューバー
@findex skk-count-jisyo-candidates
@kindex M-x skk-count-jisyo-candidates

コマンド @kbd{M-x skk-count-jisyo-candidates} を使うと、辞書の候補数を数
えることができます。

@example
@group

@kbd{M-x skk-count-jisyo-candidates}

--------------- MiniBuffer --------------
File: (default: /your/home/.skk-jisyo) ~/
--------------- MiniBuffer --------------
@end group
@group

@kbd{. s k k - j i s y o @key{RET}}

-------------- Echo Area --------------
Counting jisyo candidates... 100% done
-------------- Echo Area --------------
@end group

@group

------ Echo Area ------ 
3530 entries
------ Echo Area ------
@end group
@end example

ただし、@samp{[}と@samp{]}に囲まれた送り仮名毎のブロック形式内は数えませ
ん。

また、メニューバーが使用できる環境では、メニューバーを使ってこのコマンド
を呼び出すことができます。

@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.

@node 辞書バッファの文字コードの設定, 辞書バッファのメジャーモード, 辞書候補数の数えあげ, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの文字コードの設定

@vtable @code
@item skk-jisyo-code

この変数の値は辞書ファイルの漢字コードを決定します。

この変数は以下のような値を取ります。
@footnote{Mule 2.3 では @w{@code{*euc-japan*}}, @w{@code{*sjis*}},
@w{@code{*junet*}} などのシンボルを指定することができます。
Emacs 20 では、@code{euc-jp}, @code{shift_jis}, @code{junet} などのシン
ボルを指定することができます。}

@itemize @bullet
@item @w{``euc''}, @w{``ujis''}, @w{``sjis''}, @w{``jis''} などの文字列
@item Emacs によって coding system と認められるシンボル
@item Emacs によって coding system を示すのに使われるシンボル
@item nil
@end itemize

既定値は nil です。この場合、SKK側で辞書の漢字コードを設定することはせず、
Emacs に任せます。
@end vtable

@node 辞書バッファのメジャーモード, 辞書バッファのbuffer-file-name, 辞書バッファの文字コードの設定, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファのメジャーモード
@cindex @file{dabbrev.el}
@cindex @samp{ *SKK-JISYO.L*}
@findex fundamental-mode
@vindex major-mode
@vindex mode-name
@vindex skk-large-jisyo
@cindex 辞書バッファの名付け規則

辞書検索プログラムを実行すると、必要ならば辞書が Emacs のバッファに読み
込まれます。このバッファを辞書バッファと呼びます。

辞書バッファの名前は、

「空白+@samp{*}+辞書ファイル名(ディレクトリ抜き)+@samp{*}」

という規則に基づいて付けられます。例えば、変数 @code{skk-large-jisyo} の
値が

@w{@file{/usr/local/share/skk/SKK-JISYO.L}}

であるとき、これに対する辞書バッファ名は、

@w{@samp{ *SKK-JISYO.L*}}

となります。

このバッファのメジャーモードは @code{fundamental-mode} です。しかし、諸
般の事情により、変数 @code{major-mode} の値をシンボル @w{skk-jisyo-mode}、
変数 @code{mode-name} の値を文字列 @samp{SKK dic} としています。
@footnote{これは、Emacs の @file{dabbrev.el} の機能との調和を考えての措
置です。
Dabbrev においては、現在のバッファと同じモードの他のバッファを検索して
abbreviation の展開を行なうように設定することができるのですが、仮に辞書
バッファにおける変数 @code{major-mode} の値が @w{fundamental-mode} のま
まだとすると、 Dabbrev が辞書バッファを検索してしまう可能性があります。
この措置によって、そのような事態を回避しています。}

@node 辞書バッファのbuffer-file-name,  , 辞書バッファのメジャーモード, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの@code{buffer-file-name}
@vindex buffer-file-name
@findex save-some-buffers

Emacs には @code{save-some-buffers} という関数があります。この関数は、ファ
イルに関連付けられている各バッファについて、変更があればファイルに保存し
ますが、実際に保存するかどうかを使用者に質問します。

Emacs のコマンドには @kbd{M-x compile} のように、
@code{save-some-buffers} を呼び出すものがあります。もし、個人辞書の辞書
バッファがファイル名と関連付けられていたとしたら、こうしたコマンドを
実行するたびに個人辞書を保存するかどうか質問されるので、面倒です。

SKK では、このような事態を避けるため、辞書バッファにおける変数
@code{buffer-file-name} の値を nil に設定しています。

@node 飾りつけ, VIP/VIPERとの併用, 辞書関連, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section 飾りつけ

@menu
* 仮名文字のローマ字プレフィックスのエコー::  
* 入力モードを示すモードラインの文字列の変更::  
* 入力モードを示すカーソル色に関する設定::  
* ▼モードにおける変換候補のハイライト表示::  
* エラーなどの日本語表示::      
@end menu

@node 仮名文字のローマ字プレフィックスのエコー, 入力モードを示すモードラインの文字列の変更, 飾りつけ, 飾りつけ
@comment  node-name,  next,  previous,  up
@subsection 仮名文字のローマ字プレフィックスのエコー

@vtable @code
@item skk-echo

この変数の値は、仮名文字のローマ字プレフィックス
@footnote{@xref{辞書の形式, ローマ字プレフィックス}.}
のエコーの有無を制御します。
@end vtable

変数 @code{skk-code} の値が 非 nil であれば、仮名文字のローマ字プレフィッ
クスが、入力時点で一旦現在のバッファに挿入され、続く母音の入力の際に、か
な文字に変換された時点で現在のバッファから消去されます。

@example
@group
@kbd{t}

------ Buffer: foo ------
t
------ Buffer: foo ------

@end group
@group
@kbd{a}

------ Buffer: foo ------
た
------ Buffer: foo ------
@end group
@end example

変数 @code{skk-echo} の値が nil であれば、仮名文字のローマ字プレフィック
スのエコーは行なわれません。これを上記の例で考えると、@samp{t} が現在の
バッファに挿入されず、続く母音 (@samp{a}) が入力されたとき @samp{た} の
文字が挿入されます。

@node 入力モードを示すモードラインの文字列の変更, 入力モードを示すカーソル色に関する設定, 仮名文字のローマ字プレフィックスのエコー, 飾りつけ
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すモードラインの文字列の変更

下記の変数の値を変更することにより、モード行において入力モードを示す文字
列が変更されます。

@vtable @code
@item skk-latin-mode-string

アスキーモードを示す文字列。標準では、`` SKK''。

@item skk-hirakana-mode-string

かなモードを示す文字列。標準では、`` かな''。

@item skk-katakana-mode-string

カナモードを示す文字列。標準では、`` カナ''。

@item skk-jisx0208-latin-mode-string

全英モードを示す文字列。標準では、`` 全英''。
@end vtable

@node 入力モードを示すカーソル色に関する設定, ▼モードにおける変換候補のハイライト表示, 入力モードを示すモードラインの文字列の変更, 飾りつけ
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すカーソル色に関する設定

@vtable @code
@item skk-use-color-cursor

この変数の値が非 nil ならば、カーソルに色付けします。nil ならば、この機
能を無効にします。

標準では、ウィンドウシステムを使用していてなおかつ色表示が可能な場合に限
り、この機能が有効になります。
@end vtable

この機能が有効になっているとき、以下の変数の値を変更することで、各モード
におけるカーソルの色が変更されます。

@vtable @code
@item skk-default-cursor-color

SKK モードがオフであることを示すカーソル色。標準では、カーソルのある該当
フレームにおける標準のカーソル色を使います。

@item skk-hiragana-cursor-color

かなモードであることを示すカーソル色。標準では、背景の明暗により
``coral4'' または ``pink'' を用います。

@item skk-katakana-cursor-color

カタカナモードであることを示すカーソル色。標準では、背景の明暗により
``forestgreen'' または ``green'' を用います。

@item skk-jisx0208-latin-cursor-color

全角英字モードであることを示すカーソル色。標準では、``gold'' を用います。

@item skk-latin-cursor-color

アスキーモードであることを示すカーソル色。標準では、背景の明暗により
``ivory4'' または ``gray'' を用います。
@end vtable

カーソル色の変更の際、カラーマップ切れが起きた場合にはエラーメッセージを
表示し、標準のカーソル色を使います。

@vtable @code
@item skk-report-set-cursor-error

この変数の値を nil 設定すると、カラーマップ切れの際エラーメッセージを表
示しません。
@end vtable

@node ▼モードにおける変換候補のハイライト表示, エラーなどの日本語表示, 入力モードを示すカーソル色に関する設定, 飾りつけ
@comment  node-name,  next,  previous,  up
@subsection ▼モードにおける変換候補のハイライト表示
@cindex @file{canna.el}
@cindex @file{rgb.txt}
@cindex Overlays
@cindex Extents
@cindex Text Properties
@cindex face

@vtable @code
@item skk-use-face

この変数の値が非 nil であれば、Emacs のフェイス機能を使って変換候補をハ
イライト表示します。

このハイライト表示には Emacs のオーバーレイ (overlay) の機能を使います
@footnote{以前のバージョンではテキスト属性 (text property) を使用してい
ました。

オーバーレイ属性はテキスト属性と異なり、テキストの一部とは見なされません。
そのため、テキストのコピーの際にオーバーレイ属性は保存されません。その他
にも、オーバーレイの移動やその属性の変更はバッファの変更とは見なされない
こと、オーバーレイの変更はバッファのアンドゥリストに記録されないこと、な
どが特徴として挙げられます。

なお、XEmacs にはオーバーレイ機能はありません。代わりに extent というも
のが用意されているのでそれを利用します。}。

@item skk-henkan-face

この変数の値はフェイスであり、このフェイスによって変換候補がハイライト表
示されます。既定値は @w{highlight} です。
@end vtable

変数 @code{skk-henkan-face} には、既存のフェイス
@footnote{Emacs 標準 では @w{default}, @w{modeline}, @w{region},
@w{secondary-selection}, @w{highlight}, @w{underline},
@w{bold}, @w{italic}, @w{bold-italic} があります。}を指定できますが、新
たにフェイスを作ることもできます。そのために、以下の関数が用意されていま
す。

@ftable @code
@item skk-make-face

形式: (skk-make-face FACE)

この関数は、引数 FACE と同じ名前のフェイスを作成して、そのフェイスを返し
ます。フェイスの前景色・背景色は、引数 FACE によって、例えば以下の例のよ
うに決定されます。

@example
@group
(setq skk-henkan-face (skk-make-face 'DimGray/PeachPuff1))
@end group
@end example

この場合、前景色は DimGray に、背景色は PeachPuff1 になります。

もうひとつ例を挙げます。

@lisp
(skk-make-face 'RosyBrown1)
@end lisp

この場合、前景色は DimGray になります。背景色はもちません。つまり、バッ
ファの背景色がそのまま見えます。
@end ftable

@node エラーなどの日本語表示,  , ▼モードにおける変換候補のハイライト表示, 飾りつけ
@comment  node-name,  next,  previous,  up
@subsection エラーなどの日本語表示

標準では、エラー、メッセージおよびミニバッファでのプロンプトは、英語で表
示されます。

@vtable @code
@item skk-japanese-message-and-error

この変数の値を非 nil に設定すると、エラー、メッセージおよびミニバッファ
でのプロンプトを日本語で表示します。
@end vtable

@node VIP/VIPERとの併用, I-search関連, 飾りつけ, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section VIP/VIPERとの併用
@cindex VIP
@cindex VIPER
@cindex @file{vip.el}
@cindex @file{viper.el}

@vtable @code
@item skk-use-viper

この変数の値を非 nil に設定すると、VIPER に対応します。
@end vtable

VIPER については

@xref{Top, , VIPER, viper}. 

@noindent
を参照してください。

@c XXX VIP 3.7 について言及する。
また、VIPER の前身である VIP にも対応します。ただし、正式に対応している
バージョンは 3.5 のみです。これは Mule 2.3 に標準添付します
@footnote{ちなみに、VIP 3.5 の作者は、SKKの原作者でもある佐藤雅彦教授で
す。VIP 3.5 の発展版である VIPER は現在もメンテナンスされています。Emacs
19, 20 には、VIP 、VIPER とも標準添付します。}。

@node I-search関連, skk-init-fileのコンパイル, VIP/VIPERとの併用, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section I-search関連
@cindex I-search
@cindex Incremental search
@cindex @file{~/.skk}

@menu
* 起動時の入力モードの指定::    
* 間に空白等を含む文字列の検索::  
@end menu

@node 起動時の入力モードの指定, 間に空白等を含む文字列の検索, I-search関連, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 起動時の入力モードの指定

@vtable @code
@item skk-isearch-use-previous-mode

この変数の値が非 nil であれば、次のインクリメンタル・サーチ起動時の入力
モードは、前回のインクリメンタル・サーチでの入力モードになります。

@item skk-isearch-start-mode

この変数の値は、インクリメンタル・サーチの起動時の入力モードを決定します。
ただし変数 @code{skk-isearch-use-previous-mode} の値が非 nil ならば、そ
ちらの機能が優先されます。

この変数は以下の値を取り得ます。

@table @asis
@item latin

アスキーモード

@item hirakana

かなモード

@item jisx0208-latin

全英モード
@end table
@end vtable

@node 間に空白等を含む文字列の検索,  , 起動時の入力モードの指定, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 間に空白等を含む文字列の検索
@cindex Incremental regexp search

@samp{検索}という文字列をインクリメンタル・サーチにより検索する場合に、
バッファが以下のような状態になっていることがあります。

@example
@group
-------- Buffer: foo --------
この行末から始まる文字列を検
索して下さい。
-------- Buffer: foo --------
@end group
@end example

このような場合のために、Emacs は正規表現によるインクリメンタル・サーチを
提供しています。SKK はこの正規表現によるインクリメンタル・サーチにも対応
しているため、空白や改行を含んだ検索も可能です。

@table @asis
@item @kbd{M-x isearch-forward-regexp}
@findex isearch-forward-regexp
@kindex M-x isearch-forward-regexp
@kindex C-u C-s
@kindex M-C-s

前方への正規表現によるインクリメンタル・サーチ。
@kbd{C-u C-s} または @kbd{M-C-s} で起動します。

@item @kbd{M-x isearch-backward-regexp}
@findex isearch-backward-regexp
@kindex M-x isearch-backward-regexp
@kindex C-u C-r
@kindex M-C-r

後方への正規表現によるインクリメンタル・サーチ。
@kbd{C-u C-r} または @kbd{M-C-r} で起動します。
@end table

以下は空白や改行の処理を制御する変数です。

@vtable @code
@item skk-isearch-whitespace-regexp

この変数の値は正規表現です。この正規表現にマッチする要素は、正規表現によ
るインクリメンタル・サーチにおいては、単語を区切る要素ではないと判断され
ます。この変数の既定値は以下のようになっています。

@example
"\\(\\s \\|[ \t\n\r\f]\\)*"
@end example
@end vtable

変数 @code{skk-isearch-whitespace-regexp} の値を変更することで、正規表現
によるインクリメンタル・サーチを拡張することができます。例えば、電子メー
ルの引用部分を検索する場合を考えます。

@example
> 引用部分も検
> 索できる。
@end example

上記のうち、「検索」という語は 2 行にわたっているうえ引用マークが挿入さ
れています。ここで

@lisp
(setq skk-isearch-whitespace-regexp "\\(\\s \\|[ \t\n\r\f<>|]\\)*")
@end lisp

と設定することにより、「検索」を検索できるようになります。

@node skk-init-fileのコンパイル, picture-modeとの併用, I-search関連, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section @code{skk-init-file}のコンパイル

@vtable @code
@item skk-byte-compile-init-file

この変数の値が非 nil であれば、SKK の起動時に SKK の設定ファイル
(標準では @file{~/.skk}) を必要に応じてバイトコンパイルします。

この変数の値が nil であれば、SKK の設定ファイルをバイトコンパイルしたファ
イルを消去します。

この機能を有効にしたい場合は、@file{~/.emacs} に

@lisp
(setq skk-byte-compile-init-file t)
@end lisp

と記述します。
@footnote{この変数は SKK の設定ファイルが読み込まれる前に調べられるので、
SKK の設定ファイルに上記の設定を書いてもこの機能は有効になりません。}
@end vtable

@node picture-modeとの併用, サーバ関連, skk-init-fileのコンパイル, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section @code{picture-mode}との併用
@cindex @key{BS}
@cindex move-to-column
@cindex move-to-column-force
@cindex @file{picture.el}
@cindex picture-mode

SKK モードを @code{picture-mode} において使用した場合は、以下のような問
題点があります。ただし、これらは @code{picture-mode} の問題なので、現在
のところ SKK 側では対処していません。

@enumerate
@item
SKK モードで全角文字を入力した場合に、@key{BS}で全角文字を消すことができ
ません。現状では、後方にある文字を消したい場合は、その文字にポイントを合
わせ、@kbd{C-c C-d}で一文字づつ消す必要があります。

@item
コマンド @code{picture-movement-up} や @code{picture-movement-down} によ
り上下に全角文字を挿入した場合に、桁がずれる場合があります。
@end enumerate

関数 @code{move-to-column-force} の中で使用されている関数
@code{move-to-column} の引数として、全角文字を無視した桁数が与えられるこ
とがあり、そのときカーソル移動ができないため、これらの問題が生じます。

@node サーバ関連,  , picture-modeとの併用, 便利な応用機能
@comment  node-name,  next,  previous,  up
@section サーバ関連

@vtable @code
@item skk-servers-list

この変数を使うと、複数のホスト上の辞書サーバを使い分けることができます。

この変数の値は、辞書サーバ毎の情報リストです。各リストは 4 つの要素か
ら成ります。4 つの要素はそれぞれ、ホスト名、サーバ名 (フルパス)、サーバ
が読みこむ辞書名、サーバが使用するポート番号、となります。ただし、辞書、
およびポート番号は、サーバ自身が決定することもあるため、そのような場合は
nil として構いません。

例えば、以下のように設定します。

@lisp
@group
(setq skk-servers-list
      '(("host1" "/your/path/to/skkserv" nil nil)
        ("host2" "/your/path/to/skkserv" nil nil)))
@end group
@end lisp

上記の設定の場合、まず host1 上のサーバと接続します。接続できなくなると、
次に host2 上のサーバと接続します。

@item skk-report-server-response

この変数の値が非 nil であれば、変換時に、サーバの送出する文字を受け取る
までに関数 @code{accept-process-output} が実行された回数を報告します。

@item skk-server-remote-shell-program

この変数には、リモートシェルのプログラム名を指定します。既定値は、システ
ム依存性を考慮する必要があるため、以下の Emacs Lisp コードを評価すること
により決定されています。

@lisp
@group
(or (getenv "REMOTESHELL")
    (and (boundp 'remote-shell-program) remote-shell-program)
    (cond
     ((eq system-type 'berkeley-unix)
      (if (file-exists-p "/usr/ucb/rsh") "/usr/ucb/rsh" "/usr/bin/rsh"))
     ((eq system-type 'usg-unix-v)
      (if (file-exists-p "/usr/ucb/remsh") "/usr/ucb/remsh" "/bin/rsh"))
     ((eq system-type 'hpux) "/usr/bin/remsh")
     ((eq system-type 'EWS-UX/V) "/usr/ucb/remsh")
     ((eq system-type 'pcux) "/usr/bin/rcmd")
     (t "rsh")))
@end group
@end lisp
@end vtable

@node  辞書ツール, 旧バージョンからの変更点, 便利な応用機能, Top
@comment  node-name,  next,  previous,  up
@chapter 辞書ツール

SKK 辞書に関するツールには、Perl, C の各言語により書かれたものがあります。
入手は、WWW

@file{http://openlab.ring.gr.jp/skk/skk/tools/})

@noindent
もしくは CVS

@ref{CVSによる入手方法}

@noindent
からできます。

@menu
* Cによるツール::               
* Perlによるツール::            
@end menu

@node Cによるツール, Perlによるツール, 辞書ツール, 辞書ツール
@comment  node-name,  next,  previous,  up
@section Cによるツール

@menu
* プログラム作成方法::          
* skkdic-expr::                 
* skkdic-sort::                 
* skkdic-count::                
@end menu

@node プログラム作成方法, skkdic-expr, Cによるツール, Cによるツール
@comment  node-name,  next,  previous,  up
@subsection プログラム作成方法

@file{configure} スクリプトが付属するので、それを実行します。その後
@code{make} を実行します。

@example
% ./configure
% make
@end example

ここで、作成に関していくつか注意すべきことがあります。

@table @asis
@item ndbm

@file{skkdic-expr} を作成するには @code{ndbm} の機能が必要です。システム
にそれがない場合は、Berkeley DB もしくは @code{gdbm} をインストールする
ことで代用することができます。

@item TMPDIR

@file{skkdic-expr} を実行するとき、作業用のファイルとして辞書の 2 倍程度
の大きさのファイルを作成します。このファイルが作成されるディレクトリは実
行時に指定できます。もし指定しなければ、@file{skkdic-expr} の作成時に
@var{TMPDIR} に指定されたディレクトリが使用されます。これは標準では
@file{/tmp} になっていますが、@file{/tmp} の容量が小さいなどの事情がある
場合は

@example
-DTMPDIR=\".\"
@end example

@noindent
のような記述を @var{CFLAGS} に追加して作成します。実際には、例えば以下
のようにして作成します。

@example
% CFLAGS="-O2 -DTMPDIR=\".\"" ./configure
% make
@end example
@end table

@node skkdic-expr, skkdic-sort, プログラム作成方法, Cによるツール
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-expr}
@cindex @file{skkdic-sort}
@cindex @file{skkdic-expr}

複数の SKK 辞書を結合したり、他の辞書との差分をとるのに使います@footnote{但し、
@file{skkdic-expr} は辞書を正しい順にソートせず、また、
@w{@samp{;; okuri-ari entries.}} と @w{@samp{;; okuri-nasi entries.}} の
タグも付けてくれません。@file{skkdic-expr} によって生成した辞書は必ず
@file{skkdic-sort} による事後処理が必要です。

@xref{skkdic-sort}.}

例えば、次のようにします。

@example
% skkdic-expr @var{jisyo1} + @var{jisyo2} - @var{jisyo3} > @var{result}
@end example

@noindent
上記の例では、@var{jisyo1} と @var{jisyo2} にある @var{jisyo1} と重複し
ない候補を加え、その後、@var{jisyo3} と同じ候補があれば削除します。

また、次の引数が使用できます。これらは引数の辞書の前に指定します。

@table @var
@item -d

作業用ディレクトリ。

@item -o

出力ファイル。
@end table

以下にその他の使用例をあげます。

@enumerate
@item
複数の辞書を@code{cat}でつないだものを整理する。

@example
% skkdic-expr @var{olddict1} > @var{newdict1}
@end example

@noindent
このように使用すると、重複する候補を削除したり、同じ見出し語が別々の行に
複数存在していても一行のエントリにまとめます。例えば、

@example
じしょ /辞書/
じしょ /璽書/
じしょ /字書/
@end example

@noindent
のような辞書を

@example
じしょ /辞書/璽書/字書/
@end example

@noindent
と、一行にまとめることができます。候補が出力される際の優先順位は並び順に
なります。

@item
個人辞書と L 辞書との差分を取り出す。

@example
% skkdic-expr ~/.skk-jisyo - SKK-JISYO.L > @var{private}
@end example

@noindent
この差分を将来の SKK 辞書に反映させる方法については

@ref{お願い}

@noindent
を参照してください。

@item
2 つの辞書の共通部分を取り出す。

@example
@group
% skkdic-expr @var{jisyo-a} - @var{jisyo-b} > @var{jisyo-tmp}
% skkdic-expr @var{jisyo-a} - @var{jisyo-tmp} > @var{jisyo-common}
@end group
@end example
@end enumerate

@node skkdic-sort, skkdic-count, skkdic-expr, Cによるツール
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-sort}
@cindex @file{skkdic-sort}
@cindex @file{skkdic-expr}

ソートされていない辞書を通常の SKK 辞書の形式にソートし、@*
@w{@samp{;; okuri-ari entries.}} と @w{@samp{;; okuri-nasi entries.}} の
各行を適切な位置に挿入します。入力は標準入力のみ、出力は標準出力のみが指
定できます。@file{skkdic-expr} はソートも @w{@samp{;; okuri-ari entries.}}
と @w{@samp{;; okuri-nasi entries.}} のタグも出力してくれませんので、
@file{skkdic-expr} によって生成した辞書は必ず事後に @file{skkdic-sort}
をかける必要があります @footnote{一時的に使用する swap を小さくするため
にあえて @file{skkdic-expr} とは別のプログラムとしてあります。

@xref{skkdic-expr}.}

@example
% skkdic-expr @var{jisyo-a} + @var{jisyo-b} | skkdic-sort > @var{newdict}
@end example

@node skkdic-count,  , skkdic-sort, Cによるツール
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-count}
@cindex @file{skkdic-count}

SKK 辞書の中の候補数を数えます。@samp{[} と@samp{]} で囲まれた送り仮名毎
のブロックも一つの候補として数えます。

@node Perlによるツール,  , Cによるツール, 辞書ツール
@comment  node-name,  next,  previous,  up
@section Perlによるツール
@cindex @file{adddummy}
@cindex @file{codeconv.pl}
@cindex @file{jis2sjis}
@cindex @file{jis2ujis}
@cindex @file{kana2roma}
@cindex @file{kana2roma.pl}
@cindex @file{list2skk}
@cindex @file{pubdic2list}
@cindex @file{removedummy}
@cindex @file{roma2kana}
@cindex @file{roma2kana.pl}
@cindex @file{sjis2jis}
@cindex @file{skk2list}
@cindex @file{skkconv}
@cindex @file{sub}
@cindex @file{ujis2jis}

これは、辞書を結合したり、pubdic 辞書を SKK 辞書の形式に変換したりするた
めのツール群です。

SKK 辞書は見出し語に対応する複数の候補が @samp{/} で区切られた構造をして
いますが、このツールでは読みと候補が 1 対 1 に対応した形式
@footnote{これを @samp{リスト形式} と呼びます。}のファイルを中間形式とし
て取り扱います。

Perl によるツールには以下のプログラムがあります。

@table @file
@item skk2list

SKK 辞書をリスト形式に変換する。

@item pubdic2list

pubdic 辞書の名詞エントリをリスト形式に変換する。

@item list2skk

リスト形式を SKK 辞書に変換する。

@item adddummy

SKK 辞書ソートのためにダミー文字を加える。

@item removedummy

加えたダミー辞書を取り除く。

@item sub

2 つのリスト形式の辞書の差分を計算する。

@item skkconv

漢字検索コマンド。
@end table

例えば、既存の SKK 辞書と pubdic 辞書を結合して新しいSKK辞書を作成するに
は次のように行ないます。

@example
@group
% (skk2list skk-jisyo ; pubdic2list kihon.u) \@r{; リスト形式を連結}
      | adddummy \@r{; ダミー文字追加}
      | sort -u \@r{; ソート}
      | removedummy \@r{; ダミー文字削除}
      | list2skk \@r{; SKK辞書に変換}
      > skk-jisyo.new
@end group
@end example

これらのツールでは文字コードが EUC-JP の辞書のみ取り扱い可能です。それ以
外の文字コードの辞書を使うときは後述の @file{jis2ujis} などのコマンドを
組み合わせます。

2 つのリスト形式の辞書の差分を計算するには、

@example
% sub 旧リスト 新リスト
@end example

@noindent
とします。ただし比較する二つのファイルはあらかじめソートされている必要が
あります。

@file{skkconv} は辞書サーバを使用してコマンドラインでかな漢字変換するた
めのコマンドです。例えば @samp{かんじ} という読みをもつ漢字は以下のよう
に検索します。

@example
@group
% skkconv kanji
漢字
幹事
感じ
......
%
@end group
@end example

この他に以下の Perl ライブラリとコマンドがあります。

@table @file
@item codeconv.pl

JIS, EUC-JP, SJIS 相互変換ライブラリ。

@item roma2kana.pl

ローマ字 @expansion{} 平仮名変換ライブラリ。

@item kana2roma.pl

平仮名 @expansion{} ローマ字変換ライブラリ。

@item jis2sjis

JIS @expansion{} SJIS 変換コマンド。

@item sjis2jis

SJIS @expansion{} JIS 変換コマンド。

@item jis2ujis

JIS @expansion{} EUC-JP 変換コマンド。

@item ujis2jis
EUC-JP @expansion{} JIS 変換コマンド。

@item roma2kana
ローマ字 @expansion{} かな (EUC-JP) 変換コマンド。

@item kana2roma
かな (EUC-JP) @expansion{} ローマ字変換コマンド。
@end table

@node 旧バージョンからの変更点, 拡張アイディア, 辞書ツール, Top
@comment  node-name,  next,  previous,  up
@chapter 旧バージョンからの変更点

SKK 10 は SKK 9.6 と比べて、重要な変更がいくつかあります。そこで、
@w{SKK 9.6} のユーザーが SKK 10 に移行するに際して注意すべき点について本
節で説明します。

@table @asis
@item 対応する Emacs のバージョン

Emacs 20 と XEmacs 21 をサポートしたことが最も重要な変更点です。同時に 
Mule 2.3 (Emacs 19.28 または 19.34) もサポートします。ただし、Nemacs や 
Mule 1.1 など、Emacs 18 はもはやサポートされません。

@item APEL ライブラリの使用

様々な Emacsen の上で動作するようにすると保守が難しくなります。SKK 10 は
 APEL ライブラリを各種 Emacs の差異を吸収する目的で使用し、この問題に対
処しています。

一方で、SKK をインストールする前に APEL をインストールする必要があるため、
管理者にとってはひとつ手間が増えることになります。

@item Custom パッケージの使用

Emacs 20 はユーザーオプションの設定のための汎用インターフェイスとして
Custom というパッケージを採用しています。SKK 10 もこれを使った設定ができ
ます。ただしその汎用性のためか、必ずしも便利ではないため、このマニュアル
では詳しく説明していません。

@item 多くの変数の defcustom (defvar) 化

以前のバージョンでは、変数の宣言に @code{defconst} を使用していました。
これは、どのようなカスタマイズが行なわれている場合でもチュートリアル使用
時に標準設定に戻すのが目的でした。このため、全てのカスタマイズは 
@file{~/.skk} で行なう必要がありました。SKK 10 では、@code{defcustom} を
使用した宣言を行なっているので、この制限はなくなりました。

@item @code{skk-input-vector} の廃止
@vindex skk-input-vector

SKK 9 のころは、「？」や「；」などの記号をいわゆる半角で入力するために、
@code{skk-input-vector} という変数の設定を各ユーザが行っていました。
SKK 10 では、この変数は廃止されましたが、代わりに
@code{skk-rom-kana-rule-list} という変数を使って、同様の設定ができるので
問題ありません。その設定方法を知りたい場合は

@ref{数字や記号文字の入力}

@noindent
を参照してください。
@end table

@node 拡張アイディア, SKKメーリングリスト, 旧バージョンからの変更点, Top
@comment  node-name,  next,  previous,  up
@chapter 拡張アイディア

本章には、将来のバージョンに託された拡張アイディアについて記述します。実
現可能かどうかに関しては必ずしも触れません。

これ以外にも要望、拡張の具体的アイディアがあれば、メーリングリストに投稿
するなどの方法で、開発チームに連絡いただけることを期待します。

@xref{SKK Ring Server Openlab メーリングリスト}.

@itemize @bullet
@item
辞書の個々の見出し語、候補に属性を持たせる。それにより、例えば、次のよう
な機能を実装する。

@enumerate
@item
その属性の内容により、変換の際に候補の絞り込み条件を指定できるようにする。
その際、絞り込み条件はユーザーの任意に変更できるようにする。一例をあげれ
ば、サ変動詞になり得る名詞に適当な属性を持たせ、@samp{〜する} という送り
仮名が入力された場合には、そのサ変動詞属性を持った名詞のみを候補として出
力する、など活用の幅は非常に広い。サ変動詞の問題については、

@w{@ref{辞書登録モード}}

も参照のこと。

@item
候補に最終の変換時刻などを属性として持たせ、辞書のメンテナンスに利用する
(一定期間アクセスのない候補を個人辞書から削除するなど)。

@item
候補に関する意味を属性として持たせ、意味を調べるような拡張変換を行なえる
ようにする。
@end enumerate

@c XXX 今まで実験してきたことを記述する。
@noindent
言うは易しだが、色々な未解決の問題がある。多数の見出し語や候補に属性を持
たせて、通常の変換効率をできる限り落さないで、かつ効率良く属性のメンテナ
ンスを行なう方法を模索することがまず大変。Emacs のバッファに読み込む辞書
とサーバ経由でアクセスしている辞書とがあることも検討事項。Emacs 側の機
能で対応した場合にサーバ経由の辞書属性をどうやって得るか、またはその逆
が課題である。コーディング抜きであってもアイディアをいただけたら幸いであ
る。

@item
Canna や Wnn のサーバと接続して検索が可能になるようにする
@footnote{Tamago 4 では、Emacs Lisp ベースでサーバと接続できる。

@samp{http://www.m17n.org/tamago/}}。

@item
いかなるユーザーオプション変数をバッファローカル化しても動作するようにす
ること。辞書バッファで参照されるユーザーオプションを、変換を行なっていた
バッファの指定値から受け渡しして辞書バッファで参照するなどの配慮が必要か。

@xref{送り仮名の厳密なマッチ}.

@item
送り仮名の厳密なマッチを要求せずに、送り仮名の自動処理を行なうオプション
を作ること。現状の送り仮名の自動処理では、送り仮名のプレフィックスがマッ
チするだけでは候補として出力せず、更に送り仮名全体が厳密にマッチするかど
うかをチェックしている。これは候補の絞り込みのためには有効に作用するが、
個人辞書の内容が貧弱な場合は、逆にこれがあだとなってすぐに辞書登録モード
に入ってしまう。オプション設定することにより、いずれの場合にも対応できる
ようにする。

@xref{送り仮名の自動処理}.

@xref{送り仮名の厳密なマッチ}.

@c @item
@c @code{query-replace}などのコマンドで、SKKの入力モードを認識するようなプ
@c ロンプトを出す。こりゃ無理か？
@item
部首変換プログラムと辞書を作ること。

@c Daredevil では実現している。
@item
辞書毎にコーディングシステムを別々に設定できるようにすること。
@end itemize

@node SKKメーリングリスト, SKKの入手方法, 拡張アイディア, Top
@comment  node-name,  next,  previous,  up
@chapter SKKメーリングリスト

@menu
* SKK Ring Server Openlab メーリングリスト::  
* ユーザーメーリングリスト::    
@end menu

@node SKK Ring Server Openlab メーリングリスト, ユーザーメーリングリスト, SKKメーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section SKK Ring Server Openlab メーリングリスト
@cindex メーリングリスト

SKK 10 は、 Ring Server Openlab にて CVS を用いて開発されています。
このメーリングリストでは、利用者と開発者で分かれていません。バグレポートや
開発における議論など様々な話題が流れます。

@table @asis
@item メーリングリストに参加する場合

@samp{skk-request@@ring.gr.jp} 宛てのメールに本文に (@samp{Subject} ではあり
ません) @samp{subscribe} とだけ書いて送って下さい。機械的に加入処理されます。

@item メーリングリストから脱会する場合

@samp{skk-request@@ring.gr.jp} 宛てのメールに本文に (@samp{Subject} ではあり
ません) @samp{unsubscribe} とだけ書いて送って下さい。MLのメンバーからあ
なたのアドレスが機械的に削除されます。

@item 登録したアドレスの変更する場合

古いアドレスについて一旦 unsubscribe して、新しいアドレスから再度 subscribe
して下さい。

@item 記事の投稿 

@samp{skk@@ring.gr.jp} へ送ります。メーリングリストに登録されている人全員に
メールが配信されます。
@end table

Ring Server Openlab では、ニュースサーバに接続してメーリングリストの記事を
読むことができます。NNTP クライアントで @samp{news.ring.gr.jp} に接続します。
ニュースグループ名は、 @samp{ring.openlab.skk} です。

HTTP 経由でニュースを見ることもできます。

@w{@samp{http://ring.etl.go.jp/news/openlab.skk/}}

@noindent
データベースエンジンが装備されていますので、ニュース記事のキーワード検索
を行なうこともできます。

@node ユーザーメーリングリスト,  , SKK Ring Server Openlab メーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section ユーザーメーリングリスト
@cindex メーリングリスト

SKK に関する意見交換の場として SKK メーリングリストが開設されています。
これは SKK Ring Server Openlab メーリングリストが開設されるよりもずっと
前から利用されているメーリングリストで、現在でも投稿があります。


@table @asis
@item メーリングリストへ参加したいとき。

@samp{skk-join@@kuis.kyoto-u.ac.jp} へメールを送れば、自動的に発信者のメー
ルアドレス (@samp{From:}のアドレス) が登録されます。

@item メーリングリストへの記事の投稿を行なうとき。

@samp{skk@@kuis.kyoto-u.ac.jp} へ送れば自動的に全ての登録者に送付されま
す。

@item メーリングリストに登録したアドレスを変更したいとき。

新しいメールアドレスから @samp{skk-change@@kuis.kyoto-u.ac.jp} 宛に、本
文の 1 行目に下記の書式で旧アドレスを書いたメールを送付します。

@example
@samp{Old:@var{your-old-address}}
@end example

@item メーリングリストから抜けたいとき。

@samp{skk-leave@@kuis.kyoto-u.ac.jp}へメールを送ります。
@end table

@samp{skk-source@@kuis.kyoto-u.ac.jp} 宛にメールを送付することで、過去の
SKK メーリングリストへの投稿記事を入手することができます。入手したい記事
の @samp{Mailinglist-ID:} に従って、以下の要領で @samp{Subject:} を指定
し、メールを送付することで、指定された内容のメールが返送されます。

@table @asis
@item @samp{Mailinglist-ID:}が134の記事を入手する場合。

@samp{Subject: 134}

@item @samp{Mailinglist-ID:}が100番から199番の記事を全部入手する場合。

@samp{Subject: ml-contents-01}
@end table

@noindent
ただし、0 〜 99 番の場合は @samp{ml-contents-00}と指定します。なお、
Mailinglist-ID: が欠番の部分もあります。

@node SKKの入手方法, SKK関連ソフトウェア, SKKメーリングリスト, Top
@comment  node-name,  next,  previous,  up
@chapter SKKの入手方法

@menu
* WWWを利用して入手する方法::   
* CVSによる入手方法::           
@end menu

@node WWWを利用して入手する方法, CVSによる入手方法, SKKの入手方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section WWWを利用して入手する方法

SKK OpenLab のホームページでは、SKK の最新版を配布するためのページを設け
ています。

@table @asis
@item 日本語版URL

@samp{http://openlab.ring.gr.jp/skk/maintrunk-ja.html}
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item 英語版URL

@samp{http://openlab.ring.gr.jp/skk/maintrunk.html}

@end table

@node CVSによる入手方法,  , WWWを利用して入手する方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section CVSによる入手方法

CVS を利用すれば、SKK OpenLab のホームページにて公開されているものよりも
新しい開発版の SKK を入手できます。ここではまず、CVS の入手とインストー
ルについて説明し、次に CVS を使って SKK を取得する方法を述べます。


@menu
* CVSの入手先::                 
* CVSによるSKKの取得::          
@end menu

@node CVSの入手先, CVSによるSKKの取得, CVSによる入手方法, CVSによる入手方法
@comment  node-name,  next,  previous,  up
@subsection CVSの入手先

CVS は 以下のサイトで配布されています。
 
@samp{ftp://ftp.cvshome.org/pub/}

また、少し更新が遅れ気味のようですが、 GNU のミラーサイトからも入手でき
ます。マスターサイトは

@samp{ftp://ftp.gnu.org/gnu/non-gnu/cvs/}

ですが、日本から入手する場合は

@table @samp
@item ftp://ftp.ring.gr.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.win.ne.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.iij.ad.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.tokyonet.ad.jp/pub/GNU/non-gnu/cvs/ 
@end table

等の日本のサイトを利用します。上記は安定した正式リリース版ですが、最新の
開発版を利用したい人は

@samp{http://www.cvshome.org/dev/source.html}

@noindent
をご覧ください。

@c  また、Windows の binary が欲しい方は、
@c
@c  @samp{ftp://ftp.cvshome.org/pub/cvs-1.10/windows/cvs-1.10-win.zip}
@c
@c  に正式版 cvs-1.10 のバイナリーが、
@c
@c  @samp{ftp://ftp.cvshome.org/pub/cvs-1.10.5/windows/cvs.exe}
@c
@c  に開発版 cvs-1.10.5 のバイナリーが置かれています。また、Mac 用 CVS は
@c
@c  @samp{http://www.maccvs.org/}
@c
@c  から入手可能です。

CVS に関する情報は

@table @samp
@item http://www.loria.fr/~molli/cvs-index.html
@item http://www.cvshome.org/
@item http://www.race.u-tokyo.ac.jp/~moro/cvs/
@item http://www.itojun.org/hack/cvs/tut-kernel.html
@item http://www-vox.dj.kit.ac.jp/nishi/cvs/
@item http://duff.kuicr.kyoto-u.ac.jp/~okuji/gnujdoc.html
@end table

@noindent
などから得られます。

@node CVSによるSKKの取得,  , CVSの入手先, CVSによる入手方法
@comment  node-name,  next,  previous,  up
@subsection CVSによるSKKの取得

@samp{cvs} コマンドで SKK を取得する場合、「ログイン」と「チェックアウト」
の 2 つの操作が必要になります。

まず guest アカウントで openlab.ring.gr.jp の CVS server に「ログイン」
します。

@example
$ cvs -d :pserver:guest@@openlab.ring.gr.jp:/circus/cvsroot login
@end example

プロンプトが出るので、パスワードに `guest' を入れ、CR します。

@example
CVS password: guest (CR)
@end example

~/.cvspass というファイルに password が記録され、次からは明示的な
ログイン は不要になります。

次に「チェックアウト」 して CVS server からソースをもらってきます (この
ファイルをワーキングコピーといいます)。

@example
$ cvs -d :pserver:guest@@openlab.ring.gr.jp:/circus/cvsroot checkout skk/main
@end example

これで @file{skk/main} というディレクトリにワーキングコピーが作られます。

同様の操作で、@file{skk/main} を @file{skk/tools} に変更すると

@example
$ cvs -d :pserver:guest@@openlab.ring.gr.jp:/circus/cvsroot checkout skk/tools
@end example

辞書ツールが、@file{skk/dic} とすると辞書のワーキングコピーが作られます。

@node SKK関連ソフトウェア, 最新情報など, SKKの入手方法, Top
@comment  node-name,  next,  previous,  up
@chapter SKK関連ソフトウェア
@cindex @file{kakasi}
@c @cindex @file{pskkserv}
@cindex @file{skkfep}
@cindex @file{skkinput}

@menu
* dbskkd-cdb::                  
* skkfep内蔵jvim::              
* KAKASI::                      逆引プログラム
* skkfep::                      SKKクローンFEP
* SKK on Jed::                  Jedで動くSKK
* skkinput::                    X上のSKK入力プログラム
* SKKIME::                      skkinput for Microsoft Windows
* SKK95::                       Windowsで動くSKK like IME
@end menu

@node dbskkd-cdb, skkfep内蔵jvim, SKK関連ソフトウェア, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section dbskkd-cdb
@cindex dbskkd-cdb
@cindex cdb

本節は、dbskkd-cdb の開発者である力武健次氏により書かれたものを元に若干
変更しています。

@table @asis
@item 正式名称
dbskkd-cdb

@item どのようなソフトウェアか
SKK 用のシステム辞書サーバ。

@item 使用するために要求される環境
Linux, FreeBSD, Solaris 2.6 上での動作を確認している。現状では使用する
SKK システム辞書と比べ、cdb 形式の辞書のサイズは 2 倍弱になる。セキュリ
ティ向上のため、inetd から tcp_wrapper などを経由して起動することを前提
とする。Daniel J. Bernstein 氏の開発した同様のソフトウェア ucspi-tcp の
使用を推奨する。高速化のため、Daniel J. Bernstein 氏の開発した固定データ
ベース用ライブラリ cdb を使っているので cdb のインストールが必要。

@item 最新バージョン、release の日付
1.01, 1999 年 9 月 28 日

@item 開発者
力武 健次 @w{<kenji.rikitake@@acm.org>}

@item 配布条件
GPL に準拠。

@item 入手方法
一次配布先は

@w{@samp{http://www.ne.jp/asahi/bdx/info/software/jp-dbskkd.html}}

@noindent
から参照できる。

@item bug report,質問のためのアドレス
@w{@samp{kenji-dbskkd-cdb@@k2r.org}}

@item その他
さまざまな UNIX 系 OS の上での動作レポートを希望しています。
@end table

@node skkfep内蔵jvim, KAKASI, dbskkd-cdb, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep内蔵jvim
@cindex skkfep
@cindex jvim

本節は、skkfep 内蔵 jvim の開発者である木原英人氏により書かれました。

@table @asis
@item 正式名称

skkfep 内蔵 jvim

@item どのようなソフトウェアか

jvim (vi クローンのエディタ vim を日本語化したもの) に skkfep を組み込ん
だものです。vi 系のエディタで SKK 風の日本語入力ができます。

@item 使用するために要求される環境

UNIX, Windows 95/98/NT, DOS

@item 最新バージョン、release の日付

jvim, skkfep, ari それぞれに対するパッチとして提供しています。
@w{jvim3.0-j1.7-skk1.2.8.patch} 1999/8/30,
@w{skkfep0.86c-kh1.2.6.patch}, 1999/9/28,
@w{ari1.00a-kh1.2.1.patch} 1999/1/29

@item 開発者
木原 英人

@item 配布条件

skkfep, jvim, ari それぞれに対するパッチとして提供しているので、それぞれ
の配布条件に従います。

@item 入手方法

@w{@samp{http://hiroshima.cool.ne.jp/deton/jvim-skk/}}

@item bug report,質問のためのアドレス

@w{@samp{deton@@m1.interq.or.jp}}
@end table

@node KAKASI, skkfep, skkfep内蔵jvim, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section KAKASI
@cindex Kanji Kana Simple Inverter

KAKASI とは、高橋裕信氏 @w{<takahasi@@tiny.or.jp>} による「漢字かなまじ
り文をひらがな文やローマ字文に変換することを目的として作成したプログラム
と辞書の総称」です。

KAKASIは、Kanji Kana Simple Inverter にちなんで、またSKKの逆言葉として名
付けられました。KAKASI は現在、Namazu のサイト

@samp{http://www.namazu.org/}

@noindent
にて開発が継続されています。

@table @asis
@item 入手方法

@w{@samp{http://kakasi.namazu.org/}}
@end table

@node skkfep, SKK on Jed, KAKASI, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep
@cindex @file{skkfep}

skkfep は、伊藤彰則、渡辺雅俊、金子裕の各氏による、SKK と似た入力方式の
漢字入力フロントエンドプロセッサです。

現在サポートされている OS は、以下の通りです。
@display
SunOS 4.x, AIX3.x, Linux, 386BSD, AIX/ESA, DOMAIN-IX SR9.x, HP-UX 8.x,
SEIUX 3.x, EWS-UX/V Rel4.0, NEWS-OS 4.x, NEWS-OS 3.3
@end display

@c @node pskkserv, SKK on Jed, skkfep, SKK関連ソフトウェア
@c @comment  node-name,  next,  previous,  up
@c @section pskkserv
@c @cindex DBM
@c @cindex Perl
@c @cindex @file{makedbmdic}
@c @cindex @file{pskkserv}
@c @vindex exec-directory
@c
@c pskkservは佐藤正章氏@w{<msatoh@@mrit.mei.co.jp>}による@file{skkserv}
@c 代替ソフトである。Perlスクリプトとしてインプリメントされており、サーバー
@c プログラムである@file{pskkserv}と、辞書のDBM化の際使用する 
@c @file{makedbmdic}がある。
@c
@c @file{pskkserv}は、SKK辞書をDBM化し、Perlの連想配列を用いて検索を行なう。
@c Perlの連想配列のインデクスキーは、内部的にハッシュテーブルに登録されてお
@c り、連想配列に登録されているエントリの個数に影響を受けることなく、一定時
@c 間で高速な検索を行なうことができる。DBM関連の関数が使えるPerlであれば、
@c バージョン4でも5でも動作可能である(Perl4専用プログラムとPerl5専用プログ
@c ラムとに分れている)。
@c
@c @file{pskkserv}を利用するには、まず@file{makedbmdic}によりSKK辞書をDBM
@c 化する必要がある。Berkeley DB形式の場合は、@file{makedbmdic}に@samp{-B}
@c オプションを、GDBMの場合は@samp{-G}オプションを渡す。
@c
@c @example
@c @cartouche
@c % makedbmdic -G SKK-JISYO.L
@c
@c makedbmdic by msatoh@@mrit.mei.co.jp
@c Make dbm format dic from SKK dic.
@c The numbers mean how many lines have processed.
@c A dot mean 20 lines, as you see.
@c
@c ..................................................1000[ 0.97%]
@c ..................................................2000[ 1.95%]
@c ..................................................3000[ 2.92%]
@c @dots{}
@c ..................................................101000[98.34%]
@c ..................................................102000[99.32%]
@c ................................... done
@c @end cartouche
@c @end example
@c
@c @noindent
@c @file{makedbmdic}により@file{SKK-JISYO.L}を処理すると、Berkeley DB形
@c 式の場合は、@file{SKK-JISYO.L.db}、GDBMの場合は@file{SKK-JISYO.L.gdbm}
@c というDBM形式の辞書が生成される@footnote{拡張子が違うので要注意。}。この
@c 辞書は、元の@file{SKK-JISYO.L}の4倍弱のファイルサイズになる。
@c
@c 次に@file{pskkserv}をEmacsの@code{exec-directory}などに置き、下記の
@c ようなシェルスクリプト@footnote{もちろん@file{pskkserv}のパスはご自分
@c のマシンに合ったものをご指定いただきたい。}を@file{rc.local}などに追加
@c して再起動する。
@c
@c @example
@c @group
@c echo Starting up pskkserv...
@c if [ -x /your/path/to/pskkserv ]; then
@c         /your/path/to/pskkserv -G /your/path/to/SKK-JISYO.L.gdbm &
@c fi
@c @end group
@c @end example
@c
@c また、下記のようなフォームを@file{~/.emacs}などに設定する。
@c
@c @lisp
@c (setq skk-server-prog "/your/path/to/pskkserv")
@c @end lisp
@c
@c @noindent
@c ディレクトリが、@code{exec-directory}と同一ならば、下記のように指定する
@c こともできる。
@c @lisp
@c (setq skk-server-prog (concat exec-directory "pskkserv"))
@c @end lisp
@c
@c @noindent
@c @file{pskkserv}を使用する場合でも、設定は@file{skkserv}を使用するとき
@c と変りない。@xref{共通の設定}.
@c @xref{スーパーユーザの権限を持たない人の場合}.

@node SKK on Jed, skkinput, skkfep, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK on Jed
@cindex Jed
@cindex S-Lang

本節は、SKK on Jedの開発者である豊福親信氏により書かれました。

@table @asis
@item 正式名称
SKK on Jed

@item どのようなソフトウェアか
Jed (Emacs 系の軽いエディタ。C 言語風の拡張言語 S-Lang を持つ) に移植さ
れた SKK です。

@item 使用するために要求される環境
日本語版 Jed が動いていればその上で動きます。現在、多くの UNIX、MSDOS、
Win95/NT、OS2 上で日本語版 Jed は動いています。

@item 最新バージョン、release の日付
version 0.1.1 (1996 年 12 月 15 日)

@item 開発者
豊福 親信

@item 配布条件
SKK と同じです。

@item 入手方法

@table @asis
@item メールによる入手方法
@samp{unbound@@papaya.juice.or.jp} にメールで連絡して下さい。

@item WWWを利用して入手する方法
WWW クライアントを利用して

@w{@samp{http://www.juice.or.jp/~toyofuku/jed.html}}

から入手できます。

@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.
@end table

@item bug report,質問のためのアドレス
@w{@samp{unbound@@papaya.juice.or.jp}}

@item その他
まだいくつか未実装機能がありますが SKK の全機能実装を目指しています。
@end table

@node skkinput, SKKIME, SKK on Jed, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkinput
@cindex @file{skkinput}

本節は、skkinput の開発者である阪本崇氏により書かれたものを若干修正した
ものです。

@table @asis
@item 正式名称
skkinput

@item どのようなソフトウェアか

日本語テキスト入力を要求する X11 のアプリケーションのための入力サーバ。
現在は Kinput Protocol にしか対応していませんが、将来的には XIM や
Kinput2 Protocol に対応させる予定です。

@item 使用するために要求される環境

UNIX + X11R5 または X11R6 (R6.1)

@item 最新バージョン ,release の日付

2.03, 

@item 開発者

阪本 崇 (@w{@samp{sakamoto@@yajima.kuis.kyoto-u.ac.jp}},
@*@w{@samp{PXG01715@@niftyserve.or.jp}})

@item 配布条件

ありません。

@item 入手方法

@smallexample
@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkinput.htm}}
@end smallexample

@noindent
から入手できます。
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item bug report、質問のためのアドレス

@w{sakamoto@@yajima.kuis.kyoto-u.ac.jp} もしくは
@w{PXG01715@@niftyserve.or.jp} まで御願い致します。

@item その他

SKK 8.6 にはかなり近付けたと思うのですが、まだまだ異なる部分が残っていま
す。特に操作体系で異なると感じられた方は私までレポートを御願い致します。
@end table

@node SKKIME, SKK95, skkinput, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKKIME
@cindex SKKIME

@table @asis
@item  開発者
skkinput と同じく 阪本崇氏

@item 最新バージョン
SKKIME 1.0

@item 入手先

@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkime.htm}}
@end table

@node SKK95,  , SKKIME, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK95
@cindex SKK95

@c @table @asis
@c @item 正式名称
@c @item どのようなソフトウェアか
@c @item 使用するために要求される環境
@c @item 最新バージョン、release の日付
@c @item 開発者
@c @item 配布条件
@c @item 入手方法
@c @item bug report,質問のためのアドレス
@c @item その他
@c @end table

本節は、京大マイコンクラブ川崎進一郎氏によって書かれました。

@table @asis
@item 正式名称
SKK95

@item どのようなソフトウェアか
Windows95, WindowsNT, Windows98 上で SKK ライクなかな漢字入力を実現する
IME。

@item 使用するために要求される環境
上記の OS (もちろん日本語版)。

@item 最新バージョン、release の日付
最新バージョン α13。1999 年 6 月 9 日。

@item 開発者
京大マイコンクラブ

@item 配布条件
SKK95 はフリーウェアです。商業目的以外の目的のためならば自由にコピーして
いただいて構いません。SKK95 を使用したことによるいかなる被害に対しても、
SKK95 の作者は責任を負いません。

@item 入手方法
下記のウェッブページから入手して下さい。

@w{@samp{http://www.kuis.kyoto-u.ac.jp/~kmc/proj/skk95/}}

@item bug report,質問のためのアドレス
@w{@samp{skk95-bugs@@kmc.kyoto-u.ac.jp}}

@item その他
1999 年 9 月現在、SKK95 はαバージョンであり、動作が安定していないところ
もあります。WindowsNT では比較的安定して動作するようです。
@end table

@node 最新情報など, 事項索引, SKK関連ソフトウェア, Top
@comment  node-name,  next,  previous,  up
@chapter 最新情報など

@menu
* 最新情報::                    
* 謝辞::                        
* お願い::                      
* SKKの作者::                   
* このマニュアルについて::      
@end menu

@node 最新情報, 謝辞, 最新情報など, 最新情報など
@comment  node-name,  next,  previous,  up
@section 最新情報

SKK 10 についての最新情報は、

@w{@samp{http://openlab.ring.gr.jp/skk/}}

@noindent
から得ることができます。

SKK Openlab では、開発者、文章の整備にご協力いただける方、テスター、よろず
ものを言う人などなど、常に募集しています。

@xref{SKK Ring Server Openlab メーリングリスト}.

また、SKK の開発は、 CVS によってなされています。CVS を使って最新の SKK を
取得する場合、CVS account を取得して開発に参加される場合は、付属の
@samp{READMEs/CVS_digest} ファイルを参照して下さい。

@node 謝辞, お願い, 最新情報, 最新情報など
@comment  node-name,  next,  previous,  up
@section 謝辞

(本節は、旧来のマニュアルのものですが、歴史的意義を踏まえて、そのまま掲
載します。)

SKK の設計方針は TAO/ELIS 上の日本語入力システム Kanzen の影響を受けてい
ます。Kanzen のデモを行ってくださり、また Kanzen を使う機会を与えてくだ
さった NTT の竹内郁雄さんに感謝します。

第 1 版の辞書作成のための読みの入力を行ってくださった東北大学電気通信研
究所佐藤研究室の 安藤大君、猪岡美紀さん、奥川淳一君、佐々木昭彦君、佐藤
克志君、山岸信寛君に感謝します。

SKK辞書第 2, 3, 4, 5, 6, 7, 8 版作成のためのデータを提供してくださった方々
に感謝します。

SKK辞書第 6, 7 版作成にあたり協力してくださった高橋裕信氏に感謝します。

@node お願い, SKKの作者, 謝辞, 最新情報など
@comment  node-name,  next,  previous,  up
@section お願い

SKK 辞書は多くのユーザの方々から提供された辞書によりコピーフリーの辞書と
しては最大規模の辞書になっています。今後もこの方式により SKK 辞書をより
充実したものにしていきたいと思います。

SKK 辞書の充実にご協力いただける方は、随時以下のアドレスまで個人辞書と
@file{SKK-JISYO.L} との差分をお送りください。お送りいただいた辞書を整理
して @file{SKK-JISYO.L} に含めさせていただきます。差分ファイルの作成方法
については @ref{skkdic-expr} を参照してください。

また, @file{SKK-JISYO.L} の誤りを発見された場合にも、多少にかかわらず、
下記のアドレスまでお知らせください。

@example
@samp{skk-dic@@maid.ne.jp}
@samp{skk@@ring.gr.jp}
@end example

@node SKKの作者, このマニュアルについて, お願い, 最新情報など
@comment  node-name,  next,  previous,  up
@section SKKの作者

SKK の原作者は、現京都大学の佐藤雅彦教授 @w{<masahiko@@kuis.kyoto-u.ac.jp>}
です。

現在の SKK は、大勢のボランティアの貢献により成立しています。以下は確認
されている貢献者名です。ここに入っていない貢献者がおられる場合には、修正
しますので、SKK OpenLab メーリングリスト @w{<skk@@ring.gr.jp>} までご一
報ください。

@itemize @asis
@item 小関 吉則 @w{<kose@@wizard.tamra.co.jp>}
@item 小野 孝男 @w{<takao@@hirata.nuee.nagoya-u.ac.jp>}
@item 進藤裕志 @w{<shindo@@super.ees.saitama-u.ac.jp>}
@item 中津山 恒 @w{<hisashi@@rst.fujixerox.co.jp>}
@item 沈志勇 @w{<jshen@@cas.org>}
@item 柘植 正大 @w{<ma-tsuge@@kdd.co.jp>}
@item Chikanobu Toyofuku @w{<unbound@@papaya.juice.or.jp>}
@item FUKANO Masaaki @w{<fukano-m@@alp.cs.uec.ac.jp>}
@item Fukaya Shigeru @w{<SFUKAYA@@oracle.co.jp>}
@item FURUE Hideyuki @w{<furue@@kke.co.jp>}
@item GUNJI Takao @w{<gunji@@lisa.lang.osaka-u.ac.jp>}
@item Haru Mizuno @w{<mizu@@cs3.cs.oki.co.jp>}
@item Haru'yasu Ueda @w{<hal@@sics.se>}
@item Hideki Sakurada @w{<sakurada@@kuis.kyoto-u.ac.jp>}
@item Hisao Kuroda @w{<kuroda@@msi.co.jp>}
@item Hitoshi SUZUKI @w{<h-suzuki@@ael.fujitsu.co.jp>}
@item IIDA Yosiaki @w{<iida@@secom-sis.co.jp>}
@item Jun-ichi Nakamura @w{<nakamura@@pluto.ai.kyutech.ac.jp>}
@item Katuya Tomioka @w{<tomioka@@culle.l.chiba-u.ac.jp>}
@item Kazuo Hirokawa @w{<hirokawa@@rics.co.jp>}
@item Kazushi Marukawa @w{<kazushi@@kubota.co.jp>}
@item Keisuke Nishida @w{<kxn30@@po.cwru.edu>}
@item Kenji Rikitake @w{<kenji@@reseau.toyonaka.osaka.jp>}
@item Kenji Yamashita @w{<kenji@@cs.titech.ac.jp>}
@item Kimura Chikahiro @w{<kimura@@oa1.kb.nec.co.jp>}
@item Kiyotaka Sakai @w{<ksakai@@netwk.ntt-at.co.jp>}
@item Koichi MORI @w{<kmori@@onsei2.rilp.m.u-tokyo.ac.jp>}
@item Koji Uchida @w{<uchida@@cfd.tytlabs.co.jp>}
@item Makoto MATSUSHITA @w{<matusita@@ics.es.osaka-u.ac.jp>}
@item Manabu Kawashima @w{<kaw@@lp.nm.fujitsu.co.jp>}
@item Masahiko Sato @w{<masahiko@@kuis.kyoto-u.ac.jp>}
@item Masahiko Suzuki @w{<suzmasa@@sm.sony.co.jp>}
@item Masahiro Doteguchi @w{<xdote@@rp.open.cs.fujitsu.co.jp>}
@item Masakazu Takahashi @w{<masaka-t@@ascii.co.jp>}
@item Masatake YAMATO @w{<masata-y@@is.aist-nara.ac.jp>}
@item Mikio Nakajima @w{<minakaji@@osaka.email.ne.jp>}
@item MINOURA Itsushi @w{<minoura@@uni.zool.s.u-tokyo.ac.jp>}
@item MIYOSHI Tsutomu @w{<minkov@@fuzzy.or.jp>}
@item Motohiko Mouri @w{<mouri@@jaist.ac.jp>}
@item Murata Shuuichirou @w{<mrt@@notwork.org>}
@item NAMBA Seiich @w{<pi9s-nnb@@asahi-net.or.jp>}
@item Naoki HAMADA @w{<nao@@mimo.jaist-east.ac.jp>}
@item Naoki Wakamatsu @w{<naoki-w@@ht-net21.ne.jp>}
@item NEMOTO Takashi @w{<tnemoto@@mvi.biglobe.ne.jp>}
@item NISHIDA Keisuke @w{<knishida@@nn.iij4u.or.jp>}
@item Rei FURUKAWA @w{<furukawa@@tcp-ip.or.jp>}
@item Ryoichi Hashimoto @w{<gnu@@ipri.go.jp>}
@item Satoshi Harauchi
@item Sekita Daigo @w{<sekita@@mri.co.jp>}
@item Shuhei KOBAYASHI @w{<shuhei@@aqua.ocn.ne.jp>}
@item Shuji Ashizawa @w{<ashizawa@@zuken.co.jp>}
@item SL Baur @w{<steve@@altair.xemacs.org>}
@item sphere @w{<sphere@@pop12.odn.ne.jp>}
@item Stephen Turnbull  @w{<turnbull@@sk.tsukuba.ac.jp>}
@item Takao KAWAMURA @w{<kawamura@@ike.tottori-u.ac.jp>}
@item Takeshi OHTANI @w{<ohtani@@iias.flab.fujitsu.co.jp>}
@item Thierry Emery @w{<Thierry.Emery@@nmu.alcatel.fr>}
@item TOKUYA Junichi @w{<tokuya@@crab.fuji-ric.co.jp>}
@item Tomotaka SUWA @w{<cooper@@saitama.fujimic.fujisankei-g.co.jp>}
@item Tomoyuki Hiro @w{<hiro@@momo.it.okayama-u.ac.jp>}
@item Toyonobu Yoshida @w{<toyono-y@@is.aist-nara.ac.jp>}
@item Tsugutomo Enami @w{<enami@@ptgd.sony.co.jp>}
@item Tsukamoto Tetsuo  @w{<czkmt@@remus.dti.ne.jp>}
@item Tsuyoshi AKIHO @w{<akiho@@media.osaka-cu.ac.jp>}
@item TSUMURA Tomoaki @w{<tsumura@@kuis.kyoto-u.ac.jp>}
@item Wataru Matsui @w{<matsui@@atr-rd.atr.co.jp>}
@item Wataru Matsui @w{<matsui@@gf.hm.rd.sanyo.co.jp>}
@item Yoshida Toyonobu @w{<toyono-y@@is.aist-nara.ac.jp>}
@item YOSHIZAWA Masahiro @w{<manbou@@ceres.dti.ne.jp>}
@item Yukiyoshi Kameyama @w{<kameyama@@kuis.kyoto-u.ac.jp>}  
@item Yuh Ohmura @w{<yutopia@@t3.rim.or.jp>}
@end itemize

@node このマニュアルについて,  , SKKの作者, 最新情報など
@comment  node-name,  next,  previous,  up
@section このマニュアルについて

本マニュアルは、SKK オープンラボの有志の貢献により、従来のマニュアルに加
筆修正したものです。

@node よくある質問とその回答(FAQ), 事項索引, 最新情報など, Top
@comment      node-name, next,       previous, up
@c @unnumbered よくある質問とその回答(FAQ)

@include{skk-faq.texi}

@node 事項索引, 変数索引, 最新情報など, Top
@comment      node-name, next,       previous, up
@unnumbered 事項索引

@printindex cp

@node 変数索引, 関数索引, 事項索引, Top
@comment    node-name,         next,       previous, up
@unnumbered 変数索引

@printindex vr

@node 関数索引, キー索引, 変数索引, Top
@comment      node-name, next,       previous, up
@unnumbered 関数索引

@printindex fn

@node キー索引,  , 関数索引, Top
@comment      node-name, next,       previous, up
@unnumbered キー索引

@printindex ky

@summarycontents
@contents
@bye

@c Local Variables:
@c End:
