\input texinfo @c -*- mode: texinfo; coding: iso-2022-jp -*-
@setfilename skk.info
@settitle SKK Manual
@paragraphindent 1
@c
@c  Author: Masahiko Sato <masahiko@kuis.kyoto-u.ac.jp>
@c          Yukiyoshi Kameyama <kameyama@@kuis.kyoto-u.ac.jp>
@c          NAKAJIMA Mikio <minakaji@namazu.org>
@c          Tsukamoto Tetsuo <czkmt@remus.dti.ne.jp>
@c          Tsuyoshi AKIHO <akiho@sky.email.ne.jp>
@c          SAKAI Kiyotaka <ksakai@kso.netwk.ntt-at.co.jp>
@c          Satoshi Harauchi <satoshi@sys.sdl.melco.co.jp>
@c          Kitamoto Tsuyoshi <lisp_interaction@yahoo.co.jp>
@c  Maintainer: SKK Development Team <skk@ring.gr.jp>
@c  Keywords: japanese
@c
@set EDITION 13.1.50
@set SKK-VERSION 13.1.50
@set UPDATED $Date: 2008/07/21 14:07:38 $

@dircategory Emacs
@dircategory GNU Emacs Lisp
@direntry
* SKK: (skk).           Simple Kana to Kanji conversion program.
@end direntry

@c Texinfo に追加できたら良いなぁと思う点を述べます。中島は単なる LaTeX
@c ユーザーで、Plain TeX マクロの組み方なんて全然知りませんので、ユー
@c ザーの立場でやりたいことを卒直に、また無責任に述べるに留めます。あし
@c からず。実現できる方法をご存知の方がいらっしゃいましたら、是非教えて
@c 下さい。
@c
@c (1)日本語の用語についてゴシック体でプリントアウトし、info では "「"
@c    と "」" を自動的に付けるような@jdfn{}が欲しい。本書では、日本語
@c    の用語定義をとりあえず`「',`」' で囲み、@b コマンドでゴシック体を
@c    出力するようにしている。
@c
@c (2)アスキー文字と全角文字を連接して書いたとしても pTeX がその間に適切
@c    に空白を挿入して印刷してくれる。一方 info は連接したままで空白は挿
@c    入されないので少し見にくい気がする。info ではアスキー文字と全角文
@c    字との間に半角スペースを挿入してはどうか?
@c
@c (3)LaTeX の表を書くコマンドを実装して欲しい (なら Latexinfo を使えと
@c    は言わないでね。互換性が大きく損なわれるから嫌なんです)。

@synindex pg cp
@footnotestyle end
@iftex
@afourpaper
@end iftex
@ifinfo
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@title SKK Manual
@subtitle Edition @value{EDITION}for SKK Version @value{SKK-VERSION}
@c @subtitle @value{UPDATED-MONTH}
@subtitle @value{UPDATED}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{}1991-2007 @w{Masahiko Sato}(佐藤雅彦), @*
@w{Yukiyoshi Kameyama}(亀山幸義), @w{NAKAJIMA Mikio}(中島幹夫),
@w{Tsukamoto Tetsuo}(塚本徹雄) and @w{Tsuyoshi AKIHO} (秋保強).
Revised by @w{Kiyotaka Sakai}(酒井清隆) and @w{Satoshi Harauchi}(原内聡).

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the author.

@end titlepage
@page
@ifinfo
@node Top
@top SKK

これは @cite{SKK マニュアル} 第 @value{EDITION} 版です。
SKK のバージョン @value{SKK-VERSION} に対応しています。


@menu
* はじめに::
* インストール::
* はじめの設定::
* 基本的な使い方::
* 便利な応用機能::
* ローマ字入力以外の入力方式::
* SKKに関する情報::
* よくある質問とその回答(FAQ)::
* 事項索引::
* 変数索引::
* 関数索引::
* キー索引::

@detailmenu
 --- 以下は各章の項目です。 ---

はじめに

* このバージョンのSKKについて::
* SKKとはなにか::

インストール

* APEL のインストール::
* DDSKK のインストール::
* 辞書の入手::
* 辞書サーバの入手::

はじめの設定

* 最も基本的な設定::
* インクリメント検索の設定::
* 古い設定のチェック::
* 辞書サーバを使いたいときの設定::

基本的な使い方

* 起動と終了::
* 入力モード::                  文字種別毎のモード
* 変換モード::                  辞書を用いた変換の状態毎のモード
* インクリメンタル・サーチ::
* チュートリアル::

便利な応用機能

* ファイル構成::                応用機能を使いこなすための予備知識。
* ユーザーオプションの設定方法::
* 入力モードの一時変更::        使用頻度の低い入力モードを一時的に利用する。
* ■モードにおける文字入力::    かな/カナ/全英モードでの文字入力の設定。
* ポイントを戻して▽モードへ::
* 文脈に応じた自動モード切り替え::
* 確定アンドゥ::                候補の選択ミスに対する取り消し操作。
* 見出し語関連::                変換のキーとなる語の処理について。
* 送り仮名関連::                送り仮名の処理について。
* 変換の学習::
* 候補の絞り込み::
* 単漢字変換::
* ▽モードにおける動的補完::
* 自動変換開始::                @key{SPC} を押さずに変換開始。
* 特殊変換::                    ちょっと変った便利な変換方法。
* 接頭辞・接尾辞::              接頭辞・接尾辞を指定して候補を絞り込む。
* 暗黙の確定のタイミング::      変換の後、いつ確定するか。
* 確定変換とその取り消し::      確定操作なしに確定する変換方法とその取り消し。
* 積極的な確定変換::            変換候補が一つだけなら確定変換する。
* 領域一括変換::                スパッと領域一括変換。
* 漢字コード関連::              漢字コードにまつわる機能。
* ▼モードの特殊キー::          キーの動作、あるいはキー定義変更。
* 変換位置の指定方法::          大文字以外でも変換位置を指定可能に。
* 辞書関連::                    辞書にまつわる設定および機能。
* DDSKK 以外のツールを用いた辞書変換::
* 飾りつけ::                    様々な表示の設定。
* ユーザガイダンス関連::
* VIP/VIPERとの併用::
* I-search関連::                インクリメンタル・サーチにまつわる機能。
* skk-init-fileのコンパイル::   設定ファイルの自動バイトコンパイル。
* picture-modeとの併用::        picture-mode との併用の際の問題点。
* サーバ関連::

ローマ字入力以外の入力方式

* AZIK::
* ACT::
* TUT-code::
* かな入力と親指シフト::

SKKに関する情報

* 最新情報::
* SKKメーリングリスト::
* SKK関連ソフトウェア::
* SKK辞書について::
* 辞書ツール::
* SKKの作者::
* SKKの歴史::
* このマニュアルについて::
* 謝辞::

よくある質問とその回答(FAQ)

* Introduction::                SKK のなぜなに。
* Installation::                SKK の入手から導入まで。
* Customization::               SKK の基本設定からお好みのカスタマイズまで。
* Dictionaries::                SKK 辞書関連。
* Miscellaneous::               SKK の活用法その他。

@end detailmenu
@end menu
@end ifinfo

@node はじめに
@chapter はじめに
@cindex はじめに

@menu
* このバージョンのSKKについて::
* SKKとはなにか::
@end menu

@node このバージョンのSKKについて
@section このバージョンのSKKについて

Daredevil SKK (以下 @samp{DDSKK} といいます) は高速で効率的な日本語入力環
境を提供するシステムです。GNU General Public License に従ったフリー・ソフ
トウェアとして配布されます。

DDSKK 13.1 が動作を保証する Emacsen のバージョンは下記の通りです。

@itemize @minus
@item Emacs 20.7 以降
@item Emacs 21.1 以降
@item Emacs 22.1 以降
@item Mule 機能付きでコンパイルされた XEmacs 21.4.18 以降
@item Mule 機能付きでコンパイルされた XEmacs 21.5.28
@end itemize

なお、XEmacs に関して、本体と別配布のパッケージ群は最新版が要求されます。
少なくとも xemacs-base パッケージは最新でなければなりません。また、
fsf-compat パッケージが動作のために必須です。

全体として、現在は XEmacs より GNU Emacs での動作がよくテストされており、
XEmacs でのより多くのテストが必要です。

@node SKKとはなにか
@section SKKとはなにか

SKK はかな漢字変換プログラムであり、Simple Kana to Kanji conversion
program にちなんで名付けられました。また、その名は Combinatory Logic での
有名な等式 @samp{SKK = I} にも由来しています @footnote{@samp{SKK = I} に
ついて詳しくは @url{http://openlab.jp/skk/SKK.html} をご参照下さい。}。

Daredevil SKK (DDSKK) は SKK のさらなる拡張版として位置付けられています。

但し、@samp{SKK モード}、@samp{SKK 辞書}、@samp{SKK サーバ} など、歴史的
な用語は引き継いでおり、DDSKK と呼ばない場合もあります。また、SKK 方式の
入力方法を採用したプログラムなど、広く SKK familyを意味する場合も同様で
す。

DDSKK の主な特徴は、次の通りです。

@itemize @bullet
@item 多彩な入力方式サポート。ローマ/かな 両対応のかな入力のほか、AZIK、
ACT、TUT-code による入力も可能。
@item 文法的知識を用いない高速な「かな → 漢字」変換。
@item 辞書に登録されていない単語の登録が簡単。
@item 個人辞書への単語の自動登録による変換の高ヒット。
@item マイナーモードとして実装されているので、メジャーモードにほとんど影
響を与えない。つまり、Emacs との親和性が高い。
@item DDSKK 本体 (Emacs Lisp) と辞書のみで動作(サーバは必須ではない)。辞
書サーバがダウンしていても使用できる。
@item 辞書サーバを使うことで、使用メモリを削減可能。
@item ディスク容量に応じて選べる辞書。
@item Emacs のオリジナルと同様の操作で行える日本語インクリメンタル・サー
チ。
@item Emacs Lisp で書かれたプログラムを変換候補にできる。
@end itemize

@samp{Daredevil} の名の由来については
@w{@ref{Q.1-1 Daredevil SKK って SKK とは違うのですか?}} を参照して下さ
い。

@node インストール
@chapter インストール
@cindex インストール

@menu
* APEL のインストール::
* DDSKK のインストール::
* 辞書の入手::
* 辞書サーバの入手::
@end menu

@node APEL のインストール
@section APEL のインストール
@cindex APEL

DDSKK 13 は種々の Emacsen での動作を可能とするため APEL (A Portable
Emacs Library) を使用します。DDSKK 13.1 は APEL 10.7 での動作を確認して
いますが、できるだけ新しいバージョンをインストールすることをお勧めします。

@display
@url{http://kanji.zinbun.kyoto-u.ac.jp/%7Etomo/lemi/dist/apel/}
@url{ftp://ftp.jpl.org/pub/elisp/apel/}
@end display

@noindent
より入手できます。

DDSKK のインストールをする前に APEL をインストールして下さい。

@node DDSKK のインストール
@section DDSKK のインストール
@findex skk-search-small-dic
@cindex SKK_DEFAULT_JISYO
@cindex @file{SKK-CFG}

APEL をインストールしたら、 DDSKK をインストールしましょう。ここでは、
UNIX 上で @code{make} コマンドが用意されている場合を想定しています
@footnote{Windows 環境では、@code{makeit.bat} を使用することにより、同
様の操作でインストールできます。 次の資料を参照してください。

@display
@url{http://openlab.jp/skk/skk/main/READMEs/README.w32.ja}
@end display

cygwin 環境をインストールされている方は @code{make} コマンドが使用できる
ので、ここの説明がそのまま当てはまります。

また、Mac OS 環境の方は以下の資料を参照してください。

@display
@url{http://openlab.jp/skk/skk/main/READMEs/README.MacOSX.ja}
@url{http://openlab.jp/skk/skk/main/READMEs/README.Mac.ja}
@end display
}。

まず、@code{tar} と @code{gzip} コマンドを使用して、 DDSKK を書庫
(@file{ddskk-VERSION.tar.gz}) から取り出します。

@example
% gzip -cd ddskk-VERSION.tar.gz | tar xvf -
@end example

@noindent
DDSKK のトップディレクトリ (@file{ChangeLog} や @file{Makefile} の
あるディレクトリ)をカレントディレクトリにします。

@example
% make what-where
@end example

@noindent
と実行すると、どのディレクトリにインストールされるか確認できます。
ここで、DDSKK のインストール先ディレクトリが表示されない場合は、APEL の
path を @file{SKK-CFG} に記入します。@file{SKK-CFG} に設定方法が書いてあ
ります。また、インストール先ディレクトリを変更したい場合も、
@file{SKK-CFG} ファイルを編集することにより指定できます。

つぎにスーパーユーザになって、

@example
% make install
@end example

@noindent
とすると、実際にインストールされます。

あるいは、一般ユーザが自分の home directory を root directory としてイ
ンストールするには、

@example
% make install PREFIX=~/
@end example

@noindent
とします。

特定の Emacs を指定する場合は、

@example
% make install EMACS=mule
@end example

@noindent
とすると指定できます。

XEmacs でパッケージとしてインストールする場合は、

@example
% make what-where-package
@end example

@noindent
を実行すると、パッケージのインストール先が表示されます。

@example
% make install-package
@end example

@noindent
を実行すると実際にインストールします。

@code{make} する際、SHELL の環境変数 @code{SKK_DEFAULT_JISYO} に SKK
辞書のファイル名(フルパス)がセットされていると、その辞書の内容を
@file{skk-dic.el} の中に取り込み、辞書検索関数として
@code{skk-search-small-dic} が使えるようになります。
@code{SKK_DEFAULT_JISYO} には通常、@file{SKK-JISYO.S} を指定すると良い
でしょう。@w{@xref{複数辞書の検索方法}.}

@node 辞書の入手
@section 辞書の入手

DDSKK を使用するには、辞書が必要です。DDSKK 本体 (elisp) には S 辞書が附
属します。それ以外の辞書は、必要に応じ別途入手して下さい。

@table @asis
@item SKK 各辞書の解説とダウンロード
 @url{http://openlab.jp/skk/wiki/wiki.cgi?page=SKK%BC%AD%BD%F1}
@end table

用意されている辞書は、従来からの

@itemize @minus
@item SKK-JISYO.S : S 辞書(主に単漢字が登録。最小限必要な語を収録)
@item SKK-JISYO.M : M 辞書(普通に使う分には足りる程度)
@item SKK-JISYO.ML: M 辞書と L 辞書の中間のサイズの辞書。L 辞書収録語の
                    内、EPWING 辞書やオンライン辞書で正しいと判別された
                    語をベースにして加除。
@item SKK-JISYO.L : L 辞書(あらゆる単語を収録)
@end itemize

@noindent
に加えて、

@itemize @minus
@item zipcode           : 郵便番号辞書
@item SKK-JISYO.JIS2    : JIS Level 2 辞書
@item SKK-JISYO.public+ : public+ 辞書
@item SKK-JISYO.JIS3_4  : JIS Level 3, 4 辞書
@item SKK-JISYO.edict   : edict 辞書(英和辞書)
@item SKK-JISYO.wrong   : 間違い辞書(S, M, L 辞書に既に登録されていたが、
                          間違いであったので削除された単語を収録)
@end itemize

@noindent
などがあります@footnote{一部の辞書の著作権は GNU GPL 2 とは異なるものが
ありますのでご注意下さい。詳細は以下の資料を参照して下さい。

@display
@url{http://openlab.jp/skk/skk/dic/READMEs/committers.txt}
@end display
}。

@node 辞書サーバの入手
@section 辞書サーバの入手

辞書サーバはオプションですので無くても DDSKK は動作しますが、特に辞書が
大きな場合に辞書サーバを利用することで省メモリ効果を得られます。また、辞
書サーバによっては複数辞書の検索、EPWING 辞書の検索ができたりするものも
あります。

DDSKK のクライアント側は特定の辞書サーバの実装に依存していませんので、下
記の辞書サーバのいずれでも動作可能です。ソースやバイナリの入手、インストー
ルについてはそれぞれのウェブサイトをご参照下さい。

@table @asis
@item SKK サーバの説明とリンク
@url{http://openlab.jp/skk/skkserv-ja.html}
@end table

@node はじめの設定
@chapter はじめの設定

DDSKK 11 以降、設定が非常に簡単になりました。DDSKK 13 では、標準的なイン
ストールの場合、なにも設定せず Emacs を起動するだけで使える状態になって
います。自動的に @file{skk-setup.el} というファイルが読み込まれ、設定さ
れます。

もし、この自動設定によらず、手動で設定をしたい場合は、以下の説明を参照し
てください。

@menu
* 最も基本的な設定::
* インクリメント検索の設定::
* 古い設定のチェック::
* 辞書サーバを使いたいときの設定::
@end menu

@node 最も基本的な設定
@section 最も基本的な設定
@cindex @file{skk-obsolete.el}

自動設定によらず、手動で設定する場合は、以下のように @file{~/.emacs} に書
きます@footnote{サンプルとして、配布物に @file{etc/dot.emacs}、
@file{etc/dot.skk} ファイルがあります。参考にして下さい。}。

@lisp
@group
(require 'skk-autoloads)
(global-set-key "\C-x\C-j" 'skk-mode)
(global-set-key "\C-xj" 'skk-auto-fill-mode)
(global-set-key "\C-xt" 'skk-tutorial)
@end group
@end lisp

@noindent
ただし XEmacs でパッケージとしてインストールをした場合は、

@lisp
(require 'skk-autoloads)
@end lisp

@noindent
の記述はしません。

サーバを使わない場合は、更に辞書ファイルを指定する必要があります。

@lisp
(setq skk-large-jisyo "/your/path/to/SKK-JISYO.L")
@end lisp

@noindent
この場合 @code{skk-large-jisyo} は Emacs のバッファに取り込んで使用します。
これによりメモリが圧迫されすぎる場合は、上記の @file{SKK-JISYO.L} を
@file{SKK-JISYO.M}、@file{SKK-JISYO.ML} または @file{SKK-JISYO.S} に変更
します。

@node インクリメント検索の設定
@section インクリメント検索の設定
@vindex isearch-mode-hook
@vindex isearch-mode-end-hook

以下のように @file{~/.emacs} に書きます。

@lisp
@group
(add-hook 'isearch-mode-hook
          #'(lambda ()
              (when (and (boundp 'skk-mode)
                         skk-mode
                         skk-isearch-mode-enable)
                (skk-isearch-mode-setup))))
(add-hook 'isearch-mode-end-hook
          #'(lambda ()
              (when (and (featurep 'skk-isearch)
                         skk-isearch-mode-enable)
                (skk-isearch-mode-cleanup))))
@end group
@end lisp

@noindent
上記の設定では、DDSKK が起動されているときのみ、付属のインクリメンタル・サー
チを使用します。常に付属のインクリメンタル・サーチを使用したかったら上記の
 @code{isearch-mode-hook}、 @code{isearch-mode-end-hook} の設定を下記の
設定に変更します。

@lisp
@group
(add-hook 'isearch-mode-hook 'skk-isearch-mode-setup)
(add-hook 'isearch-mode-end-hook 'skk-isearch-mode-cleanup)
@end group
@end lisp

@node 古い設定のチェック
@section 古い設定のチェック

@table @code
@item skk-obsolete-check-all-files
@findex skk-obsolete-check-all-files

このコマンドは、各個人の設定ファイルの古い設定を調べて、可能な限り新しい
設定に書換えます。
@end table

SKK 9、 SKK 10 と比較して、変数名、関数名が大幅に変更されたので、

@example
@file{skk-obsolete.el}
@end example

@noindent
をロードし、

@example
@kbd{M-x skk-obsolete-check-all-files}
@end example

@noindent
を実行することを強くお勧めします。

@node 辞書サーバを使いたいときの設定
@section 辞書サーバを使いたいときの設定

辞書サーバを使いたいときは、@file{~/.emacs} や @file{~/.skk} で以下のように
設定します。
@footnote{辞書サーバの入手等については @ref{辞書サーバの入手} を参照して
ください。}

@lisp
@group
(setq skk-server-host "example.org")
(setq skk-server-portnum 1178)
@end group
@end lisp

@table @code
@item skk-server-host
@vindex skk-server-host

辞書サーバの走っているホスト名、または IP アドレス。

@item skk-server-portnum
@vindex skk-server-portnum

辞書サーバが使うポート番号。@file{/etc/services} に skkserv のエントリがあれば
指定する必要は無い。
@end table


@vindex skk-server-inhibit-startup-server
辞書サーバが起動して無かった時、Emacs から skkserv プロセスを立ち上げる
事もできます。@code{skk-server-inhibit-startup-server} を @code{nil} に
する事でこの機能が有効になります。@ref{サーバ関連} も参照してください。

Emacs から立ち上げて利用する事ができる辞書サーバは、

@example
skkserv [-p port] [jisyo]
@end example

@noindent
のようなオプションを受け付け、inetd などを経由せず直接起動するものに限ら
れます。

サーバプログラムと辞書は次のように設定します。

@lisp
@group
(setq skk-server-prog "/your/path/to/skkserv")
(setq skk-server-jisyo "/your/path/to/SKK-JISYO.L")
@end group
@end lisp

@table @code
@item skk-server-prog
@vindex skk-server-prog

辞書サーバプログラム(フルパスで指定する)。

@item skk-server-jisyo
@vindex skk-server-jisyo

サーバに渡す辞書(フルパスで指定する)。
@end table

@noindent
これらの設定は、環境変数を利用して下記のようにすることもできます。
@cindex @code{SKKSERVER}
@cindex @code{SKKSERV}
@cindex @code{SKK_JISYO}

@table @asis
@item B シェルの場合 (sh, bash, ksh, zsh など)

@example
export SKKSERVER=example.org
export SKKSERV=/your/path/to/skkserv
export SKK_JISYO=/your/path/to/SKK-JISYO.L
@end example

@item C シェルの場合 (csh, tcsh など)

@example
setenv SKKSERVER example.org
setenv SKKSERV /your/path/to/skkserv
setenv SKK_JISYO /your/path/to/SKK-JISYO.L
@end example
@end table

@node 基本的な使い方, 便利な応用機能, はじめの設定, Top
@comment  node-name,  next,  previous,  up
@chapter 基本的な使い方

本章では、DDSKK の基本的な使用方法を説明します。これを読めば、とりあえず
DDSKK を使ってみるには充分です。

DDSKK を使った入力方法に慣れるには、付属のチュートリアルが最適なので、お
試しください。

@xref{チュートリアル}.

なお、次章の「便利な応用機能」は、興味のある個所のみをピックアップして
お読みになるのがいいでしょう。

@menu
* 起動と終了::
* 入力モード::                  文字種別毎のモード
* 変換モード::                  辞書を用いた変換の状態毎のモード
* インクリメンタル・サーチ::
* チュートリアル::
@end menu

@node 起動と終了
@section 起動と終了
@kindex C-x C-j
@kindex C-x j

SKK モードに入るには @kbd{C-x C-j}、もしくは @kbd{C-x j} とタイプします。
モードラインの左端には、下記のように @w{@samp{--かな:}} が追加されます。
@footnote{次の設定をしているときはマイナーモードの表示に追加されます。

@lisp
(setq skk-status-indicator 'minor)
@end lisp
}

@example
--かな:MULE/7bit----- Buffer-name (Major-mode)---
@end example

また、カーソルの色が変化します
@footnote{カラーディスプレイを使用し、カラー表示をサポートしている
Window System 下で対応する Emacs を使用している場合。

@w{@xref{入力モードを示すカーソル色に関する設定}.}}。

@kbd{C-x C-j}、もしくは @kbd{C-x j} を再度タイプすることで、SKK モードに
入る前のモードに戻り、カーソル色も元に戻ります。
@footnote{但し、@b{「アスキーモード」}を利用すれば SKK モードから抜ける
必要はほとんどありません。

@xref{入力モード, , アスキーモード}.}

@defvr {ユーザ変数} skk-preload

@file{~/.emacs} にて変数 @code{skk-preload} を非 @code{nil} と設定するこ
とにより、DDSKK の初回起動を速くすることができます。

@lisp
(setq skk-preload t)
@end lisp

これは、SKK 本体プログラムの読み込みと変数 @code{skk-search-prog-list} に
指定された辞書の読み込みを Emacs の起動時に済ませてしまうことにより実現し
ています。そのため、Emacs の起動そのものは遅くなりますが、DDSKK を使い始
めるときのレスポンスが軽快になります。
@end defvr

@menu
* SKKオートフィルモード::
* 辞書の保存::
@end menu

@node SKKオートフィルモード
@subsection SKKオートフィルモード
@cindex オートフィル
@cindex Auto Fill
@kindex C-x j

@kbd{C-x j} とタイプすれば、SKK モードに入ると同時にオートフィルモード
(@pxref{Auto Fill, , Auto Fill, emacs, GNU Emacs Manual})
をオンにします。

既にオートフィルモードがオンになっているバッファで @kbd{C-x j}をタイプす
ると、オートフィルモードは逆にオフになるので注意してください。

@kindex M-1 C-x j
@kindex C-u C-x j
バッファの状態にかかわらず強制的にオートフィルモード付で SKK モードに入
りたい場合は、@kbd{M-1 C-x j} や @kbd{C-u C-x j} などとタイプし、このコ
マンドに正の引数を渡します
@footnote{「引数」については、

@display
@ref{Arguments, , Arguments, emacs, GNU Emacs Manual}.
@end display

@noindent
を参照のこと。}。

@kindex C-u -1 C-x j
@kindex M-- C-x j
オートフィルモードをオフにし、かつ SKK モードも終了したい場合には
@w{@kbd{M-- C-x j}} や @w{@kbd{C-u -1 C-x j}} などとタイプし、このコマン
ドに負の引数を渡します。

@node 辞書の保存
@subsection 辞書の保存
@kindex C-x C-c
@vindex skk-backup-jisyo
@vindex skk-jisyo

@kbd{C-x C-c} で Emacs を終了しようとすると @file{~/.skk-jisyo} に個人辞
書 (@pxref{辞書の種別, , 個人辞書})の内容を自動的に保存します。

@file{~/.skk-jisyo.BAK} に保存を行う前の個人辞書が退避されます。

@file{~/.skk-jisyo} や @file{~/.skk-jisyo.BAK} のファイル名を変更したけ
ればそれぞれ @code{skk-jisyo} や @code{skk-backup-jisyo} の値を変更して
下さい。

@table @code
@item  skk-kill-emacs-without-saving-jisyo
@findex  skk-kill-emacs-without-saving-jisyo

個人辞書を保存せず Emacs を終了させたい場合には、

@example
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end example

@noindent
とタイプします。
@end table

個人辞書の保存動作について更に詳しくは、@ref{個人辞書の保存動作} を参照
してください。

@node 入力モード
@section 入力モード

SKK モードは、文字種類による 4 種類の@b{「入力モード」}と、辞書を用いた
変換の状態により 3 つの@b{「変換モード」}を持ちます。

入力モードは、文字種別により

@cindex かなモード
@cindex アスキーモード
@cindex カナモード
@cindex 全英モード
@itemize @asis
@item 「かなモード」
@item 「カナモード」
@item 「全英モード」
@item 「アスキーモード」
@end itemize

の 4 種類に分類されます。

@menu
* 入力モードの説明::
* 入力モードを切り替えるキー::
@end menu

@node 入力モードの説明
@subsection 入力モードの説明

@table @b
@item 「かなモード」

@itemize @asis
@item アスキー小文字をひらがなに変換するモード。
@item マイナーモードの表示: @w{@samp{かな}}
@item カーソル色: 赤系
@end itemize

@item 「カナモード」

@itemize @asis
@item アスキー小文字をカタカナに変換するモード。
@item マイナーモードの表示: @w{@samp{カナ}}
@item カーソル色: 緑系
@end itemize

@item 「全英モード」

@itemize @asis
@item アスキー小文字／大文字を全角アルファベットに変換するモード。
@item マイナーモードの表示: @w{@samp{全英}}
@item カーソル色: 黄系
@end itemize

@item 「アスキーモード」

@itemize @asis
@item 文字変換を行わないモード。入力されたキーは @kbd{C-j} を除いて通
常の Emacs のコマンドとして解釈される。
@item マイナーモードの表示: @w{@samp{SKK}}
@item カーソル色: 背景によりアイボリーかグレイ。
@end itemize
@end table

入力モードに伴うカーソル色の変更方法については、
@w{@ref{入力モードを示すカーソル色に関する設定}} を参照してください。

@node 入力モードを切り替えるキー
@subsection 入力モードを切り替えるキー

@table @kbd
@item q
「かなモード」、「カナモード」間をトグルする。

@item l
「かなモード」または「カナモード」から「アスキーモード」へ。

@item L
「かなモード」または「カナモード」から「全英モード」へ。

@item C-j
「アスキーモード」または「全英モード」から「かなモード」へ。
@end table

実際にはカナモードや全英モードで長時間入力を続けることはほとんどないの
で、かなモードのままでカナ文字や全英文字を入力する便法が用意されています。
@xref{入力モードの一時変更}.

@node 変換モード
@section 変換モード

変換モードは、次の 3 種類のいずれかです。

@table @b
@item 「■モード(確定入力モード)」

あるキー入力に対応する文字列を、辞書を用いた文字変換を行わずに直接バッ
ファへ入力するモード。入力モードに応じてローマ字からひらがな、ローマ字か
らカタカナ、あるいはアスキー文字から全角アルファベットへの文字変換を行
う。

@item 「▽モード」

辞書変換の対象となる文字列、「見出し語」を入力するモード。

@item 「▼モード」

見出し語について、辞書変換を行うモード。
@end table

また、▽モードの変種として @dfn{SKK abbrev mode} があり、▼モードのサブモー
ドとして、@b{「辞書登録モード」}があります。

@menu
* ■モード::                    辞書変換を行わない確定入力のモード。
* ▽モード::                    辞書変換のため見出し語の入力を行うモード。
* ▼モード::                    辞書変換を行うモード。
* 辞書登録モード::              個人辞書への単語登録を行うモード。
@end menu

@node ■モード
@subsection ■モード

@cindex 確定入力
@cindex 確定入力モード
@cindex ■モード
確定入力モードを@b{「■モード」}と呼びます。■モードでは、あるキー入力に
対応した特定の文字列への変換を行うだけで、辞書変換は行いません。アスキー
文字列から、入力モードに応じて、ひらがな、カタカナ、あるいは全角アルファ
ベットへの文字変換を行います。変換を行うカレントバッファにこのモード
特有のマークは表示されません。

@cindex ローマ字入力
かなモード、カナモードで、かつ ■モードである場合、デフォルトの入力方法
はいわゆるローマ字入力です。訓令式、ヘボン式のどちらによっても入力するこ
とができます。主な注意点を以下に説明します。

@itemize @bullet
@item
@samp{ん} は @kbd{n n} または @kbd{n '} で入力する。直後に @samp{n}、
@samp{y} 以外の子音が続くときは @kbd{n} だけで入力できる。

@item
促音は、@kbd{c h o t t o} @result{} @samp{ちょっと}、@kbd{m o p p a r a}
@result{} @samp{もっぱら} のように次の子音を重ねて入力する。

@item
促音や拗音(ひらがなの小文字)を単独で入力するときは、@kbd{x a} @result{}
@samp{ぁ}、@kbd{x y a} @result{} @samp{ゃ} などのように @kbd{x} を用いる。

@item
長音には、@kbd{-} を用いる。@kbd{-} @result{} @samp{ー}。
@end itemize

@node ▽モード
@subsection ▽モード

@cindex 辞書変換対象の文字列の決定
@cindex ▽モード
@b{「▽モード」}では、辞書変換の対象となる文字列を入力します。かなモード、
もしくはカナモード@footnote{@xref{入力モード, , かなモード、カナモード}.}
で、かつ、■モードであるときに、キー入力を大文字で開始することで、▽モー
ドに入ります。例えば、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
のようにタイプすることで、▽モードに入り、続けて辞書変換の対象となる文字
列、「見出し語」を入力してゆくことができます。@samp{▽}マークは、▽モード
であるという表示ですが、見出し語開始点を示す表示でもあります。

@menu
* 後から▽モードに入る方法::
* ▽モードを抜ける方法::
@end menu

@node 後から▽モードに入る方法
@subsubsection 後から▽モードに入る方法
@cindex 後から▽モードに入る方法
@kindex Q

辞書変換の対象としたい文字列について、先頭の文字を大文字で入力し忘れた場
合は、その位置までポイント@footnote{@xref{Point, ,ポイント, emacs, GNU Emacs Manual}.}
を戻し @kbd{Q} をタイプすることで、▽モードに入ることができます。例えば、
下記のように操作します (@point{} の地点にカーソルがあります)。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{C-u 3 C-b}

@group
------ Buffer: foo ------
@point{}かんじ
------ Buffer: foo ------
@end group

@kbd{Q}

@group
------ Buffer: foo ------
▽@point{}かんじ
------ Buffer: foo ------
@end group

@kbd{C-e}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

@cindex 数字から始まる見出し語の入力
@samp{7がつ24にち} のように大文字から始めることができない文字列についても、
▽モードにしたい場合は @kbd{Q} をタイプし、▽モードにしてから @samp{7が
つ24にち} の文字列を入力します。なお、▽モードでは、文字列の間に空白を含
めることはできません
@footnote{これは、辞書の見出し語に空白を含めることができない制限からきて
います。}。

@node ▽モードを抜ける方法
@subsubsection ▽モードを抜ける方法

@kindex C-g
@kindex C-j
誤って▽モードに入ってしまったときは @kbd{C-j} とタイプし、■モードに戻
るか @kbd{C-g} とタイプし▽モードで辞書変換と対象となっている文字列を消
去するかの 2 通りの処理の方法があります。具体例を下記に示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
あるいは、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group
@end example

@node ▼モード
@subsection ▼モード
@cindex Overlays
@cindex ハイライト
@cindex 暗黙の確定
@cindex 変換開始

@b{「▼モード」} では、▽モードで入力した見出し語を、辞書に従い変換する作
業を行います。▽モードで見出し語を入力した後 @key{SPC} をタイプするこ
とで▼モードに入ります。@samp{▽} マークから @key{SPC} をタイプしたとき
のポイントまでの文字列が見出し語として確定され、 @samp{▽} マークは
@samp{▼} マークで置き換えられ、この文字列が辞書の中で検索されます。

@menu
* 送り仮名が無い場合::
* 次候補・前候補::
* 送り仮名が有る場合::
@end menu

@node 送り仮名が無い場合
@subsubsection 送り仮名が無い場合

仮に、辞書に

@example
かんじ /漢字/幹事/
@end example

@noindent
というエントリ
@footnote{本マニュアルでは、見出し語と候補群を合わせた一行を「エントリ」
と呼びます。詳細は、@ref{送りありエントリと送りなしエントリ}を参照してく
ださい。}を含むとして、例を示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼漢字@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、▽モードにおける @samp{▽} マークからポイントまでの間の文字列
@samp{かんじ} を辞書変換の対象文字列として確定し、それについて辞書内での
検索を行っています。実際の変換動作では、候補部分がハイライト表示されます
@footnote{ハイライト表示は FSF Emacs の Overlays、XEmacs の extent の機能を使
用しています。}。

@samp{漢字} が求める語である場合は @kbd{C-j} をタイプすれば、この変換が
確定します。ハイライト表示も @samp{▼} マークも消えます。

また @kbd{C-j} をタイプせずに、新たな確定入力を続けて行うか、または新
たな変換を開始すると、直前の変換は自動的に確定されます。これを @b{「暗黙
の確定」} と呼んでいます。副作用として確定を伴うキーは、印字可能な文字
全てと @key{RET} です。ただし、@ref{暗黙の確定のタイミング} を参照してく
ださい。

@node 次候補・前候補
@subsubsection 次候補・前候補

求めるものがすぐに出なければ、更に続けて @key{SPC} をタイプすることで、
次候補を検索します。

@example
@group
------ Buffer: foo ------
▼漢字
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼幹事
------ Buffer: foo ------
@end group
@end example

候補が 5 つ以上あるときは 5 番目以降の候補は 7 つずつまとめてエコーエリ
アに表示されます。例えば、辞書が

@example
@group
きょ /距/巨/居/裾/嘘/拒/拠/虚/挙/許/渠/据/去/
@end group
@end example

@noindent
というエントリを含むときに @kbd{K y o} の後に @key{SPC} を 5 回続けて打
てば、

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

@noindent
がエコーエリア
@footnote{エコーエリアとミニバッファは視覚的には同一の場所にありますが、
エコーエリアが単にユーザーへのメッセージを表示するのみであるのに対し、ミ
ニバッファは独立のバッファとして機能する点が違います。}に表示されます。
ここで仮に @samp{許} を選択したければ、 @kbd{k} を入力します。

@samp{A}, @samp{S}, @samp{D}, @samp{F}, @samp{J}, @samp{K}, @samp{L} の
各文字は、押し易さを考慮してキーボードのホームポジションから横方向に一直
線に配置されているキーが選ばれています。また、候補の選択のために押すキー
は、大文字、小文字のいずれでも構いません。候補の選択に用いるキーの変更に
ついては、@ref{候補の選択に用いるキー} を参照してください。

@key{SPC} を連打してしまい、誤って求める候補を通過してしまったときは 
@kbd{x} により前候補/前候補群に戻ることができます
@footnote{@samp{x} は小文字で入力する必要があります}。

候補を次々と探しても求めるものがなければ、自動的に辞書登録モードになります
(辞書登録モードは▼モードのサブモードです) 。
@ref{辞書登録モード}にて説明します。

@node 送り仮名が有る場合
@subsubsection 送り仮名が有る場合

次に送り仮名のある単語について説明します。

@samp{動く} を変換により求めたいときは @kbd{U g o K u} のように、まず ▽
モード に入るために @kbd{U} を大文字で入力し、次に送り仮名の開始を DDSKK
に教えるために @kbd{K} を大文字で入力します。送り仮名の @kbd{K} をタイプ
した時点で @key{SPC} をタイプすることなく、▼モード に入り辞書変換が行わ
れます。

送り仮名の入力時、ローマ字プレフィックスが挿入された瞬間に、プレフィック
スの直前に @samp{*} を一瞬挿入し、送り仮名の開始時点を明示します。プレ
フィックスに続くキー入力で、かな文字が完成した時点で @samp{*} は消えます。

キー入力を分解して追いながらもう少し詳しく説明します。

@example
@kbd{U g o}

@group
------ Buffer: foo ------
▽うご
------ Buffer: foo ------
@end group

@kbd{K}

@group
------ Buffer: foo ------
▽うご*k
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
▼動く
------ Buffer: foo ------
@end group
@end example

DDSKK ではこのように、送り仮名の開始地点をユーザーが明示的に入力するので、
システム側で送り仮名を分解する必要がありません。これにより、高速でヒット
効率が高い変換が可能になります。@xref{送り仮名の自動処理}.

但しサ変動詞の変換では、サ変動詞の語幹となる名詞を @b{「送りなし変換」}
@footnote{詳細は、@ref{送り仮名が無い場合}を参照してください。}
として変換し、その後 @samp{する} を■モードで入力した方が効率が良くなり
ます。@xref{サ変動詞の辞書登録に関する注意, , サ変動詞の入力}.

@node 辞書登録モード
@subsection 辞書登録モード

@cindex 辞書登録
DDSKK には独立の辞書登録モードはありません。その代わり、辞書にない単語に
ついての変換を行った場合に、自動的に辞書登録モードに入ります。例えば辞書
に

@example
へんかんちゅう /変換中/
@end example

@noindent
のエントリがない場合に、@samp{変換中} を入力しようとして、@w{@kbd{H e n
k a n t y u u @key{SPC}}} とタイプすると、下記のように、カレントバッファ
は ▼モード のまま @samp{へんかんちゅう} に対して変換ができない状態で休
止し、同時にミニバッファに @samp{へんかんちゅう} というプロンプトが表示
されます。

@example
@group
------ Buffer: foo ------
▼へんかんちゅう
------ Buffer: foo ------

------ Minibuffer -------
[辞書登録] へんかんちゅう @point{}
------ Minibuffer -------
@end group
@end example

@menu
* 送り仮名が無い場合の辞書登録::
* 送り仮名が有る場合の辞書登録::
* サ変動詞の辞書登録に関する注意::
* 再帰的辞書登録::
* 改行文字を含む辞書登録::
@end menu

@node 送り仮名が無い場合の辞書登録
@subsubsection 送り仮名が無い場合の辞書登録

@noindent
辞書登録モードでは、入力はミニバッファに対して行われます。仮に辞書に

@example
@group
へんかん /変換/
ちゅう /中/
@end group
@end example

@noindent
のようなエントリがあるとして、ミニバッファで @samp{変換中} の文字列を
@samp{変換} と @samp{中} とに分けて作ります。

@example
@group
@kbd{H e n k a n @key{SPC} T y u u @key{SPC}}

----------- Minibuffer ------------
[辞書登録] へんかんちゅう 変換▼中
----------- Minibuffer ------------
@end group
@end example

@cindex 暗黙の確定
@noindent
ここで @key{RET} をタイプすれば @samp{変換中} が個人辞書に登録され、辞書
登録モードは終了します
@footnote{ここでは暗黙の確定が行われるので @kbd{C-j} をタイプする必要
はありません。ただし、@ref{▼モードでのRET} を参照してください。}。同時
に、変換を行っているカレントバッファには、@samp{変換中} が挿入され確定さ
れます。@xref{辞書の種別, , 個人辞書}.

辞書登録モードを抜けたいときは @kbd{C-g} をタイプするか、または何も登録
せず @key{RET} をタイプすると▽モードに戻ります。

@node 送り仮名が有る場合の辞書登録
@subsubsection 送り仮名が有る場合の辞書登録
@vindex skk-check-okurigana-on-touroku

送り仮名のある単語の登録では、ミニバッファで作る候補に送り仮名そのものを
登録しないように注意しなければいけません。仮に辞書に

@example
うごk /動/
@end example

@noindent
というエントリがないとして、例を挙げて説明します。

@example
@group
@kbd{U g o K u}

@end group
@group
------ Buffer: foo ------
▼うごく
------ Buffer: foo ------

------ Minibuffer -------
[辞書登録] うご*く@point{}
------ Minibuffer -------
@end group
@end example

@noindent
ミニバッファで辞書登録すべき文字列は、@samp{動} だけで、送り仮名の
@samp{く} は含めてはいけません。 @samp{動く} を登録してしまうと、次に
@kbd{U g o K u} とタイプしたときに出力される候補が @samp{動くく} になっ
てしまいます@footnote{変数@code{skk-check-okurigana-on-touroku} が非
@code{nil} であれば、辞書登録時に送り仮名のチェックを行います。この変
数に、シンボル @w{@code{ask}} を設定すれば、ユーザに確認を求め、送り仮
名と認められれば送り仮名を取り除いてから登録します。シンボル
@w{@code{auto}} を設定すれば、ユーザに確認を求めず、勝手に送り仮名を判
断して削除してから登録します。@code{skk-check-okurigana-on-touroku} の
デフォルトは @code{nil} です。}。

@example
@group
@kbd{D o u @key{SPC}}

@end group
@group
------ Minibuffer -------
[辞書登録] うご*く 動@point{}
------ Minibuffer -------

@end group
@key{RET}
@group

------ Buffer: foo ------
動く
------ Buffer: foo ------
@end group
@end example

@node サ変動詞の辞書登録に関する注意
@subsubsection サ変動詞の辞書登録に関する注意,

サ変動詞 (名詞の後に @samp{する} を付けた形で構成される動詞) については
@samp{する} を送り仮名とした送りあり変換 @footnote{送り仮名を伴う変換。
詳しくは、@ref{送り仮名が有る場合} を参照してください。} をしないで、
@samp{運動} と @samp{する} と分けて入力した方が効率が良くなります
@footnote{名詞とそのサ変動詞とを別々に辞書に持つと空間的な効率が悪いので、
基本的に、辞書がサ変動詞を送りありとして意識した作りとしていません。その
ため、@samp{する} を送り仮名とした送りあり変換では、辞書に候補がなく辞書
登録モードに入ってしまう可能性が高いので、名詞として分解して入力すること
をお勧めします。一方で、このように名詞に分解して入力することで、サ変動詞
になり得ない名詞が候補として出てくることもあるので (例えば @samp{孝行す
る} という変換を行いたい場合に @samp{高校} が出てくるなど)、候補の絞り
込みという点では必ずしも効率が良くありません。将来のバージョンにおいてこ
の点を改善する方向で検討しています。詳しくは、@ref{最新情報} を参
照してください。}。

例えば @samp{運動する} は @kbd{U n d o u @key{SPC} s u r u} とタイプする
ことにより入力できます。名詞から作られる形容詞等も同様です。

@node 再帰的辞書登録
@subsubsection 再帰的辞書登録

@cindex 再帰的辞書登録
ミニバッファを再帰的に使い辞書登録を再帰的に行うことができます。

仮に辞書に

@example
@group
さいきてき /再帰的/
さいき /再帰/
@end group
@end example

@noindent
のようなエントリがなく、かつ

@example
@group
さい /再/
き /帰/
てき /的/
@end group
@end example

@noindent
のようなエントリがあるとします。

ここで @kbd{S a i k i t e k i @key{SPC}} とタイプすると、文字列 @samp{さ
いきてき} に対する候補を見つけられないので、ミニバッファに @samp{さいき
てき} というプロンプトを表示して辞書登録モードに入ります。

@samp{さいきてき} に対する辞書エントリを作るため @kbd{S a i k i @key{SPC}}
とタイプすると、更にこの候補も見つけられないので、ミニバッファに
@samp{さいき} というプロンプトを表示して、再帰的に @samp{さいき} の辞書
登録モードに入ります。

@kbd{S a i @key{SPC} K i @key{SPC}}とタイプすると、ミニバッファは、

@example
------ Minibuffer -------
[[辞書登録]] さいき 再▼帰
------ Minibuffer -------
@end example

@noindent
となります。プロンプトが @samp{[[辞書登録]]} となり、@samp{[]} が1つ増え
ていますが、この @samp{[]} の数が再帰的な登録モードの深さを表わしています。
ここで @key{RET} をタイプすると、個人辞書には

@example
さいき /再帰/
@end example

@noindent
というエントリが登録され、ミニバッファは @samp{さいきてき} の辞書登録モー
ドに戻り、プロンプトは @samp{さいきてき} となります。

今度は @samp{再帰} が変換可能なので @kbd{S a i k i @key{SPC} T e k i
@key{SPC}} とタイプすると、

@example
------ Minibuffer -------
[辞書登録] さいきてき 再帰▼的
------ Minibuffer -------
@end example

@noindent
となります。ここで @key{RET} をタイプすることで、@samp{さいきてき} の辞
書登録モードから抜け、個人辞書に

@example
さいきてき /再帰的/
@end example

@noindent
というエントリが登録されます。カレントバッファのポイントには、@samp{再帰
的}が挿入されます。

@node 改行文字を含む辞書登録
@subsubsection 改行文字を含む辞書登録
@kindex C-q C-j

@cindex 改行文字を含む文字列の辞書登録
改行文字を含む文字列を辞書に登録するには、辞書登録モードで改行文字を
@kbd{C-q C-j} により入力します。例えば、

@example
@group
〒980
仙台市青葉区片平2-1-1
東北大学電気通信研究所
@end group
@end example

@noindent
を辞書に登録するには、辞書登録モードで、

@example
@group
@samp{〒980},
@kbd{C-q C-j},
@samp{仙台市青葉区片平2-1-1},
@kbd{C-q C-j},
@samp{東北大学電気通信研究所},
@key{RET}
@end group
@end example

@noindent
と入力します。

@node インクリメンタル・サーチ
@section インクリメンタル・サーチ
@cindex @file{isearch.el}
@cindex I-search
@cindex Incremental search

DDSKK では、専用のインクリメンタル・サーチプログラムを Emacs 添付の
@file{isearch.el} のラッパーとして実装しているため、日本語の文字列につい
てのインクリメンタル・サーチをアスキー文字と同様の操作で行うことができま
す。

@menu
* skk-isearchの操作性::
* skk-isearchと入力モード::
@end menu

@node skk-isearchの操作性
@subsection skk-isearchの操作性

大部分の動作は、オリジナルのインクリメンタル・サーチのままですから、
オリジナルのインクリメンタル・サーチのコマンド
@footnote{@kbd{M-y} の @code{isearch-yank-kill} や @kbd{M-p} の
@code{isearch-ring-retreat}, @kbd{M-n} の @code{isearch-ring-advance} な
ど}やユーザー変数でのカスタマイズ @footnote{@code{search-highlight} など}
もそのまま利用できます。

オリジナルのインクリメンタル・サーチについては、
@w{@ref{Incremental Search, ,Incremental Search, emacs, GNU Emacs Manual}.}
を参照してください。

インクリメンタル・サーチ中の入力方法は、通常のバッファにおける各入力モー
ド、変換モードでの入力方法と同一です。

@kindex C-r
@kindex C-s
@kindex M-C-s
@kindex M-C-r
@kbd{C-s} や @kbd{C-r}、あるいは @kbd{M-C-s} や @kbd{M-C-r} でインクリメ
ンタル・サーチを起動すると、インクリメンタル・サーチを起動したバッファの
入力モードと同一の入力モードで、キーとなる文字の入力が可能となります。

@node skk-isearchと入力モード
@subsection skk-isearchと入力モード

入力モードに合わせて、インクリメンタル・サーチのプロンプトが表示されます。
プロンプトの種類は、以下の 5 つです。

@table @asis
@item I-search: [aa]
アスキーモード

@item I-search: [か]
かなモード

@item I-search: [カ]
カナモード

@item I-search: [英]
全英モード

@item I-search: [--]
インクリメンタル・サーチモードで @kbd{C-x C-j} などをタイプして DDSKK を
終了した場合は、このプロンプトが表示されます。
@end table

@node チュートリアル
@section チュートリアル

@cindex チュートリアル
@vindex skk-tut-file
@findex skk-tutorial
@kindex M-x skk-tutorial
DDSKK には、チュートリアルが附属しています。チュートリアルでは、 DDSKK
の基本的な操作方法を学習できます。@kbd{M-x skk-tutorial} で実行します。
チュートリアルは、日本語 (@samp{Japanese}) と英語 (@samp{English}) が用
意されています。英語を選択する場合は、@kbd{C-u M-x skk-tutorial [RET]
English [RET]} を実行します。

チュートリアルファイルが、標準の場所にない場合は、 @file{~/.emacs} で

@lisp
(setq skk-tut-file "/usr/local/share/skk/SKK.tut")
@end lisp

@noindent
と書くことにより、指定したチュートリアルファイルを使用させることが
できます。英語のチュートリアルファイルは、 @samp{skk-tut-file} に @file{.E}
が付いたファイル名です。この場合であれば、
@file{/usr/local/share/skk/SKK.tut.E} になります。


@node 便利な応用機能
@chapter 便利な応用機能

@menu
* ファイル構成::                応用機能を使いこなすための予備知識。
* ユーザーオプションの設定方法::
* 入力モードの一時変更::        使用頻度の低い入力モードを一時的に利用する。
* ■モードにおける文字入力::    かな/カナ/全英モードでの文字入力の設定。
* ポイントを戻して▽モードへ::
* 文脈に応じた自動モード切り替え::
* 確定アンドゥ::                候補の選択ミスに対する取り消し操作。
* 見出し語関連::                変換のキーとなる語の処理について。
* 送り仮名関連::                送り仮名の処理について。
* 変換の学習::
* 候補の絞り込み::
* 単漢字変換::
* ▽モードにおける動的補完::
* 自動変換開始::                @key{SPC} を押さずに変換開始。
* 特殊変換::                    ちょっと変った便利な変換方法。
* 接頭辞・接尾辞::              接頭辞・接尾辞を指定して候補を絞り込む。
* 暗黙の確定のタイミング::      変換の後、いつ確定するか。
* 確定変換とその取り消し::      確定操作なしに確定する変換方法とその取り消し。
* 積極的な確定変換::            変換候補が一つだけなら確定変換する。
* 領域一括変換::                スパッと領域一括変換。
* 漢字コード関連::              漢字コードにまつわる機能。
* ▼モードの特殊キー::          キーの動作、あるいはキー定義変更。
* 変換位置の指定方法::          大文字以外でも変換位置を指定可能に。
* 辞書関連::                    辞書にまつわる設定および機能。
* DDSKK 以外のツールを用いた辞書変換::
* 飾りつけ::                    様々な表示の設定。
* ユーザガイダンス関連::
* VIP/VIPERとの併用::
* I-search関連::                インクリメンタル・サーチにまつわる機能。
* skk-init-fileのコンパイル::   設定ファイルの自動バイトコンパイル。
* picture-modeとの併用::        picture-mode との併用の際の問題点。
* サーバ関連::
@end menu

@node ファイル構成
@section ファイル構成
@cindex @file{ccc.el}
@cindex @file{leim-list.el}
@cindex @file{skk.el}

DDSKK 13 では、応用機能を提供するプログラムのほとんどを @file{skk.el} と
は別のファイルに収めています。これらは、必要に応じオートロードするように
設計されています。各応用機能の概略と該当のファイル名について説明します。

@table @file
@item context-skk.el
@cindex @file{context-skk.el}

編集の文脈に応じて自動的に skk のモードを切り替えたり、SKK の各種設定を変
更する機能を提供します。

@xref{文脈に応じた自動モード切り替え}.

@item skk-abbrev.el
@cindex @file{skk-abbrev.el}

SKK abbrev mode の機能を提供するプログラムを集めたファイル。

@xref{アスキー文字を見出し語とした変換, , SKK abbrev mode}.

@item skk-act.el
@cindex @file{skk-act.el}

dvorak 配列での拡張ローマ字入力 "ACT" を SKK で使うための設定を提供しま
す。

@xref{ACT}.

@item skk-annotation.el
@cindex @file{skk-annotation.el}

個人辞書に付けたアノテーション (注釈) を活用するプログラムを集めたファイ
ル。

@xref{辞書のアノテーション(注釈)}.

@item skk-auto.el
@cindex @file{skk-auto.el}

送り仮名の自動処理を行うプログラムを集めたファイル。

@xref{送り仮名の自動処理}.

@item skk-autoloads.el
@cindex @file{skk-autoloads.el}

オートロードの設定を記述したファイル。XEmacs で DDSKK をパッケージとして
インストールした場合は @file{auto-autoloads.el} というファイルがこれに相
当します。

@item skk-azik.el
@cindex @file{skk-azik.el}

拡張ローマ字入力 "AZIK" の設定を提供します。

@xref{AZIK}.

@item skk-bayesian.el
@cindex @file{skk-bayesian.el}

SKK の学習機能のひとつで、ユーザの過去の入力から変換候補を予測します。

@url{http://kenichi.kurihara.googlepages.com/bskk.html}

@item skk-comp.el
@cindex @file{skk-comp.el}

見出し語の補完を行うプログラムを集めたファイル。

@xref{見出し語の補完}.

@item skk-cursor.el
@cindex @file{skk-cursor.el}

カーソルの色を制御するプログラムを集めたファイル。

@xref{入力モードを示すカーソル色に関する設定}.

@item skk-cus.el
@cindex @file{skk-cus.el}
@kbd{M-x customize-group} による対話的な設定変更機能の簡易版を提供します。

@xref{Customize による設定変更}.

@item skk-dcomp.el
@cindex @file{skk-dcomp.el}

skk-comp による補完を自動的に実行して見出し語入力を支援します。

@xref{▽モードにおける動的補完}.

@item skk-develop.el
@cindex @file{skk-develop.el}

バグレポートのメールバッファを用意するプログラムファイル。

@item skk-dic.el
@cindex @file{skk-dic.el}

SKK 辞書を Emacs Lisp プログラムとして用意できます。

@item skk-e21.el
@cindex @file{skk-e21.el}

GNU Emacs 21 以降の拡張機能を利用するプログラムを集めたファイル。
インジケータのカラー化や画像表示、ツールティップ利用など。

@item skk-gadget.el
@cindex @file{skk-gadget.el}

プログラム実行変換を行うプログラムを集めたファイル。

@xref{プログラム実行変換}.

@item skk-hint.el
@cindex @file{skk-hint.el}

SKK の変換候補が多いときにヒントを与えて絞りこむ機能を提供します。

@xref{候補の絞り込み}.

@item skk-isearch.el
@cindex @file{skk-isearch.el}

DDSKK を併用したインクリメンタル・サーチ機能を提供します。

@xref{I-search関連}.

@item skk-jisx0201.el
@cindex @file{skk-jisx0201.el}

いわゆる半角カナを利用する機能を提供します。

@item skk-jisx0213.el
@cindex @file{skk-jisx0213.el}

JISX0213 文字コードを扱うプログラムです。

@item skk-jisyo-edit-mode.el
@cindex @file{skk-jisyo-edit-mode.el}

SKK 辞書を編集するためのメジャーモードを提供します。

@item skk-kakasi.el
@cindex @file{skk-kakasi.el}

KAKASI インターフェイスプログラムを集めたファイル。

@xref{領域一括変換}.

@item skk-kanagaki.el
@cindex @file{skk-kanagaki.el}

キーボードのかな配列などに対応する枠組みを提供します。
現段階では旧 JIS 配列のかなキーボード、および NICOLA 規格の親指シフト配
列に対応しています。

@xref{かな入力と親指シフト}.

@item skk-kcode.el
@cindex @file{skk-kcode.el}

漢字コードまたはメニューによる文字入力を行うプログラムを集めたファイル。

@xref{漢字コードまたはメニューによる文字入力}.

@item skk-leim.el
@cindex @file{skk-leim.el}

LEIM 関連プログラムファイル。DDSKK を Emacs の input method として利用で
きるようにします。

@item skk-look.el
@cindex @file{skk-look.el}

look インターフェイスプログラムを集めたファイル。

@xref{skk-look}.

@item skk-lookup.el
@cindex @file{skk-lookup.el}

Lookup で検索できる辞書を使って単語の候補を出力するプログラム。

@xref{skk-lookup}.

@item skk-macs.el
@cindex @file{skk-macs.el}

他のファイルで共通して使用するマクロなどを中心にまとめたファイル。

@item skk-num.el
@cindex @file{skk-num.el}

数値変換を行うプログラムを集めたファイル。

@xref{数値変換}.

@item skk-obsolete.el
@cindex @file{skk-obsolete.el}

@file{~/.emacs} や @file{~/.skk} などのユーザー設定ファイル中の古い設定 (変
数、関数名など)の修正支援プログラム。
@c XXX

@item skk-server-completion.el
@cindex @file{skk-server-completion.el}

拡張された SKK 辞書サーバによる見出し語補完機能を利用できます。

@item skk-server.el
@cindex @file{skk-server.el}

SKK 辞書サーバと通信して変換する機能を提供します。

@xref{サーバ関連}.

@item skk-setup.el
@cindex @file{skk-setup.el}

自動的に個人設定を行うためのファイル。

@item skk-sticky.el
@cindex @file{skk-sticky.el}

変換開始位置および送り開始位置の指定方法を変更可能にする。

@xref{変換位置の指定方法}.

@item skk-study.el
@cindex @file{skk-study.el}

直前に確定したいくつかの語との関連性を確認し、候補順を操作する学習効果
を提供するプログラム。

@xref{変換の学習}.

@item skk-tankan.el
@cindex @file{skk-tankan.el}

SKK を使って単漢字変換を行うプログラムです。

@xref{単漢字変換}.

@item skk-tut.el
@cindex @file{skk-tut.el}

SKK チュートリアルプログラム。

@xref{チュートリアル}.

@item skk-tutcode.el
@cindex @file{skk-tutcode.el}

SKK で TUT-code 入力を実現します。

@xref{TUT-code}.

@item skk-vars.el
@cindex @file{skk-vars.el}

DDSKK の変数を集約したファイル。カスタマイズしたい場合にこのファイルを見
ると参考になるかもしれません。

@item skk-version.el
@cindex @file{skk-version.el}

DDSKK のバージョン情報を提供するプログラムファイル。

@item skk-viper.el
@cindex @file{skk-viper.el}

VIPER インターフェイスプログラムを集めたファイル。

@xref{VIP/VIPERとの併用}.

@item skk-xemacs.el
@cindex @file{skk-xemacs.el}

XEmacs の拡張機能を利用するプログラムを集めたファイル。
インジケータのカラー化や画像表示、ツールティップ利用など。
@end table

なお、Elibより @file{queue-m.el} ファイルを収録しています。
@cindex @file{queue-m.el}

@node ユーザーオプションの設定方法
@section ユーザーオプションの設定方法

@cindex @file{~/.emacs}
@cindex @file{~/.skk}
DDSKK のカスタマイズは、@file{~/.emacs} あるいは @file{~/.skk} に記述し
ます。また、各ファイルの提供するフックも利用します。上記のファイルやフッ
クを利用した設定がいつ有効になるのか、という点についてここで説明します
@footnote{以前のバージョンでは、どのようなカスタマイズが行われている場合
でもチュートリアル使用時に標準設定に戻す目的で、変数の宣言に
@code{defconst} を使用していたので、全てのカスタマイズは @file{~/.skk}
で行う必要がありましたが、DDSKK 11 以降では、@code{defcustom} を使用した
宣言を行っているので、この制限はなくなりました。}。

@menu
* 設定ファイル::
* フック::
* Customize による設定変更::
@end menu

@node 設定ファイル
@subsection 設定ファイル

@table @asis
@item @file{~/.emacs}

Emacs を起動したときに一度だけ読みこまれます。

@xref{Init File, ,.emacs, emacs, GNU Emacs Manual}.

@item @file{~/.skk}

DDSKK を起動した最初の一度だけ読みこまれます。ファイル名の既定値は、OS
の種類により異なりますが、実際は Emacs の関数
@code{convert-standard-filename} により加工されます。
@findex convert-standard-filename
@file{~/.skk} のファイル名は変数 @code{skk-init-file} で変更することがで
きます。また、DDSKK にはこのファイルを自動的にバイトコンパイルする機能が
あります@xref{skk-init-fileのコンパイル}.。

@end table

@defvr {ユーザ変数} skk-user-directory
DDSKK は、@file{~/.skk} や @file{~/.skk-jisyo} といった複数のファイルを
使用します。これらのファイルをひとつのディレクトリにまとめて置きたい場合
は、変数 @code{skk-user-directory} にそのディレクトリ名を設定します。

この変数のデフォルトは @code{nil} です。この変数を設定する場合
は @file{~/.emacs} で行ってください。DDSKK 起動時
に @code{skk-user-directory} が指すディレクトリが存在しない場合は、自動
的に作られます。

@lisp
(setq skk-user-directory "~/.ddskk")
@end lisp

この変数を設定した場合（例えば上記 @code{"~/.ddskk"}）、以下に挙げる各変
数のデフォルト値が変更されます。

@example
影響を受ける変数       デフォルト値      変更後のデフォルト値
skk-init-file          ~/.skk            ~/.ddskk/init
skk-jisyo              ~/.skk-jisyo      ~/.ddskk/jisyo
skk-backup-jisyo       ~/.skk-jisyo.BAK  ~/.ddskk/jisyo.bak
skk-emacs-id-file      ~/.skk-emacs-id   ~/.ddskk/emacs-id
skk-record-file        ~/.skk-record     ~/.ddskk/record
skk-study-file         ~/.skk-study      ~/.ddskk/study
skk-study-backup-file  ~/.skk-study.BAK  ~/.ddskk/study.bak
@end example

なお、@code{skk-user-directory} を設定した場合でも、各変数を個別に設定し
ている場合はその個別の設定が優先されます。

@end defvr

@node フック
@subsection フック

@table @code
@item skk-mode-hook
@vindex skk-mode-hook

@kbd{C-x C-j} と入力して SKK モードに入る度に呼ばれます。主にバッファロー
カルの設定などを行います。

@item skk-auto-fill-mode-hook
@vindex skk-auto-fill-mode-hook

@kbd{C-x j} と入力してオートフィルモード付きで SKK モードに入る度に呼ば
れます。主にバッファローカルの設定などを行います。

@item skk-load-hook
@vindex skk-load-hook

@file{skk.el} の読みこみを完了した時点で呼ばれます。@file{~/.skk} は SKK
モードを起動しなければ読みこまれないのに対し、このフックは、
@file{skk.el} を読みこんだら SKK モードを起動しなくとも呼ばれます。

@item skk-auto-load-hook
@itemx skk-comp-load-hook
@itemx skk-gadget-load-hook
@itemx skk-kakasi-load-hook
@itemx skk-kcode-load-hook
@itemx skk-num-load-hook
@itemx skk-server-load-hook
@c @itemx skk-viper-load-hook
@vindex skk-auto-load-hook
@vindex skk-comp-load-hook
@vindex skk-gadget-load-hook
@vindex skk-kakasi-load-hook
@vindex skk-kcode-load-hook
@vindex skk-num-load-hook
@vindex skk-server-load-hook
@c @vindex skk-viper-load-hook

@file{skk-auto.el}, @file{skk-comp.el}, @file{skk-gadget.el},
@file{skk-kakasi.el}, @file{skk-kcode.el}, @file{skk-num.el},
@file{skk-server.el}
@c , @file{skk-viper.el} 
の各ファイルの読みこみが完了し
た直後に呼ばれるフック。
@end table

@findex eval-after-load
@code{load-hook} が提供されていないプログラムであっても、ロード後に何らか
の設定を行いたい場合は、関数 @code{eval-after-load} を使用します。例え
ば、

@example
@group
(eval-after-load "skk-look"
  '(
    ...
    ))
@end group
@end example

@noindent
のように記述します。

@node Customize による設定変更
@subsection Customize による設定変更

SKK の設定は、Emacs 標準の Customize 機能を使って行うこともできます。
ただし、 Customize での設定は @file{~/.emacs} での設定と同様、
@file{~/.skk} での設定により上書きされますので注意してください。

@kindex M-x customize-group
@kbd{M-x customize-group} により、skk の設定を対話的に変更することができ
ます。

@kbd{M-x customize-group} を実行すると、ミニバッファに ''Customize group''
とプロンプトが表示されます。ここで ``skk'' と答えると、SKK グループの画
面となります。

あるいは、モードラインで SKK インジケータを右 (第 3 ボタン) クリックして表示
されるメニューから ''SKKをカスタマイズ'' を選んでも同じ画面となります。

カスタマイズの使いかたは以下を参照してください。

@display
@xref{Easy Customization, , Easy Customization, emacs, GNU Emacs Manual}.
@end display

@kindex M-x skk-customize

@kbd{M-x customize-group} の設定が複雑すぎると感じるユーザのために、簡易
版として @kbd{M-x skk-customize} を用意しています。これは SKK グループの
ユーザオプションのうち、よく使うものだけ抜粋して設定できるようにしたもの
です。

これは、モードラインで SKK インジケータを右 (第 3 ボタン) クリックして表示
されるメニューから ''SKKをカスタマイズ (簡易版)'' を選んで呼び出すことも
できます。

@node 入力モードの一時変更
@section 入力モードの一時変更

DDSKK には、カタカナの入力にはカナモードを、全角アルファベットの入力には
全英モードを用いる @footnote{@w{@xref{入力モード, , カナモード、全英モード}.}}
普通のやり方のほかに、一時的にカナ文字、全英文字を入力して、また、かなモー
ドに戻る方法があります。

また、アスキー文字を見出し語として使用するために、かなモードから一時
的にアスキー文字を入力する機能が提供されています。それは▽モードの変種で
あり、 @dfn{SKK abbrev mode} と呼ばれています。この機能を使用することに
より、

@samp{is} @result{} @samp{インクリメンタル・サーチ}

のような変換を行うことができます。

ここではこれらの方法について説明します。

@menu
* ひらがな/カタカナの一時的入力::
* 全英文字の一時的入力::
@end menu

@node ひらがな/カタカナの一時的入力
@subsection ひらがな/カタカナの一時的入力
@kindex q
@cindex トグル変換

まず、かなモードもしくはカナモードに入ります。@kbd{Q} キーで一旦▽モー
ドにして @footnote{@kbd{/} キーで SKK abbrev mode に入ってしまうと
@kbd{q} キー入力が @samp{q} 文字の入力として扱われるのでこの場合は使いま
せん。} 何か文字列を入力し、その文字列の末尾で @kbd{q} をタイプすると、
@samp{▽} マークから @kbd{q} を入力した位置までの文字列が、変換され確定
されます。変換は、@samp{▽} とポイント間の文字列の種類 @footnote{正確に
は @samp{▽} の次の位置にある文字列によって文字種の判別を行っているので、
途中で文字種類の違う文字が混在していても無視されます。} をキーとして、以
下の規則に基づいて行われます。

@itemize @bullet
@item カタカナはひらがなへ
@item ひらがなはカタカナへ
@item 全英文字はアスキー文字へ
@item アスキー文字は全英文字へ
@end itemize

このような変換を、トグル変換と呼びます。以下はトグル変換の例です。

@example
@kbd{K a t a k a n a}

@group
------ Buffer: foo ------
▽かたかな@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
カタカナ@point{}
------ Buffer: foo ------
@end group
@end example

このトグル変換を上手く利用することにより、かなモードのまま一時的にカタカ
ナを入力したり、またその逆を行うことができます。こうすると、例えばひらが
な/カタカナ混じり文を書くときに、その都度 @kbd{q} キーを押して入力モー
ドを切り換える必要がありません。
@footnote{全英文字とアスキー文字のトグルでの変換を行うこともできます。
ただし、全英モードやアスキーモードでは @kbd{Q} やその他の大文字により▽
モードに入ることができないので、かな ⇔ カナ のときと同様にトグル変換で
きるわけではありません。かなモード/カナモードにおいて、既に入力さ
れた全英文字、アスキー文字に対してトグル変換をするような設計になっていま
す。}

トグル変換は、領域を対象としたコマンドによって行うこともできます。
@xref{領域一括変換}.

@node 全英文字の一時的入力
@subsection 全英文字の一時的入力
@kindex /
@kindex C-q

まず、かなモードに入ります。次に、@kbd{/} を入力すると、SKK abbrev モー
ドに入ります。続いて、全角アルファベットとして入力したい文字列を挿入し、
その文字列の末尾で @kbd{C-q} @footnote{@kbd{C-q} は
@code{skk-abbrev-mode-map} にて特別な動作をするように定義されています。
@xref{アスキー文字を見出し語とした変換}.}を入力することで、@samp{▽}マー
クから @kbd{C-q} を入力した位置までの文字列が全角アルファベットに変換さ
れ確定されます。

@example
@kbd{/ f i l e}

@group
------ Buffer: foo ------
▽file@point{}
------ Buffer: foo ------
@end group

@kbd{C-q}

@group
------ Buffer: foo ------
ｆｉｌｅ@point{}
------ Buffer: foo ------
@end group
@end example

なお、この変換を行うために、

@example
file /ｆｉｌｅ/
@end example

@noindent
のような辞書エントリを持つ必要はありません。なぜなら、辞書を参照せず、ア
スキー文字を 1 文字づつ全英文字に変換しているからです。

@node ■モードにおける文字入力
@section ■モードにおける文字入力

@menu
* かなモード/カナモードにおける入力::
* 全英モードにおける入力::
* 1回の取り消し操作(undo)の対象::
* 対になる文字列の一括入力::
@end menu

@node かなモード/カナモードにおける入力
@subsection かなモード/カナモードにおける入力

@menu
* ■モードにおける文字変換::
* skk-rom-kana-base-rule-listの具体例::
* skk-rom-kana-rule-listの利用例::
* ■モードに関連するその他の変数::
* 数字や記号文字の入力::
@end menu

@node ■モードにおける文字変換
@subsubsection ■モードにおける文字変換

@table @code
@item skk-rom-kana-base-rule-list
@vindex skk-rom-kana-base-rule-list
@item skk-rom-kana-rule-list
@vindex skk-rom-kana-rule-list
@end table

DDSKK の■モードにおける文字変換は、上記 2 変数を用いて行われます。

これらは、1 種の規則であり、「入出力の状態がいかに移り変わるべきか」を決
定します。その内容は、

@example
(入力される文字列 出力後に自動的に入力に追加される文字列 出力)
@end example

@noindent
という形のリストを列挙したものです。

@samp{入力される文字列} とは変換される前のアスキー文字の文字列をいいます。

@samp{出力} は次の入力状態に移るときにバッファに挿入される文字列の組み合
わせであり、 @w{("ア" . "あ")} のようなコンスセルです。

2 変数のうち、@code{skk-rom-kana-rule-list} はユーザが独自の規則を定義す
るために用意されていて、@code{skk-rom-kana-base-rule-list} の規則より優
先されます。

@node skk-rom-kana-base-rule-listの具体例
@subsubsection skk-rom-kana-base-rule-listの具体例

@code{skk-rom-kana-base-rule-list} には

@example
("a" nil ("ア" . "あ"))
("ki" nil ("キ" . "き"))
("tt" "t" ("ッ" . "っ"))
("nn" nil ("ン" . "ん"))
("n'" nil ("ン" . "ん"))
@end example

@noindent
のような規則があります。これによると

@example
a @expansion{}あ
ki @expansion{}き
tt @expansion{}っt
nn @expansion{}ん
n' @expansion{}ん
@end example

@noindent
のようになります。

@node skk-rom-kana-rule-listの利用例
@subsubsection skk-rom-kana-rule-listの利用例

@code{skk-rom-kana-base-rule-list} の規則に従うと

@example
hannou @expansion{}はんおう
han'ou @expansion{}はんおう
hannnou @expansion{}はんのう
@end example

@noindent
のようになります。ここで

@lisp
@group
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("nn" "n" ("ン" . "ん")))))
@end group
@end lisp

@noindent
のような設定にすることで

@example
hannou @expansion{}はんのう
@end example

@noindent
のようにローマ字かな変換が行われるようになります。

もうひとつ利用例を挙げます。

@example
tp @expansion{}東北大学
skk @expansion{}skk
skK @expansion{}SKK
@end example

@noindent
といった変換は、

@lisp
@group
("tp" nil ("東北大学" . "東北大学"))
("sk" nil ("" . ""))
("skk" nil ("skk" . "skk"))
("skK" nil ("SKK" . "SKK"))
@end group
@end lisp

@noindent
のような規則を追加することで実現されます。自分の名前を入力することはよく
あるので、適当な省略形を用いて、このリストに追加しておく、といった利用を
お勧めします。

更に @code{skk-rom-kana-rule-list} を用いれば TUT-code による日本語入力を
実現することもできます。例えば TUT-code による入力についてはソースアーカ
イブの @samp{tut-code} ディレクトリに収録されているソースコードを参照して
ください。

@node ■モードに関連するその他の変数
@subsubsection ■モードに関連するその他の変数

@defvr {ユーザ変数} skk-kana-input-search-function

ルールリストの中に記せない変換ルールを処理する関数。これは

@example
ohs @expansion{} おおs
@end example

@noindent
のような変換を実現するために用意されています。これにより

@example
ohsaka @expansion{} おおさか
ohta @expansion{} おおた
@end example

@noindent
のように変換されますが、一方

@example
ohhonn @expansion{} おっほん
ohhira @expansion{} おっひら
@end example

@noindent
となる場合もあります。これは @code{skk-rom-kana-rule-list} の既定値に

@example
("hh" "h" ("ッ" . "っ"))
@end example

@noindent
が入っているためです。これを削除すれば

@example
ohhonn @expansion{} おおほん
ohhira @expansion{} おおひら
@end example

@noindent
となります。
@end defvr

@defvr {ユーザ変数} skk-kutouten-type
■モードの標準では、キーボードの @kbd{.} をタイプすると「。」が、
@kbd{,} をタイプすると「、」がバッファに入力されます。
変数 @code{skk-kutouten-type} に適切なシンボルを設定することにより、この
組み合せを変更することができます
@footnote{変数 @code{skk-use-kana-keyboard} が 非 @code{nil} ならば無効
である。}。そのシンボルとは、次の４つです。

@example
'jp@ @ @ @ @expansion{} 「。」「、」 (デフォルト)
'en@ @ @ @ @expansion{} 「．」「，」
'jp-en @expansion{} 「。」「，」
'en-jp @expansion{} 「．」「、」
@end example

または、変数 @code{skk-kutouten-type} にはコンス・セルを指定することも可
能です。その場合は、

@example
(句点を示す文字列 . 読点を示す文字列)
@end example

のように指定します。例として、次のように設定するとキーボード
の @kbd{.} で @code{abc} が、@kbd{,} で @code{def} がバッファに入力され
ます。
@c ↓実用的な例が思い付きませんでした
@example
(setq skk-kutouten-type '("abc" . "def"))
@end example

なお、変数 @code{skk-kutouten-type} はバッファローカル変数です。すべての
バッファで統一した設定としたい場合は、

@example
(setq-default skk-kutouten-type 'en)
@end example

のように関数 @code{setq-default} を用いてください。
@end defvr

@node 数字や記号文字の入力
@subsubsection 数字や記号文字の入力

かなモード/カナモードにおける次のキーは、かつては @code{skk-self-insert}
関数にバインドされていました。現在は他のキーと同様に @code{skk-insert}
関数にバインドされています。

@example
@group
!  #  %  &  '  *  +

-  0  1  2  3  4  5

6  7  8  9  :  ;  <

=  >  ?  "  (  )  [

]  @{  @}  ^  _  `  |

~
@end group
@end example

これらの数字や記号文字のキーに対応し挿入される文字は、変数
@code{skk-input-vector} の値により決定されていましたが、DDSKK 10 にてこ
の変数は廃止されました。カスタマイズするためには、代わりに変数
@code{skk-rom-kana-rule-list} を利用します。例えば、SKK 9.6 以前において、

@lisp
(aset skk-input-vector ?! nil)
(aset skk-input-vector ?, nil)
(aset skk-input-vector ?. nil)
(aset skk-input-vector ?: nil)
(aset skk-input-vector ?; nil)
(aset skk-input-vector ?? nil)
@end lisp

@noindent
このような設定をしていた場合、DDSKK 10.x 以降で同様の入力をするためには、

@lisp
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("!" nil "!")
                ("," nil ",")
                ("." nil ".")
                (":" nil ":")
                (";" nil ";")
                ("?" nil "?"))))
@end lisp

@noindent
のような設定に変更する必要があります。

@code{skk-insert} は、Emacs のオリジナル関数 @code{self-insert-command}
をエミュレートしています。具体的には、引数を渡すことによって同じ文字を複
数、一度に挿入することが可能です
@footnote{かつては、@samp{▽あ}などを入力する場合には引数渡しができなかっ
たのですが、本バージョンではこれもできるように拡張されています。}。

@example
@group

@kbd{C-u 2 !}

------ Buffer: foo ------
！！
------ Buffer: foo ------
@end group
@end example

@node 全英モードにおける入力
@subsection 全英モードにおける入力

全英モードにおける印字可能な全てのキーはコマンド
@code{skk-jisx0208-latin-insert} に割り付けられています。また、変数
@code{skk-jisx0208-latin-vector} の値により挿入される文字が決定されます。
@code{skk-jisx0208-latin-vector} の既定値は以下のようになっています。

@lisp
@group
[nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 "　"  "！" "”" "＃" "＄" "％" "＆" "’"
 "（" "）" "＊" "＋" "，" "−" "．" "／"
 "０" "１" "２" "３" "４" "５" "６" "７"
 "８" "９" "：" "；" "＜" "＝" "＞" "？"
 "＠" "Ａ" "Ｂ" "Ｃ" "Ｄ" "Ｅ" "Ｆ" "Ｇ"
 "Ｈ" "Ｉ" "Ｊ" "Ｋ" "Ｌ" "Ｍ" "Ｎ" "Ｏ"
 "Ｐ" "Ｑ" "Ｒ" "Ｓ" "Ｔ" "Ｕ" "Ｖ" "Ｗ"
 "Ｘ" "Ｙ" "Ｚ" "［" "＼" "］" "＾" "＿"
 "‘" "ａ" "ｂ" "ｃ" "ｄ" "ｅ" "ｆ" "ｇ"
 "ｈ" "ｉ" "ｊ" "ｋ" "ｌ" "ｍ" "ｎ" "ｏ"
 "ｐ" "ｑ" "ｒ" "ｓ" "ｔ" "ｕ" "ｖ" "ｗ"
 "ｘ" "ｙ" "ｚ" "｛" "｜" "｝" "〜" nil]
@end group
@end lisp

挿入される文字の変更方法を知りたい場合は、@w{@ref{数字や記号文字の入力}}
を参照してください。

@code{skk-jisx0208-latin-insert} も Emacs オリジナルの関数
@code{self-insert-command} をエミュレートしています。つまり、引数を渡す
ことにより同じ文字を複数、一度に挿入することができます。
@code{skk-insert} における動作と同じですから、
@w{@ref{数字や記号文字の入力}} における例を参考にしてください。

@node 1回の取り消し操作(undo)の対象
@subsection 1回の取り消し操作(undo)の対象
@cindex @file{keyboard.c}
@findex self-insert-command
@findex skk-abbrev-comma
@findex skk-abbrev-period
@findex skk-kana-input
@findex skk-insert
@findex skk-set-henkan-point
@findex skk-jisx0208-latin-insert
@vindex skk-self-insert-non-undo-count

Emacs では本来、連続する 20 文字の挿入が一回の取り消し操作 (アンドゥ) の
対象となっています。そこで DDSKK のかな・カナ・全英モードにおける入力も、
これと同様の動作をするように設計されています
@footnote{@code{buffer-undo-list} に Emacs が挿入したアンドゥの境目の目
印を取り除く方法でエミュレートしています。}。正確に言えば、
@code{skk-insert}, @code{skk-set-henkan-point},
@code{skk-jisx0208-latin-insert}
@footnote{SKK abbrev モードでは、アスキー文字入力が Emacs 本来の
@code{self-insert-command} により行われているので、エミュレーションの
ための内部変数である @code{skk-self-insert-non-undo-count} をインクリメ
ントすることができず、アンドゥをエミュレートできません。しかも、カンマや
ピリオドを挿入した時点で、コマンド @code{skk-abbrev-comma} や
@code{skk-abbrev-period} を使うことになるので、本来のアンドゥの機能も損
なってしまいます。ただし、現実問題として、元来 SKK abbrev モードは省略形
としての見出し語を挿入するためのモードですから、長い見出し語を挿入するこ
とはあまりないと考えられます。}の各関数にバインドされたキー入力について
は、連続して入力された 20 文字を 1 つのアンドゥの対象としています
@footnote{`20' は Emacs のソースファイルの一部である @file{keyboard.c}
に定められたマジックナンバーと一致します。}。

ただし、これらの DDSKK のコマンドと Emacs 本来の
@code{self-insert-command} を織り混ぜてキー入力した場合
@footnote{かなモードでの入力中、アスキーモードに移行して入力した場合など
がこれにあたります。}は、このエミュレーションは正常に動作しませんが、こ
れは現在の仕様です。

@example
@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o}

------------------------- Buffer: foo -------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{連続する20文字。}
------------------------- Buffer: foo -------------------------
@end group
@group

@kbd{C-_}

------------------------- Buffer: foo -------------------------
                       ;@r{20文字全てがアンドゥの対象となる。}
------------------------- Buffer: foo -------------------------
@end group

@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o n a}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてとな ;@r{連続する21文字。}
-------------------------- Buffer: foo --------------------------
@end group
@group

@kbd{C-_}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{最後の1文字のみがアンドゥの対象となる。}
-------------------------- Buffer: foo --------------------------
@end group
@end example

@node 対になる文字列の一括入力
@subsection 対になる文字列の一括入力

@c @samp{「}や@samp{」}が上手く処理されない...。
通常、`「' を入力したら、`」' を後で入力する必要があります。`「' の入
力時点で、対になる文字を自動挿入してくれると打鍵数を減らすことができます
し、同時に入力忘れの防止にもなるでしょう。

@vindex skk-auto-insert-paren
そのために変数 @code{skk-auto-insert-paren} が用意されています。この値を
非 @code{nil} にすると、上記の自動挿入を行います。

@example
@group
------ Buffer: foo ------
彼はこう言った@point{}
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
彼はこう言った「@point{}」
------ Buffer: foo ------
@end group
@end example

@noindent
@c @samp{「}や@samp{」}が上手く処理されない...。
上記のように `「' の入力時点で対となる`」'を自動挿入し、`「'と`」'の間に
ポイントを再配置するので、その位置からかぎかっこに囲まれた文字列を即始め
ることができます。

@vindex skk-auto-paren-string-alist
自動挿入すべきペアの文字列は、変数 @code{skk-auto-paren-string-alist} で
指定します。既定値は下記のようになっています。

@lisp
@group
(("「" . "」") ("『" . "』") ("(" . ")") ("（" . "）") ("@{" . "@}")
 ("｛" . "｝") ("〈" . "〉") ("《" . "》") ("[" . "]") ("［" . "］")
 ("〔" . "〕") ("【" . "】") ("\"" . "\"") ("“" . "”") ("`" . "'"))
@end group
@end lisp

@noindent
これは、ひと言でまとめると、「開き括弧と閉じ括弧とのコンスセルを集めたリ
スト」です。各コンスセルの @code{car} にある文字列を挿入したときに、
@code{cdr} にある文字列が自動挿入されます。
@vindex skk-rom-kana-rule-list
@footnote{このリストの各要素の @code{car} の文字列は、必ず変数
@code{skk-rom-kana-rule-list} の規則によって入力されなければなりません。
例えば、@samp{(} に対する @samp{)} の自動挿入をするには

@lisp
@group
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("(" nil "("))))
@end group
@end lisp

@noindent
のような設定をする必要があります。}
@footnote{既に SKK モードになっているバッファで変数
@code{skk-auto-paren-string-alist} を変更した場合は、@kbd{C-x C-j} もし
くは @kbd{C-x j} を 2 度タイプして @code{skk-mode} もしくは
@code{skk-auto-fill-mode} を起動し直す必要があります。}

キーとなる文字の挿入が行われても、その挿入後のポイントに自動挿入すべき
文字が既に存在している場合には、自動挿入は行われないように設計されてい
ます。

@example
@group
------ Buffer: foo ------
@point{}」
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
「@point{}」
------ Buffer: foo ------

@end group
@end example

対になる文字を複数挿入したい場合は、引数を渡して文字を指定します。

@example
@group

@kbd{C-u 2 [}

------ Buffer: foo ------
「「@point{}」」
------ Buffer: foo ------
@end group
@end example

@vindex yatex-mode
@code{yatex-mode} など、既に同種の機能が付いているモードがあります。その
ようなモードにおいてもこの自動挿入の機能が邪魔になることはないでしょうが、
そのモードにおいてのみこの機能をオフにしたい場合は、該当のモードに入った
ときにコールされるフック変数を利用して設定を行うことができます。

@lisp
@group
(add-hook 'yatex-mode-hook
          #'(lambda ()
              (when skk-auto-insert-paren
                (make-local-variable 'skk-auto-insert-paren)
                (setq skk-auto-insert-paren nil))))
@end group
@end lisp

特定のモードにおいて、自動挿入すべき文字を変更したい場合にも同様にフック
変数を用いて操作できます。

@vindex tex-mode-hook
@lisp
@group
(add-hook 'tex-mode-hook
          #'(lambda ()
              (when skk-auto-insert-paren
                (make-local-variable 'skk-auto-paren-string-alist)
                (setq skk-auto-paren-string-alist
                      (cons '("$" . "$") skk-auto-paren-string-alist)))))
@end group
@end lisp

@noindent
同様に、特定のペアを削除したい場合は、例えば下記のように設定します。
@c @footnote{何故関数 @code{copy-sequence} を使用するのかについては、
@c @w{@ref{数字や記号文字の入力}} を参照してください。}。

@lisp
@group
(add-hook 'tex-mode-hook
          #'(lambda ()
              (when skk-auto-insert-paren
                (make-local-variable 'skk-auto-paren-string-alist)
                (setq skk-auto-paren-string-alist
                      (delete
                       '("$" . "$")
                       (copy-sequence skk-auto-paren-string-alist))))))
@end group
@end lisp

@node ポイントを戻して▽モードへ
@section ポイントを戻して▽モードへ

@cindex 後から▽モードに入る方法
▽モードに入り忘れた場合の▽マークの付け方については、前述しました
@footnote{@xref{後から▽モードに入る方法}}。ここでは、これを簡略化し、一
回の操作で行う方法について説明します。

@kindex M-Q
@kbd{M-Q}
@footnote{ここで @samp{Q} は大文字で入力する必要があります。}とタイプす
ると現在位置の直前の文字列について走査し、同種の文字
@footnote{ひらがな、カタカナ、全角アルファベット、アルファベットの 4 種
類のいずれか。}が続く限り後方にポイントを戻して▽モードに入り、またポイ
ントを元の地点に戻します。
@vindex skk-allow-spaces-newlines-and-tabs
@footnote{後方にポイントを戻す途中で行頭に到達した場合は、更に上の行につ
いて、行末の文字列から同様の走査を行い、必要があれば更にポイントを戻し
ます。こうした「行を超えての走査」をやめるためには、変数
@code{skk-allow-spaces-newlines-and-tabs} の値を @code{nil} に設定しま
す。}

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{M-Q}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

変換開始位置を決定するとき、スペース文字、タブ文字、長音を表わす @samp{ー}
は無条件に無視されます。ただし、ひらがなの場合は @samp{を} が、カタカナ
の場合は @samp{ヲ} が見つかった時点で変換開始位置の走査を止め、▽モードに
入ります。変換開始ポイントを @samp{を}、@samp{ヲ} の直前で止めるのは、たい
ていその直後から単語が始まるからです。

以上は @kbd{M-Q} を引数を与えないで実行した場合です。一方で、@kbd{C-u 5
M-Q} のように引数を渡して実行すると、変換開始位置から現在位置までの文字
数を指定することができます。この場合は文字種別を問わず、与えられた文字数
だけ無条件にポイントを戻します。

@node 文脈に応じた自動モード切り替え
@section 文脈に応じた自動モード切り替え
@cindex 文脈に応じた自動モード切り替え
@cindex @file{context-skk.el}

@file{context-skk.el} は、編集の文脈に応じて自動的に skk のモードをアスキーモー
ドに切り替える等の機能を提供します。

@file{context-skk.el} をロードするには、@file{~/.emacs} に

@lisp
@group
(add-hook 'skk-load-hook
	  (lambda ()
	    (require 'context-skk)))
@end group
@end lisp

と書いてください。

あるプログラミング言語のプログラムを書いているとき、日本語入力の必要があ
るのは一般に、そのプログラミング言語の文字列中かコメント中に限られます。
文字列・コメントの「外」を編集するときは、多くの場合日本語入力は必要あり
ません。
たとえば emacs lisp では、「``〜''」や「;; 〜」といった個所でだけ日本語
入力が必要となります。

現在の文字列・コメントの「外」で編集開始と同時に（skk がオンであれば）
skk の入力モードをアスキーモードに切り替えます。
エコーエリアに

@example
@group
-------------------- Echo Area --------------------
[context-skk] 日本語入力 off
-------------------- Echo Area --------------------
@end group
@end example

と表示され、アスキーモードに切り替わったことが分かります。
これにより、文字列・コメントの「外」での編集を開始するにあたって、日本語
入力が on になっていたために発生する入力誤りとその修正操作を回避すること
ができます。

上記の機能は context-skk-mode というマイナーモードとして実装されており
@kbd{M-x context-skk-mode} でオン／オフを制御できます。
オンの場合、モードラインのメジャーモード名の隣に「;▽」と表示されます。

context-skk にて「プログラミングモード」とみなすメジャーモードは、変数
@code{context-skk-programming-mode} で定義されています。

@node 確定アンドゥ
@section 確定アンドゥ
@cindex 暗黙の確定
@cindex 確定アンドゥ

一番最後に行った変換についての確定を取り消して、再変換を行うことがで
きます。これを@b{「確定アンドゥ」}と呼びます。

例えば、辞書エントリが

@example
こうこう /高校/孝行/航行/
@end example

@noindent
のようになっているとします。

@example
@kbd{K o u k o u @key{SPC}}

@group
------ Buffer: foo ------
▼高校
------ Buffer: foo ------
@end group

@kbd{s u r u}

@group
------ Buffer: foo ------
高校する@point{}
------ Buffer: foo ------
@end group

@kbd{M-x skk-undo-kakutei}

@group
------ Buffer: foo ------
▼孝行@point{}する
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、@samp{高校} の確定について取り消しています。すると、辞書の第
一候補である @samp{高校} をとばして、次候補である @samp{孝行} が現れます。
ここで更に @key{SPC} を押せば次候補である @samp{航行} が現れ、更にもう一
度 @key{SPC} を押せば辞書登録モードに入ります。

この例に見られるように、確定アンドゥは、確定した直後でなくとも有効です。
より正確には、次の新たな確定
@footnote{@kbd{C-j} をタイプして明示的に確定した場合は勿論、暗黙の確定を
行った場合も同様です。}を行うまでは確定に関する情報が保持されている
ので、確定アンドゥすることができます。

また、変換、確定に関連しない文字列は、確定アンドゥを行っても削除されな
いように設計されています。上記の例では、@samp{する} がそのままカレントバッ
ファに残っています。

@defvr {ユーザ変数} skk-undo-kakutei-return-previous-point

この値が 非 @code{nil} であれば確定アンドゥ後に以前の位置にカーソルが戻
ります。

上の例の場合、確定した後のカーソル位置はデフォルトでは @samp{孝行} の直後
のままですが、非 @code{nil} であれば @samp{する} の直後に復帰します。
@end defvr

@node 見出し語関連
@section 見出し語関連

@menu
* 見出し語の補完::
* 見出し語を補完しながら▼モードへ::
* 空白・改行・タブを含んだ見出し語の変換::
* カタカナの見出し語::
@end menu

@node 見出し語の補完
@subsection 見出し語の補完
@cindex 読みの補完
@cindex 見出し語の補完

@kindex @key{TAB}
▽モードで @key{TAB} を押すと、見出し語 (▽モードにおける入力文字列) に
対する補完が行われます。今、@key{TAB} を押す直前に▽モードで入力された文
字列をσと呼ぶことにします。このとき、個人辞書
@footnote{共有辞書は検索されません。それは、共有辞書では一般的に先頭の文
字を共通にする見出し語が多すぎて、望みの補完が行える確率が低いからです。}
の送りなしエントリの中で、先頭がσと一致し長さがσよりも長い見出し語を捜
して、そのような語がもしあれば、σの代わりにその語が表示されます。

見出し語の補完を上手に利用すると、打鍵数を減らすことができます。

@kindex @samp{,}
@kindex @samp{.}
個人辞書では最近更新されたエントリほど上位に来るようになっています
@footnote{@ref{辞書ファイルを指定する変数}}。したがって、▼モードで変換
を行った語の見出し語について、時間的に新しいものから先に補完が行われ
ます。例えば、@samp{斉藤}、@samp{佐藤} の順で変換した後、@samp{さ} をキー
にして見出し語の補完を行うと、最初に @samp{さとう} が、その次に
@samp{さいとう} が補完されます。補完が意図したものでなかったときには
@key{TAB} の直後に @samp{.} (ピリオド) をタイプすると 2 番目の見出し語が
表示されます。以降、同様に @samp{.} を続けてタイプすると、見出し語の候補
が順次表示されます。意図した見出し語を通りすぎたときは @samp{,} (コンマ)
 で前の候補に戻ります。

@example
@kbd{S a t o u @key{SPC} C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group

@kbd{S a}

@group
------ Buffer: foo ------
▽さ
------ Buffer: foo ------
@end group

@key{TAB}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@samp{.}

@end example

@example
@group
@r{@samp{さとう} の次に補完される見出し語は、個人辞書の内容に依存します。}
@end group
@end example

@example
@group
------ Buffer: foo ------
▽さいとう
------ Buffer: foo ------
@end group

@samp{,}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼佐藤
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group
@end example

なお、個人辞書の検索は、見出し語を得るために行われるので、一旦
@key{SPC} を入力して▼モードに入れば普通の変換動作に入ります。

@kindex @key{C-u TAB}
また、2回目以降の補完のときに、@samp{.} の代わりに @key{C-u TAB} を入力
すると、見出し語補完の動作が変化します。具体的には、最初の補完キーを捨て
て最後に補完された語を補完キーとし、新しい補完を開始します。つまり上記の
例では @samp{さ} に対し、最後に補完された語は、@samp{さとう} なので、以
後の補完は、@samp{さとう} を含む語 (例えば、@samp{さとうせんせい}など)
について行われます。


@node 見出し語を補完しながら▼モードへ
@subsection 見出し語を補完しながら▼モードへ
@cindex 見出し語の補完
@cindex 読みの補完
@kindex M-@key{SPC}

前節で見出し語の補完について述べました。本節では、見出し語の補完動作を行
った後、@key{SPC} を入力し、▼モードに入るまでの動作を一回の操作で行
う方法について説明します。

やり方は簡単。@key{TAB}・@key{SPC} と打鍵していたところを、
@kbd{M-@key{SPC}} に換えると、補完した上で変換を開始します。

この方法によると、補完される見出し語があらかじめ分かっている状況では、キー
入力を一回分省略できるので、長い見出し語の専門用語を連続して入力する場合
などに威力を発揮します。

@example
@group
@kbd{K a s i t a n n p o s e k i n i n n}

@group
------ Buffer: foo ------
▽かしたんぽせきにん
------ Buffer: foo ------
@end group

@key{SPC}, @key{RET}

@group
------ Buffer: foo ------
瑕疵担保責任
------ Buffer: foo ------
@end group

@kbd{K a}

@group
------ Buffer: foo ------
▽か
------ Buffer: foo ------
@end group

@kbd{M-@key{SPC}}

@group
------ Buffer: foo ------
▼瑕疵担保責任
------ Buffer: foo ------
@end group

@end group
@end example

@node 空白・改行・タブを含んだ見出し語の変換
@subsection 空白・改行・タブを含んだ見出し語の変換

以下のようにオートフィルモードで折り返された文字列に対し、折り返された状
態のまま変換を行う方法があります。

@example
@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムをさ
くせいしました。@point{}
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 10 C-b Q}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽@point{}さ
くせいしました。
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 5 C-f}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽さ
くせい@point{}しました。
---------------- Buffer: foo ------------------
@end group

@key{SPC}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▼作成@point{}しました。
---------------- Buffer: foo ------------------
@end group
@end example

ここでは改行を越えて見出し語を探し、変換する例を示しました。同様に、空白、
タブ文字を中間に含む文字列に対しても変換を行うことができます。

@table @code
@item skk-allow-spaces-newlines-and-tabs
@vindex skk-allow-spaces-newlines-and-tabs

この変数を @code{nil} に設定すると、本節で説明したような 2 行以上にま
たがる文字列に対する変換を禁止します。
@end table

@node カタカナの見出し語
@subsection カタカナの見出し語
@kindex C-u @key{SPC}

@kbd{q} によりかなモード、カナモードを度々切り替えて入力を続けていると、
カナモードで誤って▼モードに入ってしまうことがあります。そのため、カナ
モードで▼モードに入った場合、まず見出し語をひらがなに変換してから、辞
書の検索に入るよう設計されています。また、この場合の送りあり変換での送
り仮名は、カタカナになります。

@node 送り仮名関連
@section 送り仮名関連

@menu
* 送り仮名の厳密なマッチ::
* 送り仮名の優先的なマッチ::
* 送り仮名の自動処理::
* 送りあり変換の変換開始のタイミング::
@end menu

@node 送り仮名の厳密なマッチ
@subsection 送り仮名の厳密なマッチ
@vindex minibuffer-exit-hook
@vindex minibuffer-setup-hook

今、個人辞書に

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
という送りありエントリがあると仮定します。

ここで @kbd{O o K i i @key{SPC}} と入力した場合、普通は @samp{大きい} と
@samp{多きい} という 2 通りの候補が出力されますが、このうち @samp{多きい}
は現代の日本語として正しくありません。このような場合に、出力される候補を
正しい表現のみに絞りこむ方法について、説明します。

@table @code
@item skk-henkan-okuri-strictly
@vindex skk-henkan-okuri-strictly
@vindex skk-process-okuri-early

この変数の値を 非 @code{nil} に設定すると、見出し語がマッチするかどう
かのチェックの上に、送り仮名がマッチするかどうかのチェックが行われま
す。結果として送り仮名がマッチしない候補は出力されません。上記の例では、
送り仮名 @samp{き} がマッチする @samp{大きい} は出力されますが、
@samp{多きい} は出力されません
@footnote{この機能は、変数 @code{skk-process-okuri-early} の値を非
@code{nil} に設定した状態と共存できません。この理由を知りたい場合は
@ref{送りあり変換の変換開始のタイミング}を参照してください。}。

個人辞書の送りありエントリが充実していれば、標準の設定よりも候補が絞り込
まれるので変換効率がアップしますが、さもなければ、すぐに辞書登録モードに
入ってしまうため逆に不便になります。
@end table

変数 @code{skk-henkan-okuri-strictly} の値を 非 @code{nil} にすると、
辞書登録モードに入っても送り仮名のマッチが厳密に行われます。これは辞
書登録の際希望する候補を得るためには障害となります。そのような障害を避
けるためには、下記のようにフック変数を設定します。これにより、辞書登録
時だけは、一時的に送り仮名の厳密なマッチをしないようになります
@footnote{実は変数 @code{skk-henkan-okuri-strictly} の値は辞書バッファで
参照されるので、ミニバッファのバッファローカル値を変更してもうまくいきま
せん。将来のバージョンでは、これを改良し、辞書バッファでの動作に影響する
ユーザー変数をバッファローカル化できるようにする予定です。
@w{@xref{最新情報}.}}。

@lisp
@group
(add-hook 'minibuffer-setup-hook
          #'(lambda ()
              (when (and (boundp 'skk-henkan-okuri-strictly)
                         skk-henkan-okuri-strictly
                         (not (eq last-command 'skk-purge-jisyo)))
                (setq skk-henkan-okuri-strictly nil)
                (put 'skk-henkan-okuri-strictly 'temporary-nil t))))

@end group
@group
(add-hook 'minibuffer-exit-hook
          #'(lambda ()
              (when (and (get 'skk-henkan-okuri-strictly 'temporary-nil)
                         (<= (minibuffer-depth) 1))
                (put 'skk-henkan-okuri-strictly 'temporary-nil nil)
                (setq skk-henkan-okuri-strictly t))))
@end group
@end lisp

@node 送り仮名の優先的なマッチ
@subsection 送り仮名の優先的なマッチ

@ref{送り仮名の厳密なマッチ} では、見出し語と送り仮名が一致した場合のみ
候補を表示します。ここでは、その条件を緩めて優先的に表示する方法を紹介し
ます@footnote{@samp{大く}などの候補は鬱陶しいが、すぐに単語登録に入って
しまうのも嫌な人におすすめです。}。

今、個人辞書に

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
という送りありエントリがあると仮定します。

ここで @kbd{O o K i i @key{SPC}} と入力した場合、普通は @samp{大きい} と
@samp{多きい} という 2 通りの候補が出力されますが、このうち @samp{多きい}
は現代の日本語として正しくありません。このような場合に、出力される候補を
正しい表現が優先的にする設定を紹介します。

@table @code
@item skk-henkan-strict-okuri-precedence
@vindex skk-henkan-okuri-strictly
@vindex skk-process-okuri-early

この変数の値を 非 @code{nil} に設定すると、見出し語と送り仮名がマッチ
した候補を優先して表示します。

上記の例では @samp{▽おお*く} を変換したとき、まず @samp{多く} を出力し、
次に @samp{大く} を出力します。

この変数の値が 非 @code{nil} の時は、変数
@code{skk-process-okuri-early} の値は @code{nil} でなければなりません
@footnote{理由を知りたい場合は、@ref{送りあり変換の変換開始のタイミング}
を参照してください。}。また変数 @code{skk-henkan-okuri-strictly} が
非 @code{nil} のときは、この変数は無視されます。
@end table

@node 送り仮名の自動処理
@subsection 送り仮名の自動処理

@menu
* どのように変換されるか::
* 辞書登録の際に注意すべきこと::
@end menu

@node どのように変換されるか
@subsubsection どのように変換されるか

@table @code
@item skk-auto-okuri-process
@vindex skk-auto-okuri-process

この変数の値を 非 @code{nil} に設定すると、送り仮名の自動処理が行わ
れます。
@end table

例えば、@kbd{T a t i a g e r u @key{SPC}} と入力した場合を考えます。

@samp{たちあげる} という見出し語に対し、送り仮名を明示していないので、ま
ず送りなし変換として扱い辞書を検索します。このときは、通常の変換同様、個
人辞書及び指定された共有辞書他を検索します。その後、送りありの検索に移り
ます。ここでは個人辞書のみを検索の対象とします。見出し語を最後尾から1文
字づつ切り詰め、「切り詰めの結果残った文字列」と、「切り捨てられた先頭の
文字のローマ字プレフィックス」を連結した文字列を送りあり変換の見出し語と
して、検索します。

この例において検索される見出し語の変化を追うと、

@example
@samp{たちあげる} @result{} @samp{たちあげr} @result{} @samp{たちあg}
@result{} @samp{たちa} @result{} @samp{たt}
@end example

@noindent
のようになります。仮に個人辞書エントリが、

@example
@group
たちあg /立ち上/[げ/立ち上/]/[が/立ち上/]/
たt /建/断/経/立/[つ/建/断/経/立/]/[ち/建/断/経/立/]/[て/経/立/建/]/
@end group
@end example

@noindent
の 2 つのエントリを含むとすると、見出し語を後方から順に切り詰める過程で
@samp{たちあg} と @samp{たt} の 2 つの見出し語の検索時にこれらの辞書エン
トリがマッチします。

@noindent
次に、マッチしたエントリの各候補に対し、切り捨てられた先頭の文字を送り仮
名として取るかどうかをチェックします。この判断には、個人辞書の送り仮名ブロッ
ク部分
@footnote{@ref{送りありエントリのブロック形式}.}を利用します。

@samp{たちあg} の場合の送り仮名チェックの対象は、切り捨てられた最初の文
字の @samp{げ} です。個人辞書に

@example
[げ/立ち上/]
@end example

@noindent
の部分があることから、送り仮名として取るべきと判断します。また、@samp{た
t} の場合の送り仮名チェックの対象は、@samp{ち} です。個人辞書に

@example
[ち/建/断/経/立/]
@end example

@noindent
の部分があることから、送り仮名として取るべきと判断します。

@noindent
こうして、送り仮名がマッチする候補が @samp{立ち上}、@samp{建}、@samp{断}、
@samp{経}、@samp{立} の 5 つに絞られます。これらは文字列の長さ順に昇順に
ソートされ
@footnote{長さ順にソートするのは、変換された部分がより長い候補を先順位
として出力するためです。}、それぞれの候補と該当の見出し語から切り捨てら
れた文字列と連結したもの
@footnote{@samp{該当の見出し語から切り捨てられた文字列} を送り仮名とみな
して処理しています。}を、送り仮名の自動処理の最終候補として返します。上
記の例は、@samp{立ち上げる}、@samp{建ちあげる}、@samp{断ちあげる}、
@samp{経ちあげる}、@samp{立ちあげる} の 5 つが最終候補になります。

ここで、自動送り機能の長所を考えてみると、

@itemize @bullet
@item 送り仮名の最初のローマ字表現を大文字で始める必要がない。
@item 送り仮名を正確に思い出せない場合に送り仮名を指定しなくとも変換でき
る。
@end itemize

などがあります。一方短所としては、

@itemize @bullet
@item 意図しない変換をされる割合が増える。
@item 個人辞書の送りありエントリが貧弱な場合は、自動処理ができない可能性
が高い。
@end itemize

などが考えられます。変数 @code{skk-auto-okuri-process} の値を非
@code{nil} に設定しても、従来通りの送りあり変換も同時にできますから、
一度この機能を試してみることをお勧めします
@footnote{専ら補完的に自動送り処理を利用するのであれば、
@code{(skk-okuri-search)} を @code{skk-search-prog-list} の最後にもってく
るという手もあります。}。

@node 辞書登録の際に注意すべきこと
@subsubsection 辞書登録の際に注意すべきこと

送り仮名の自動処理を行っている場合@footnote{変数
@code{skk-auto-okuri-process} の値を非 @code{nil} に設定している。}に
は、辞書登録の際に注意すべきことがあります。

個人辞書に見出し語 @samp{わたs} についてのエントリが全くない場合、あるい
は個人辞書のエントリが

@example
わたs /渡/[し/渡/]/
@end example

@noindent
のような送り仮名のブロックを持たない場合を考えてみます。ここで、@kbd{W a
t a s i t a @key{SPC}}と入力すると、送り仮名の自動処理においては送り仮名
がマッチしないので、候補が見つからずに辞書登録モードに入ります。

@example
@group
@kbd{W a t a s i t a @key{SPC}}

------ Buffer: foo ------
▼わたした
------ Buffer: foo ------

------ Minibuffer -------
[辞書登録] わたした@point{}
------ Minibuffer -------
@end group
@end example

@noindent
辞書登録モードで @kbd{W a t a S i t a @key{RET}} と送り仮名を明示的に入
力し、@samp{渡した} と変換して登録したとします。この場合、登録する語の最
後が平仮名で終わるので、その最後の平仮名の文字列 (上記の例では、@samp{し
た}) が見出し語の最後と一致するかを調べます。一致する場合には、辞書の登
録を送りありエントリとして行うのかどうかの確認を求めます。

@example
@group
@kbd{W a t a S i t a}
------ Minibuffer -------
[辞書登録] わたした 渡した@point{}
------ Minibuffer -------
@end group
@group

@key{RET}

-------------------------- Echo Area --------------------------
Shall I register this as okuri-ari word: わたs /渡/ ? (y or n)
-------------------------- Echo Area --------------------------
@end group
@end example

@noindent
この確認に対し、@samp{y} と回答した場合は、

@example
わたs /渡/[し/渡/]/
@end example

@noindent
という辞書エントリが個人辞書の送りありエントリに書き込まれます。一方
@samp{n} と回答した場合は、個人辞書の送りなしエントリに

@example
わたした /渡した/
@end example

@noindent
というエントリが書き込まれます。本例の場合は、@samp{y} と回答するのが正
解です。

@table @code
@item skk-kana-rom-vector
@vindex skk-kana-rom-vector
@c XXX この変数は定数になった。

この変数は、送り仮名部分をローマ字プレフィックスに分解する際に、参照され
ます。
@end table

変数 @code{skk-kana-rom-vector} の既定値は以下のようになっています。

@example
@group
["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
 "k" "g" "k" "g" "s" "z" "s" "j" "s" "z" "s" "z" "s" "z" "t" "d"
 "t" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
 "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
 "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
 "x" "w" "n"]
@end group
@end example

このベクトルは、それぞれ下記のかな文字をそのローマ字プレフィックスで現し
たものです。

@example
@group
ぁ  あ  ぃ  い  ぅ  う  ぇ  え  ぉ  お  か  が  き  ぎ  く  ぐ
け  げ  こ  ご  さ  ざ  し  じ  す  ず  せ  ぜ  そ  ぞ  た  だ
ち  ぢ  っ  つ  づ  て  で  と  ど  な  に  ぬ  ね  の  は  ば
ぱ  ひ  び  ぴ  ふ  ぶ  ぷ  へ  べ  ぺ  ほ  ぼ  ぽ  ま  み  む
め  も  ゃ  や  ゅ  ゆ  ょ  よ  ら  り  る  れ  ろ  ゎ  わ  ゐ
ゑ  を  ん
@end group
@end example

@noindent
これに従うと、見出し語中の送り仮名がローマ字プレフィックスに分解される際、
例えば @samp{じ} は @samp{j} に、@samp{ち} は @samp{t} に、@samp{ふ} は
@samp{h} に、それぞれ分解されます。これらをそれぞれ @samp{z}、@samp{c}、
@samp{f} に変更することもできます。それには変数
@code{skk-kana-rom-vector} の該当部分を "z"、"c"、"f" に変更します。

@lisp
@group
(setq skk-rom-kana-vector
      ["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
       "k" "g" "k" "g" "s" "z" "s" "z" "s" "z" "s" "z" "s" "z" "t" "d"
       "c" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
       "p" "h" "b" "p" "f" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
       "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
       "x" "w" "n"])
@end group
@end lisp

次にもうひとつ例を挙げます。 @samp{ありがさつき} に対し @samp{有賀さつき}
を登録したい場合は、上記と同様に辞書登録をし、

@example
@group
Shall I register this as okuri-ari entry: ありがs /有賀/ ? (y or n)
@end group
@end example

@noindent
の確認に対し @samp{n} と回答します。この結果、個人辞書の送りなしエントリ
には、

@example
ありがさつき /有賀さつき/
@end example

@noindent
というエントリが書き込まれます。

@node 送りあり変換の変換開始のタイミング
@subsection 送りあり変換の変換開始のタイミング
@kindex C-x C-j
@kindex C-x j

@table @code
@item skk-process-okuri-early
@vindex skk-process-okuri-early
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-kakutei-early

この変数の値を 非 @code{nil} に設定すると、送りあり変換の変換開始のタ
イミングが早められます。つまり、送り仮名のローマ字プレフィックスの入力
時点で変換を開始します。

@example
@group
@kbd{U g o K}

------ Buffer: foo ------
▼動k
------ Buffer: foo ------
@end group
@end example

送り仮名が分からないまま変換しているため、個人辞書が送り仮名に対応した形に
成長しません。つまり @samp{うごk /動/} のような形態のままとなります。た
だし、

@example
@group
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
@end group
@end example

@noindent
のようなエントリが既に個人辞書にある場合、それを破壊することはありません
@footnote{@ref{辞書の形式}を参照してください。}。

このユーザーオプションを 非 @code{nil} に設定して SKK モードを起動する
と、両立できないオプションである下記オプションは自動的に @code{nil} に
設定されます。

@example
@group
@code{skk-kakutei-early}, @c ここに footnote を持ってきても脚注が表われない...
@code{skk-auto-okuri-process}, @code{skk-henkan-okuri-strictly}
@end group
@end example

既に SKK モードに入った後で この変数の設定を変更した場合は、カレントバッ
ファで @kbd{C-x C-j} もしくは @kbd{C-x j} を 2 回タイプして SKK モードを
起動し直すことで、これらの変数間の衝突を調整します。

@display
@xref{暗黙の確定のタイミング, , skk-kakutei-early}.
@xref{送り仮名の自動処理, , skk-auto-okuri-process}.
@xref{送り仮名の厳密なマッチ, , skk-henkan-okuri-strictly}.
@end display
@end table

@node 変換の学習
@section 変換の学習
@cindex @file{skk-study.el}
@vindex skk-study-associates-number
@vindex skk-study-search-times

@file{skk-study.el} は、ある語 A を確定した場合に、A 及びその見出し
語 A' に対して、直前に変換した語 B とその見出し語 B' を関連語として登
録しておき、再度見出し語 A' の変換を行ったときに、B 及び B' のペアが直
前の何回かに確定した語の中に見つかれば、A を優先して出力する単純な学習
効果を提供するプログラムです。

@file{~/.skk} に @code{(require 'skk-study)} と書いて DDSKK を起動して下
さい。以降変換についての学習を始めます。

例えば、@samp{梅雨には雨が降る} と変換した場合、
@enumerate

@item
@samp{雨} (@samp{あめ}) の関連語は @samp{梅雨} @w{(@samp{つゆ})}、

@item
@samp{降る} (@samp{ふr}) の関連語は @samp{雨} @w{(@samp{あめ})}、

@end enumerate
@noindent
という風に直前に確定した語を関連語として、語と語の関連性を学習します。

ここで続けて、@samp{傘を振る} と変換すると、個人辞書がアップデートされ
てしまい、見出し語 @samp{ふr} の第一候補は @samp{振る} になってしまい
ます。

しかし、更に続けて @kbd{Ame @key{SPC} gaHuRu} と type すると、
@kbd{HuRu} @w{(@samp{ふr})} に対して @samp{雨} @w{(@samp{あめ})} が関
連語になっているため、@samp{ふr} と対で記憶されている @samp{降る} に変
換されるというわけです。

では、またここで @samp{傘を振る} と変換し、個人辞書の第一候補が
@samp{振る} になった状態で、

@display
@kbd{Ame @key{SPC} gaTairyou @key{SPC} niHuRu}
@end display

@noindent
と変換すれば @kbd{ふr} はどう変換されるでしょうか?  今度は @samp{雨} 
@w{(@samp{あめ})} と @kbd{ふr} の間に @samp{大量} @w{(@samp{たいりょう})}
が入っています @footnote{@samp{ふr} に対して @samp{大量}
@w{(@samp{たいりょう})} が関連語として保存されます。勿論
@w{(@samp{ふr})} に対する @samp{雨} @w{(@samp{あめ})} の学習もまだ生き
ています。}  実はちゃんと

@display
@samp{雨が大量に降る}
@end display

@noindent
と変換されます。何故なら @w{(@samp{ふr})} の関連語を探す際、
@code{skk-study-search-times} @footnote{デフォルト値は 5 です。} に
指定された回数分だけ遡って、以前に確定した語の中に関連語がないか探すの
です。従って、この場合だと、2 つ前の確定情報を探した際に @samp{雨}
@w{(@samp{あめ})} 見つけ、これを関連語として、@w{(@samp{ふr})} の値を
決めようとするのです。

@file{skk-study.el} に関するその他のオプションを説明します。

@table @code
@item skk-study-max-distance
@vindex skk-study-max-distance

この変数には integer を指定します。直前に確定したポイントと今回の変換ポ
イントがこの距離以上離れていると学習データを蓄積しないようにします。
この変数は、必ずしも文章がバッファの @code{point-min} か
ら @code{point-max} へ流れるように書かれるものではなく、ポイントを前に戻
したり後へ移動したりして書かれることを想定しています。
この変数に integer を設定すると、直前の変換よりも前のポイントで変換した
場合に学習データを蓄積しないようにします。この変数に @code{nil} を指定す
ると直前に確定したポイントとの距離を考慮せずに学習します。この変数のデフ
ォルト値は 30 です。

なお、この変数の値にかかわらず、直前の変換バッファと現在変換を行っている
バッファが異なる場合は学習データを蓄積しません。

@item skk-study-first-candidate
@vindex skk-study-first-candidate

この変数が @code{non-nil} であれば、第一候補
で確定した際も学習します。@code{nil} であれば、第一候補で確定したとき
のみ学習データを蓄積しません。学習データをできるだけ小さくしたい場合、
この変数を @code{nil} にすると効果があるかもしれません。
この変数のデフォルト値は @code{t} です。

@item skk-study-file
@vindex skk-study-file

学習結果を保存するファイル名です。
この変数のデフォルト値は @file{~/.skk-study} です。

@item skk-study-backup-file
@vindex skk-study-backup-file
@file{~/.skk-study} のバックアップファイルです。
この変数のデフォルト値は @file{~/.skk-study.BAK} です。

@item skk-study-sort-saving
@vindex skk-study-sort-saving

学習データのデータ構造に関するものです。この変数の値が @code{non-nil} で
あれば学習結果をソートしてセーブします。この変数が影響を及ぼすのは学習デ
ータの単なる見映えの問題だけです。
この変数のデフォルト値は @code{nil} です。

@item skk-study-check-alist-format
@vindex skk-study-check-alist-format

学習データのデータ構造に関するものです。この変数の値が  @code{non-nil} で
あれば、学習結果の読み込み時に連想リストのフォーマットをチェックします。
これは主に debug の目的で使います。
この変数のデフォルト値は @code{nil} です。

@end table

@node 候補の絞り込み
@section 候補の絞り込み
@cindex @file{skk-hint.el}

@file{skk-hint.el} は、２つの読みの積集合みたいなものを取ることによって
候補の絞り込みを行うプログラムです。
インストールは @file{~/.skk} に以下を記入します。

@lisp
(require 'skk-hint)
@end lisp

例えば、読み ``かんどう'' に対する変換は L 辞書によると

@example
感動、勘当、完動、間道、官道、貫道
@end example

と複数の候補があります。

一方、これに ``あいだ'' という「他の読み」(ヒント)を与えると候補は
``間道'' に一意に決まります。
ヒントは @key{;} に続けて入力します。

@example
@kbd{K a n d o u ; a i d a}

※ @key{;} 自体は表示されません。

----- Buffer: foo -----
▽かんどうあいだ
----- Buffer: foo -----

@kbd{SPC}

----- Buffer: foo -----
▼間道
----- Buffer: foo -----
@end example

@file{skk-hint.el} は、２つの読みの厳密な積集合を取っているわけではなく、
通常の変換候補のなかでヒントとして与えられた読みを含んだ漢字を持つものに
候補を絞ります。この実例として ``感動'' と ``感圧'' を挙げます。

@example
@kbd{K a n d o u ; k a n n a t u}

----- Buffer: foo -----
▽かんどうかんあつ
----- Buffer: foo -----

@kbd{SPC}

----- Buffer: foo -----
▼感動
----- Buffer: foo -----
@end example

@file{skk-hint.el} は単漢字の候補がたくさんある場合に、そこから候補を絞
りこむ手段としても非常に有効です。例えば

@example
▽わ
@end example

を変換すると、輪、環、話、和、羽、…と大量に候補が出てきます。
この中から ``和'' を選びたいとします。普通に変換していても
そのうち ``和'' が表示されますが、これを @kbd{W a ; h e i w a} と入力し
変換すると、「▼へいわ」の候補である「平和」に含まれる

@example
▼和
@end example

が唯一の候補となります。

@example
@kbd{W a ; h e i w a}

----- Buffer: foo -----
▽わへいわ
----- Buffer: foo -----

@kbd{SPC}

----- Buffer: foo -----
▼和
----- Buffer: foo -----
@end example

@node 単漢字変換
@section 単漢字変換
@cindex @file{skk-tankan.el}

@file{skk-tankan.el} は、単漢字変換機能を提供するプログラムです。単漢字
変換を行う際、▽モードの最後の文字として @kbd{@@} を付加してから変換を開
始すると、候補を総画数の昇順でソートして表示します。

@menu
* 検索キーの設定::
* 辞書の設定::
* 使用方法::
@end menu

@node 検索キーの設定
@subsection 検索キーの設定

デフォルトの検索キーは @kbd{@@} です。しかし、DDSKK の標準設定では
キー @kbd{@@} は関数 @code{skk-today} に割り当てられています（
変数 @code{skk-rom-kana-base-rule-list}、@ref{今日の日付の入力}.）。

ここでは、キー @kbd{@@} を @code{skk-today} ではなく、単漢字変換の検索キ
ーとして使用するために @file{~/.skk} で次の設定を行います
@footnote{@file{skk-tankan.el} を使おうとして「たん▼平成19年9月19日(水)
」となってしまう方は、@code{skk-rom-kana-rule-list} の設定を見直しましょ
う。}。

@lisp
@group
;; @@ を入力できるようにする
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
      '(("@@" nil "@@"))))
@end group
@end lisp

@vindex skk-tankan-search-key
なお、単漢字変換の検索キーは、変数 @code{skk-tankan-search-key} で変更す
ることが可能です。
以下に検索キーを @kbd{!} へと変更する例を挙げます。

@lisp
(setq skk-tankan-search-key ?!)
@end lisp

@node 辞書の設定
@subsection 辞書の設定

@findex skk-tankan-search
次に、辞書の設定を行います。以下の形式で
変数 @code{skk-search-prog-list} に要素を追加します。

@lisp
(skk-tankan-search 'function . args) 
@end lisp

ただし、@b{「確定変換」}を併用する場合は、@code{skk-search-prog-list} の
先頭の要素は @code{skk-search-kakutei-jisyo-file} であることが必要です。
@b{「確定変換」}を使用しない場合は、 @code{skk-search-prog-list} の要素
の先頭が @code{skk-tankan-search} でも大丈夫です。

@xref{辞書に関する設定}.

@xref{辞書検索の設定の具体例}.

以下に、具体例を挙げます。

@lisp
@group
;; skk-search-prog-list の２番目の要素に skk-tankan-search を追加する
(setq skk-search-prog-list
      (cons (car skk-search-prog-list)
	       (cons '(skk-tankan-search 'skk-search-jisyo-file
				         skk-large-jisyo 10000)
		     (cdr skk-search-prog-list))))
@end group
@end lisp

@node 使用方法
@subsection 使用方法

▽モードの最後の文字に @kbd{@@} を付加してから変換を開始してください。
以下、少し冗長ですが実行例を挙げます。

@example
T a n @@

----- Buffer: foo -----
▽たん@@@point{}
----- Buffer: foo -----

@kbd{SPC}

----- Buffer: foo -----
▼丹@point{}
----- Buffer: foo -----

----- Echo Area -----
4画(丶部3画)
----- Echo Area -----

@kbd{SPC}

----- Buffer: foo -----
▼反@point{}
----- Buffer: foo -----

----- Echo Area -----
4画(又部2画)
----- Echo Area -----

@kbd{SPC}

----- Buffer: foo -----
▼旦@point{}
----- Buffer: foo -----

----- Echo Area -----
5画(日部1画)
----- Echo Area -----

@kbd{SPC}

----- Buffer: foo -----
▼但@point{}
----- Buffer: foo -----

----- Echo Area -----
7画(人部5画)
----- Echo Area -----

@kbd{SPC}

----- Buffer: foo -----
▼@point{}
----- Buffer: foo -----

----- Buffer: *候補* -----
A:坦;8画(土部5画)
S:担;8画(手部5画)
D:単;9画(十部7画)
F:彖;9画(彑部6画)
J:炭;9画(火部5画)
K:眈;9画(目部4画)
L:胆;9画(肉部5画)
[残り 50+++++]
----- Buffer: *候補* -----
@end example

以上のとおり、総画数の昇順でソートされた候補が次々に表示されます。

@node  ▽モードにおける動的補完
@section ▽モードにおける動的補完
@vindex skk-dcomp-activate
@cindex @file{skk-dcomp.el}

▽モードでの見出し語入力において、MS Excel のセル入力の自動補完 (同じ列
に既に入力している文字列があったときにそれを参照して補完しようとする機能)
と類似の機能を提供します。この機能を以下「動的補完」と呼びます
@footnote{文字入力以外のキー操作を必要とせずに自動的に補完し、かつ文字入
力を続けると、そこから更に補完をします。}。

この機能を利用するには @file{~/.emacs} もしくは @file{~/.skk} に下記の式を書
きましょう。

@lisp
(setq skk-dcomp-activate t)
@end lisp

▽モードに入り見出し語を入力すると、文字入力に必要なキー操作を行う毎に、
個人辞書を自動的に検索し、見出し語を補完します。下記のように動作します
@kbd{Ho} の入力に対し、@samp{ほんとう}が補完されるかどうかは個人辞書のエ
ントリの順番次第 (変換順に降順に並んでいる) ですので、個人の環境により異
なるはずです。@point{} はポイント位置を表します。

@example
@group

@kbd{Ho}

---------------- Buffer: foo ------------------
▽ほ@point{}んとう
---------------- Buffer: foo ------------------

@end group
@end example

face が使える環境では、@samp{んとう}の部分のみ異なる face で表示され、動
的補完により補完された部分であることを示します。

自動的に補完された見出し語が、自分の意図したものであれば @key{TAB} を押
すことでポイント位置を動かし、補完された見出し語を選択することができます。

@example
@group
@key{TAB}

---------------- Buffer: foo ------------------
▽ほんとう@point{}
---------------- Buffer: foo ------------------
@end group
@end example

この状態から @key{SPC} を押して変換するなり、@kbd{q} を押してカタカナに
するなり、DDSKK 本来の動作を何でも行うことができます。

補完された見出し語が自分の意図したものでない場合は、かまわず次の入力をし
て下さい。補完された部分を無視したかのように動作します。

@example
@group

@kbd{Ho}

---------------- Buffer: foo ------------------
▽ほ@point{}んとう
---------------- Buffer: foo ------------------

@kbd{ka}

---------------- Buffer: foo ------------------
▽ほか@point{}ん
---------------- Buffer: foo ------------------

@end group
@end example

補完されない状態が自分の意図したものである場合も、補完された部分を単に無
視するだけで OK です。下記の例では、@samp{ほ}を見出し語とした変換を行っ
ています。

@example
@group

@kbd{Ho}

---------------- Buffer: foo ------------------
▽ほ@point{}んとう
---------------- Buffer: foo ------------------

@key{SPC}

---------------- Buffer: foo ------------------
▼保
---------------- Buffer: foo ------------------
@end group
@end example

補完された状態から @key{BS} を押すと、消された補完前の見出し語から再度補
完動作を行います。

@example
@group

@kbd{Ho}

---------------- Buffer: foo ------------------
▽ほ@point{}んとう
---------------- Buffer: foo ------------------

@kbd{ka}

---------------- Buffer: foo ------------------
▽ほか@point{}ん
---------------- Buffer: foo ------------------

@key{BS}

---------------- Buffer: foo ------------------
▽ほ@point{}んとう
---------------- Buffer: foo ------------------
@end group
@end example

動的補完は、個人辞書のみを参照して行われる仕様になっていますので、個人辞
書にない見出し語の補完は行われません。

また、動的補完は、送りなし変換の場合しか行われません。

@file{skk-dcomp.el} を load した後に、動的補完の機能を止めたかったら、下
記の式を評価しましょう。

@lisp
(setq skk-dcomp-activate nil)
@end lisp

@defvr {ユーザ変数} skk-dcomp-face

この変数の値はフェイスであり、このフェイスによって動的に補完された部分が
表示されます。標準では、``DarkKhaki'' を用います。

@end defvr

@defvr {ユーザ変数} skk-dcomp-show-multiple

Non-nil であれば、動的補完の候補をインラインに複数表示します@footnote{現
在は候補群の右側1カラムのフェイスがデフォルトに戻る、という制約がありま
す。}。

@kindex @key{TAB}
@kindex @samp{,}
@kindex @samp{.}
候補の選択には @key{TAB} を押します。また、@ref{見出し語の補完} と同様に
@samp{.} (ピリオド) と @samp{,} (コンマ) も利用できます。

@end defvr

@defvr {ユーザ変数} skk-dcomp-show-multiple-rows

動的補完の候補を複数表示する場合の表示数。標準は 7。

@end defvr

@defvr {ユーザ変数} skk-dcomp-multiple-face

動的補完の複数表示群のフェイス

@end defvr

@defvr {ユーザ変数} skk-dcomp-multiple-trailing-face

動的補完の複数表示郡の補完部分のフェイス

@end defvr

@defvr {ユーザ変数} skk-dcomp-multiple-selected-face

動的補完の複数表示郡の選択対象のフェイス

@end defvr

@node 自動変換開始
@section 自動変換開始

▽モードで見出し語の入力中に、単語や文節の区切りとなるような文字を打鍵す
ると、▽マークからポイントの直前の文字までを見出し語とし
@footnote{最後に入力された文字は見出し語には含まれません。}、@key{SPC}
を打鍵することなく自動的に変換を開始し、▼モードに入るようになっています
@footnote{某メーカーの MS-DOS 上の FEP の仕様を参考にしています。}。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@group

@kbd{w o}
------ Buffer: foo ------
▼漢字を
------ Buffer: foo ------
@end group
@end example

@vindex skk-auto-okuri-process
変数 @code{skk-auto-okuri-process} の値を非 @code{nil} に設定して 送り
仮名の自動処理 (@pxref{送り仮名の自動処理}) を行っている場合は、以下
のような変換も可能です。ただし、個人辞書に @samp{できr /出来/[る/出来/]/}
というようなエントリがあると仮定します。

@example
@kbd{D e k i r u n n d e s u}

@group
------ Buffer: foo ------
▽できるんです
------ Buffer: foo ------
@end group
@group

@kbd{.}
------ Buffer: foo ------
▼出来るんです。
------ Buffer: foo ------
@end group
@end example

@table @code
@item skk-auto-start-henkan-keyword-list
@vindex skk-auto-start-henkan-keyword-list

この変数の値は、単語や文節の区切りとなるような文字列のリストです。
既定値は以下のようになっています。

@lisp
@group
("を" "、" "。" "．" "，" "？" "」" "！" "；" "：" ")" ";"
 ":" "）" "”" "】" "』" "》" "〉" "｝" "］" "〕" "@}"
 "]" "?" "." "," "!" )
@end group
@end lisp

@item skk-auto-start-henkan

この変数の値を @code{nil} に設定すると、本節で説明した自動変換開始機能
を無効にします。
@end table

@node 特殊変換
@section 特殊変換

@menu
* 数値変換::                    数を含む文字列の変換。
* アスキー文字を見出し語とした変換::  アスキー文字を使った省略形からの変換。
* 今日の日付の入力::            今日の日付を一発入力。
* プログラム実行変換::          Emacs Lisp プログラムを使った変換。
@end menu

@node 数値変換
@subsection 数値変換
@cindex #0
@cindex #1
@cindex #2
@cindex #3
@cindex #4
@cindex #5
@cindex #9
@cindex 数をパラメータとする語の変換
@cindex 数値再変換

@samp{第１２回} というような表現において、数字の部分を @samp{#} で置きか
えてみると、@samp{第#回} となります。ここで、@samp{#} の部分にはあらゆる
整数が代入できます。のみならず、例えば @samp{第12回}、@samp{第一二回}、
@samp{第十二回} など、様々な形式があてはめられます。

そこで、@samp{#} をパラメータ (媒介変数) と考えて、@samp{第#回} という文
字列を操作するというのが、DDSKK における数値変換の基本的な発想です。

辞書のエントリの例によって具体的に説明します。SKK の L 辞書には、次のよ
うなエントリがあります。

@example
だい#かい /第#1回/第#0回/第#2回/第 #0 回/第#3回/
@end example

@noindent
@samp{だい12かい} のような見出し語で変換しようとした場合、見出し語の数字
の部分は自動的に @samp{#} に置き換えられるようになっているので、上記の例
にマッチします。

次に上記の例の各候補の意味について説明します。いずれも @samp{#} の次に 1
桁の数字が続く部分があります。これは、これらが候補として出力される前に数
値変換によって加工されることを意味します。そして、0 から 9 の数字はその
候補にかけられる数値変換のタイプを表しています。

以下、数値変換の各タイプについて説明します。

@table @samp
@item #0

タイプ 0。無変換。入力されたアスキー文字をそのまま出力します。例えば、
@samp{第12回} のような変換を得るために使われます。

@item #1

タイプ 1。全角文字での数字。@samp{12} を @samp{１２}に変換します。

@item #2

タイプ 2。漢数字で位取りなし。@samp{5500} を @samp{五五〇〇} に変換しま
す。

@item #3

タイプ 3。漢数字で位取りあり。@samp{5500} を @samp{五千五百} に変換しま
す。

@item #4

タイプ 4。数値再変換。見出し語中の数字そのもの
@footnote{@samp{p125} という見出し語であれば、その数値部分である
@samp{125} が再変換の見出し語となります。}をキーとして辞書を再検索し、
@samp{#4} の部分を再検索の結果の文字列で入れ替えます。これについては後で
例を挙げて説明します。

@item #5

タイプ 5。小切手や手形の金額記入の際用いられる表記で変換します。例えば、
@samp{1995} を @samp{壱阡九百九拾伍} に変換します。

@item #9

タイプ 9。将棋の棋譜の入力用。@samp{全角数字 + 漢数字} に変換します。こ
れについては後で例を挙げて説明します。
@end table

以下にいくつか例を示します。辞書に

@example
# /#3/
@end example

@noindent
というエントリがあるときに、

@example
@group
@kbd{Q 1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}@footnote{または@kbd{/
1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}。}
@end group
@end example

@noindent
と入力すれば、@samp{百兆二千三億四十万五百}と変換されます
@footnote{数字を大文字で入力し始めることはできないので、@kbd{Q} または
@kbd{/} で▽モードに入る必要があります。}。

辞書に

@example
#m#d /#0月#0日/
@end example

@noindent
というエントリがあるときに、@kbd{/ 2 m 2 5 d @key{SPC}} と入力すれば、
@samp{2月25日}と変換されます
@footnote{@samp{m} や @samp{d} などアスキー文字を見出し語として入
力する場合は @kbd{/} キーを最初に入力して SKK abbrev mode に入ってから
入力する必要があります。
@w{@xref{アスキー文字を見出し語とした変換, , SKK abbrev mode}.}}。

辞書に

@example
#kin /#9金/
@end example

@noindent
というエントリがあるときに、@kbd{/ 3 4 k i n @key{SPC}} と入力すれば、
@samp{３四金}と変換されます。

辞書に

@example
@group
p# /#4/
125 /東京都葛飾区/
@end group
@end example

@noindent
というエントリがあるときに、@kbd{/ p 1 2 5 @key{SPC}} と入力すれば、見出
し語 @samp{p125} の候補が @samp{#4} なので、見出し語の数字部分の
@samp{125} に対し辞書が再検索され、@samp{東京都葛飾区} と変換されます。

次に、辞書登録の例を 1 つ挙げます。@samp{２月２５日}を得るために、

@example
@kbd{Q 2 g a t u 2 5 n i t i @key{SPC}}
@end example

@noindent
と入力したときに、辞書に見出し語

@example
#がつ#にち
@end example

@noindent
がないときは、辞書登録時のプロンプトは、@w{@samp{#がつ#にち}}となります。
全角数字のタイプは、@samp{#1} なので、@samp{２月２５日}の全角数字部分を 
@samp{#1} で置き換えた文字列 @w{@samp{#1月#1日}} をミニバッファで作り登
録します。辞書には

@example
#がつ#にち /#1月#1日/
@end example

@noindent
というエントリが追加されます。

@table @code
@item skk-num-convert-float
@vindex skk-num-convert-float

この変数の値を非 @code{nil} に設定すると、浮動小数点数を使った見出し語
に対応して数値変換を行います。ただし、辞書において

@example
#.# /#1．#1/#0月#0日/
@end example

などの見出し語が使用できなくなります。

@item skk-use-numeric-conversion
@vindex skk-use-numeric-conversion

この変数を @code{nil} に設定すると、本節で説明した数値変換の機能を全て
無効にします。
@end table

@node アスキー文字を見出し語とした変換
@subsection アスキー文字を見出し語とした変換

@cindex SKK abbrev mode
@dfn{SKK abbrev mode} では、アスキー文字を見出し語とした変換を行うことが
できます。

まず、かなモードに入ります。@kbd{/} を入力すると、見出し語入力の間だけ
一時的に SKK abbrev mode に入ります。続けて入力する文字は、アスキー文字
としてカレントバッファに挿入される。見出し語となるアスキー文字を入力し終え
た時点で @key{SPC} を押すと、その見出し語についての変換が得られます。

仮に、

@example
is /インクリメンタル・サーチ/
@end example

@noindent
というようなエントリが辞書にあるとして、例を示します。

@example
@kbd{/}

@group
------ Buffer: foo ------
▽
------ Buffer: foo ------
@end group

@kbd{is}

@group
------ Buffer: foo ------
▽is
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼インクリメンタル・サーチ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
インクリメンタル・サーチ
------ Buffer: foo ------
@end group
@end example

@noindent
入力したアスキー文字をそのまま全角アルファベットに変換する方法については、
@ref{全英文字の一時的入力,, 全角アルファベットへの変換}. を参照してくださ
い。

なお、SKK abbrev mode においても見出し語の補完を行うことができます。
@xref{見出し語の補完}.

@node 今日の日付の入力
@subsection 今日の日付の入力
@kindex @@
@cindex プログラム実行変換

かな/カナモードで @kbd{@@} を入力すれば、今日の日付が入力されます。

日付の形式は以下の変数により決定されます。

@table @code
@item skk-date-ad
@vindex skk-date-ad

この変数の値が非 @code{nil} であれば西暦で、@code{nil} であれば元号で
表示します。既定値は @code{nil} です。

@item skk-number-style
@vindex skk-number-style

この変数の値は以下のように解釈されます。

@table @code
@item 0
@itemx nil

半角数字。@samp{1996年7月21日(日)} のようになります。

@item 1
@itemx t

全角数字。@samp{１９９６年７月２１日(日)} のようになります。

@item 2

漢数字。@samp{一九九六年七月二一日(日)} のようになります。

@item 3

漢数字。@samp{千九百九十六年七月二十一日(日)} のようになります。
@end table

上記の @samp{1996年}、@samp{１９９６年}、@samp{一九九六年} の部分は、変
数 @code{skk-date-ad} の値が @code{nil} であれば @samp{平成8年} のよう
に元号で表示されます。 @code{skk-number-style} の既定値は、@samp{1} です。
@end table

L 辞書
@footnote{@ref{辞書の形式, , L辞書}.}には、見出し語 @samp{today} の候補
として、@code{skk-date-ad} と @code{skk-number-style} の全ての組合わせが
プログラム実行変換機能@footnote{@ref{プログラム実行変換}.}を用いて登録さ
れています。従って、@kbd{/ t o d a y @key{SPC}} と入力すると、今日の日付
が上記の形式で順次候補として表示されます。

@kbd{@@} によって日付けを挿入するのではなく、文字通り @kbd{@@} を挿入し
たい場合には、

@lisp
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("@@" nil "@@"))))
@end lisp

@noindent
のようにします。全角文字の @samp{＠} を挿入したい場合は、

@lisp
(setq skk-rom-kana-rule-list
      (append skk-rom-kana-rule-list
              '(("@@" nil "＠"))))
@end lisp

@noindent
のようにします。

@node プログラム実行変換
@subsection プログラム実行変換
@cindex @file{skk-gadget.el}

辞書の候補に Emacs Lisp のプログラムが書いてあれば、そのプログラムを
Emacs に実行させ、返り値をカレントバッファに挿入します。これを @b{「プロ
グラム実行変換」}と読んでいます。例えば、辞書に

@example
now /(current-time-string)/
@end example

@noindent
というエントリがあるとします。このとき @kbd{/ n o w @key{SPC}} と入力す
れば、現在のバッファに @code{current-time-string} の返り値である

@example
Sun Jul 21 06:40:34 1996
@end example

@noindent
のような文字列が挿入されます。

ここで、プログラムの返り値は文字列である必要があります。また、プログラム
実行変換の辞書登録は通常の単語と同様に行うことができますが、その中に改
行を含まないように書く必要があります
@footnote{通常の単語では、改行を含むことが可能です。それは、評価するとそ
の位置に改行を挿入するような実行変換プログラムに変換して辞書に書き込んで
いるからなのです。@w{@xref{辞書の形式}.}

しかし、実行変換されるプログラムを辞書登録する際にはこの機能を利用できな
いため、改行を含むことができません。}。

今日の日付の入力
@footnote{@xref{今日の日付の入力}.} で説明した @samp{today} の辞書エント
リは、実際は下記のようなプログラムを候補にもっています。

@lisp
@group
today /(let ((skk-date-ad) (skk-number-style t)) (skk-today))/@dots{}/
@end group
@end lisp

@file{skk-gadget.el}
@footnote{@samp{gadget} は「上手く工夫した道具」の意味。「色々飛び出す気
のきいたおもちゃ箱」というような意味で名付けられています。
因みに、X Window System で使用される @samp{Widget} という言葉は、 @samp{window}
+ @samp{gadget} から作られた造語のようです。}には、西暦/元号変換プログラ
ムや、簡単な計算プログラムなど、実行変換用のプログラムが集められています。
以下、２つの例を掲げます。

@defun skk-calc operator

skk-calc は、引数を 1 つ取り、見出し語の数字に対しその演算を行う簡単な計算
プログラムです。

@lisp
@group
(defun skk-calc (operator)
  ;;@r{2つの引数を取って operator の計算をする。}
  ;;@r{注意: '/ は引数として渡せないので (defalias 'div '/) などとし、別の形で}
  ;;@r{skk-calc に渡す。}
  ;;@r{辞書見出し例; #*# /(skk-calc '*)/}
  (number-to-string (apply operator
                           (mapcar 'string-to-number 
                                   skk-num-list))))
@end group
@end lisp

この関数を実際にプログラム実行変換で利用するには、辞書に以下のようなエン
トリを追加します
@footnote{@ref{数値変換}.}。

@example
#*# /(skk-calc '*)/
@end example

@noindent
@kbd{Q 1 1 1 * 4 5 @key{SPC}} と入力します。ここで、@samp{111} と
@samp{45} の 2 つの数字は、変換時に @w{@code{("111" "45")}} のような文字
列のリストにまとめられ、変数 @code{skk-num-list} の値として保存されます。
次に関数 @code{skk-calc} が呼ばれます。この中で、@code{skk-num-list} の
各要素に対し演算を行うため、各要素は数に変換されます。その上で、
@code{skk-calc} に与えられた引数 (この場合は @samp{*}) を演算子として演
算を行います。
@end defun

@defun skk-gadget-units-conversion 基準単位 数値 変換単位

数値について、基準単位から変換単位への変換を行います。

@example
@kbd{/ 1 3 m i l e}

@group
------ Buffer: foo ------
▽13mile@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼20.9209km@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
20.9209km@point{}
------ Buffer: foo ------
@end group
@end example

単位変換の情報は、変数 @code{skk-units-alist} で定義されています。
@end defun

@defvr {ユーザ変数} skk-units-alist

この変数は以下の形式の連想リストです。

@example
(基準となる単位 (変換する単位 . 変換時の倍率)
                (… . …))
@end example

関数 @code{skk-gadget-units-conversion} で利用されています。デフォルトで
は、以下の単位変換の情報を定義しています。

@lisp
@group
("mile" ("km" . 1.6093)
        ("yard" . 1760))

("yard" ("feet" . 3)
        ("cm" . 91.44))

("feet" ("inch" . 12)
        ("cm" . 30.48))

("inch" ("feet" . 0.5)
        ("cm" . 2.54))
@end group
@end lisp
@end defvr

@node 接頭辞・接尾辞
@section 接頭辞・接尾辞
@cindex 接頭辞
@cindex 接尾辞

接頭辞 (prefix)、接尾辞 (suffix)の入力のために特別な方法が用意されていま
す。

辞書の見出し語の一部に @samp{>}, @samp{<}, @samp{?} を用いている場合があ
ります。例えば

@example
>し /氏/
@end example

@noindent
というエントリがあるとき、@samp{小林氏}を接尾辞入力を用いて、以下のよう
に入力することができます。

@example
@kbd{K o b a y a s h i}

@group
------ Buffer: foo ------
▽こばやし@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼小林@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
小林▽>@point{}
------ Buffer: foo ------
@end group

@kbd{s i}

@group
------ Buffer: foo ------
小林▽>し@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
小林▼氏@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
小林氏@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
このように入力することで、見出し語 @samp{し} に対応する語でも接尾辞にな
り得ないものは候補に現れないので、変換効率がよくなります。

また、辞書に

@example
ちょう> /超/
@end example

@noindent
というエントリがあるとき、@samp{超大型} を接頭辞入力を用いて、以下のよう
に入力することができます。

@example
@kbd{T y o u}

@group
------ Buffer: foo ------
▽ちょう@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
▼超@point{}
------ Buffer: foo ------
@end group

@kbd{O o g a t a}

@group
------ Buffer: foo ------
超▽おおがた@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
超▼大型@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
超大型@point{}
------ Buffer: foo ------
@end group
@end example

@table @code
@item skk-special-midashi-char-list
@vindex skk-special-midashi-char-list

▽モードまたは▼モードにおいて、この変数の値に含まれる文字の入力があった
場合、接頭辞・接尾辞の入力を開始します。この変数の既定値は、

@lisp
(?> ?< ??)
@end lisp

@noindent
です。つまり、@samp{>} と @samp{<} と @samp{?} を入力した時に接頭辞・接尾辞入
力を行います。@samp{?} を入力したときに接頭辞・接尾辞入力を行わない場合は
@samp{?} を外して

@lisp
@group
(setq skk-special-midashi-char-list '(?> ?<))
@end group
@end lisp

@noindent
とします。
@end table

@node 暗黙の確定のタイミング
@section 暗黙の確定のタイミング
@cindex 暗黙の確定
@vindex skk-process-okuri-early

標準の設定では、▼モードにおいて印字可能な文字または @key{RET} が入力さ
れると、暗黙の確定が行われ直ちに確定されます。具体的には以下のようにな
ります。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
確定s
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
確定す
------ Buffer: foo ------
@end group
@end example

@table @code
@item skk-kakutei-early
@vindex skk-kakutei-early

この変数の値を非 @code{nil} にすると、暗黙の確定が行われるタイミングが
変化します。具体的には、括弧 (@kbd{(}, @kbd{)}, @kbd{[}, @kbd{]}) また
は句読点 (@kbd{,}, @kbd{.}) の入力時、次の変換開始 (@kbd{A} から @kbd{Z}
までの大文字の入力) 時、あるいは @key{RET} 入力時まで暗黙の確定が遅延
されます
@footnote{@code{skk-kakutei-early} の機能と
@code{skk-process-okuri-early} の機能を同時に有効にすることはできません。
@code{skk-kakutei-early} の 値を非 @code{nil} にする場合は
@code{skk-process-okuri-early} の値を @code{nil} にする必要がありま
す。}。
@end table

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
▼確定s
------ Buffer: foo ------
@end group

@kbd{u r u}

@group
------ Buffer: foo ------
▼確定する
------ Buffer: foo ------
@end group

@kbd{.}

@group
------ Buffer: foo ------
確定する。
------ Buffer: foo ------
@end group
@end example

@node 確定変換とその取り消し
@section 確定変換とその取り消し

@findex skk-search-kakutei-jisyo-file
@vindex skk-kakutei-jisyo

確定辞書を用意することで「確定変換」機能を利用することができます
@footnote{確定変換を行う関数 @code{skk-search-kakutei-jisyo-file} と確定
辞書を指定するための変数 @code{skk-kakutei-jisyo} については詳しくは
@w{@ref{辞書検索のための関数}} を参照して下さい。}。
ここではその動作について説明します。

例えば、

@example
せつめい /説明/
@end example

@noindent
というエントリが確定辞書にあったとします。このとき、

@example
@group
@kbd{S e t u m e i}

@group
------ Buffer: foo ------
▽せつめい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
説明
------ Buffer: foo ------
@end group
@end group
@end example

@cindex 暗黙の確定
@noindent
のように確定動作をすることなしに (暗黙の確定もなく) いきなり確定します。
仮に確定辞書に

@example
じしょ /辞書/
@end example

@noindent
というエントリを挿入してしまったが、@samp{自署} に変換したい場合は、確定
直後に @kbd{x} をタイプすることにより確定変換を取り消して▼モードに戻り次
の候補を検索することができます。個人辞書、あるいは共有辞書に

@example
じしょ /自署/
@end example

@noindent
のエントリがあれば @samp{自署} への変換を行うことができます。

@example
@group
@kbd{Z i s y o @key{SPC}}

@group
------ Buffer: foo ------
辞書
------ Buffer: foo ------
@end group

@kbd{x}

@group
------ Buffer: foo ------
▼自署
------ Buffer: foo ------
@end group

@end group
@end example

@node 積極的な確定変換
@section 積極的な確定変換

確定辞書を用意せずに「確定変換」機能を利用することもできます。

これは単語を入力して最初に変換する時に全ての辞書を検索し、その結果変換候
補が一つしか見つからなかった場合に自動的に確定変換する、というものです。

@defvr {ユーザ変数} skk-kakutei-when-unique-candidate

この値が non-@code{nil} の場合、この機能が有効になります。

@code{t} であれば送りあり変換、送りなし変換、abbrev モードでの変換、全て
でこの機能が有効になります。

また、@samp{okuri-ari}, @samp{okuri-nasi}, @samp{abbrev} を要素とするリス
トであることもできます。その場合は変換対象がその条件に合致した場合のみ確
定変換が機能します。
@end defvr

@defvr {ユーザ変数} skk-kakutei-search-prog-limit

この機能は変換候補が他に無い事を確認するために複数の辞書を検索するので、
@code{skk-search-prog-list} の内容によってはレスポンスが悪くなる可能性が
あります。

この値が数値であった場合、検索対象を @code{skk-search-prog-list} の先頭か
ら数えてこの個数までの辞書に制限します。

それ以外であれば無制限に全ての辞書を検索対象とします。
@end defvr

@node 領域一括変換
@section 領域一括変換

以下のコマンドを @kbd{M-x} により呼ぶことで領域一括変換を行うことがで
きます
@cindex Menu Bars
@cindex メニューバー
@footnote{メニューバーが使用できる環境では、メニューバーを使ってこれらの一括変換コマ
ンドを呼び出すことができます。ただし kakasi がインストールされていない場
合は kakasi を利用する機能が灰色になり使用できません。@w{@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.}}。

@table @asis
@item @kbd{M-x skk-hiragana-region}
@kindex M-x skk-hiragana-region
@findex skk-hiragana-region

カタカナをひらがなへ変換。

@item @kbd{M-x skk-katakana-region}
@kindex M-x skk-katakana-region
@findex skk-katakana-region

ひらがなをカタカナへ変換。

@item @kbd{M-x skk-latin-region}
@kindex M-x skk-latin-region
@findex skk-latin-region

全英文字をアスキー文字へ変換。

@item @kbd{M-x skk-jisx0208-latin-region}
@kindex M-x skk-jisx0208-latin-region
@findex skk-jisx0208-latin-region

アスキー文字を全英文字へ変換。
@end table

@cindex 逆引き
以下に紹介するコマンドについては、外部プログラム KAKASI
@footnote{@url{http://kakasi.namazu.org/}} に依存しています。
KAKASI がインストールされていなければ使用することができません。

@table @asis
@item @kbd{M-x skk-gyakubiki-region}
@kindex M-x skk-gyakubiki-region
@findex skk-gyakubiki-region

漢字をひらがなへ変換。具体的な変換例をあげると、

@example
``漢字をひらがなへ変換。''@expansion{}``かんじをひらがなへへんかん。''
@end example

@noindent
のようになります。引数を渡して、

@kbd{C-u M-x skk-gyakubiki-region}

のようにすると、複数の候補がある場合に、`@{@}' で囲って表示します。例え
ば

@example
``中島''@expansion{}``@{なかしま|なかじま@}''
@end example

@noindent
のようになります。

送り仮名がある語は、送り仮名まで含めて領域に指定します (さもないと誤変換
の原因となります)。 例えば、@samp{五月蝿い} について、送り仮名 @samp{い}
を含めずにこのコマンドを実行すると、@samp{ごがつはえ} に変換されてしまい
ます。

@item @kbd{M-x skk-gyakubiki-katakana-region}
@kindex M-x skk-gyakubiki-katakana-region
@findex skk-gyakubiki-katakana-region

漢字をカタカナへ変換。

引数を渡して、@kbd{C-u M-x skk-gyakubiki-katakana-region} のようにすると、
複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-hurigana-region}
@kindex M-x skk-hurigana-region
@findex skk-hurigana-region

漢字にふりがなを付ける。例えば、

@example
``漢字の脇に''@expansion{}``漢字[かんじ]の脇[わき]に''
@end example

@noindent
のようになります。引数を渡して @kbd{C-u M-x skk-hurigana-region} のよう
にすると、複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-hurigana-katakana-region}
@kindex M-x skk-hurigana-katakana-region
@findex skk-hurigana-katakana-region

漢字にカタカナのふりがなを付ける。

引数を渡して、@kbd{C-u M-x skk-hurigana-katakana-region} のようにすると、
複数の候補がある場合に、`@{@}' で囲って表示します。

@item @kbd{M-x skk-romaji-region}
@kindex M-x skk-hurigana-region
@findex skk-romaji-region
@vindex skk-romaji-*-by-hepburn

漢字、ひらがな、カタカナをローマ字へ、全英文字をアスキー文字へ変換。標準
では、ローマ字への変換様式はヘボン式です。例えば、

@example
``し'' @expansion{} ``shi''
@end example

@noindent
となります。変数 @code{skk-romaji-*-by-hepburn} の値を @code{nil} に設
定すると、訓令式を用います。例えば、

@example
``し'' @expansion{} ``si''
@end example

@noindent
のようになります
@footnote{昭和 29 年 12 月 9 日付内閣告示第一号によれば、原則的に訓令式
(日本式) を用いるかのように記載されていますが、今日一般的な記載方法は、
むしろヘボン式であるようです。}。
@end table

以下のコマンドは、領域の文字列を置き換える代わりに、変換結果をエコーエ
リアに表示します。

@itemize @bullet
@item @kbd{M-x skk-gyakubiki-message}
@kindex M-x skk-gyakubiki-message
@findex skk-gyakubiki-message
@item @kbd{M-x skk-gyakubiki-katakana-message}
@kindex M-x skk-gyakubiki-katakana-message
@findex skk-gyakubiki-katakana-message
@item @kbd{M-x skk-hurigana-message}
@kindex M-x skk-hurigana-message
@findex skk-hurigana-message
@item @kbd{M-x skk-hurigana-katakana-message}
@kindex M-x skk-hurigana-katakana-message
@findex skk-hurigana-katakana-message
@item @kbd{M-x skk-romaji-message}
@kindex M-x skk-romaji-message
@findex skk-romaji-message
@end itemize

@c http://mail.ring.gr.jp/skk/200110/msg00005.html
@defvr {ユーザ変数} skk-gyakubiki-jisyo-list

関数 @code{skk-gyakubiki-region} はコマンド kakasi を呼び出しています。
kakasi には漢字をひらがなへ変換する機能があり、この変換には環境変数
@code{KANWADICTPATH} で指定されている辞書を用いています。

変数 @code{skk-gyakubiki-jisyo-list} を設定することにより kakasi へ与え
る辞書を任意に追加することができます。
以下のように個人辞書 @code{skk-jisyo} を指定することにより、辞書登録モー
ドで登録したばかりの単語も kakasi による逆引き変換の対象とすることができ
ます。

@example
(setq skk-gyakubiki-jisyo-list (list skk-jisyo))
@end example
@end defvr

@node 漢字コード関連
@section 漢字コード関連

@menu
* 漢字コードまたはメニューによる文字入力::
* 漢字コードを知る方法::
@end menu

@node 漢字コードまたはメニューによる文字入力
@subsection 漢字コードまたはメニューによる文字入力

@cindex JISコード
@cindex EUCコード
@kindex \
まずかなモードに入ります。@kbd{\} キーを入力すると、漢字コード (区点、JIS ま
たは EUC コード) またはメニューによる文字入力が行われます。ミニバッファ
には、

@example
@group
---------------------------- Minibuffer -----------------------------
7/8 bits or KUTEN code for ○○ (00nn or CR for Jump Menu): @point{}
---------------------------- Minibuffer -----------------------------
@end group
@end example

@noindent
というプロンプトが表示されます。○○部分は 変数 @code{skk-kcode-charset}
の値であり、その初期値は @code{japanese-jisx0208} 又
は @code{japanese-jisx0213-1} です。
初期値は環境によって自動的に設定されます。

@kbd{\} の代わりに @kbd{C-u \} とすると異なる文字集合 (charset) を指定す
る事ができます。

ここで、漢字コードがあらかじめ分かっている場合には、その漢字コードを入力
します。例えば @samp{℃} の漢字コードは、JIS コードでは @samp{216e}、EUC
コードでは @samp{a1ee} なので、いずれかの漢字コードを入力すれば @samp{℃}
が現在のバッファに挿入されます。区点コードで入力するには @samp{01-78} の
ように区と点の間にハイフン @samp{-} を入れる必要があります。

漢字コードが不明の文字の入力をする場合は、漢字コードを入力せずにそのまま
@key{RET} キーを入力します。するとミニバッファに以下のような表示が現れま
す。

@example
@group
---------------------------- Minibuffer -----------------------------
A:　  S:￣  D:〜  F:｝  G:＝  H:¢  Q:◆  W:  E:∩  R:  T:≡  Y:
---------------------------- Minibuffer -----------------------------
@end group
@end example

これを@b{「第 1 段階のメニュー」}と呼びます。第 1 段階のメニューでは、JIS 漢字を
コードの順に 16 文字毎に 1 文字抽出し、ミニバッファに一度に 12 文字づつ
表示しています
@footnote{上記の例では、JISコード 2121 (全角スペース)、2131、2141、2151、
@dots{} の文字がそれぞれ表示されています。}。ここで @key{SPC} を入力する
と、次の候補群を表示します
@footnote{漢字コードの値を@w{16x12 @equiv{}192}づつ増やします。}。
@kbd{x} により 1 つ前の候補群に戻ります。

キー @kbd{a}, @kbd{s}, @kbd{d}, @kbd{f}, @kbd{g}, @kbd{h},
@kbd{q}, @kbd{w}, @kbd{e}, @kbd{r}, @kbd{t}, @kbd{y} のいずれかを
入力すると
@footnote{大文字でも小文字でも構いません。なお、第 1 段階・第 2 段階とも
に、メニューのキーは変更することができます。これについては、
@w{@ref{候補の選択に用いるキー}} を参照してください。}、そのキーに対応す
る文字から始まる 16 個の文字が漢字コード順に表示されます。これを@b{「第 2 段
階のメニュー」}と呼びます。例えば、第 1 段階のメニューが上記の状態のときに
@kbd{d} を入力すると 第 2 段階のメニューは以下のようになります。

@smallexample
@group
--------------------------------- Minibuffer ----------------------------------
A:〜 S:‖ D:｜ F:… G:‥ H:‘ J:’ K:“ L:” Q:（ W:） E:〔 R:〕 T:［ Y:］ U:｛
--------------------------------- Minibuffer ----------------------------------
@end group
@end smallexample

ここでタイプすると、キー @kbd{a}, @kbd{s}, @kbd{d}, @kbd{f}, @kbd{g}, @kbd{h},
@kbd{q}, @kbd{w}, @kbd{e}, @kbd{r}, @kbd{t}, @kbd{y} のいずれかを
入力すると、対応する文字がカレントバッファに挿入されてメニューによる入力
が終了します。

第 2 段階のメニューが表示されているときも @key{SPC} と @kbd{x} キーによ
り第 2 段階のメニューが前進、後退します。

また @kbd{<}、@kbd{>} によりメニューを 1 文字分だけ移動します。例えば、
第 2 段階のメニューが上記の状態のときに @kbd{<} を入力すると、メニューは
以下のようになります。

@smallexample
@group
--------------------------------- Minibuffer ----------------------------------
A:＼ S:〜 D:‖ F:｜ G:… H:‥ J:‘ K:’ L:“ Q:” W:（ E:） R:〔 T:〕 Y:［ U:］
--------------------------------- Minibuffer ----------------------------------
@end group
@end smallexample

第 1 段階あるいは第 2 段階のメニューが表示されているときに @kbd{?} を入
力すると、そのときのキー @kbd{A} に対応する文字 (上記の例では、@samp{＼})
の文字コードが表示されます。

@node 漢字コードを知る方法
@subsection 漢字コードを知る方法
@kindex $
@cindex JISコード
@cindex EUCコード

かな/カナモードで @kbd{$} を入力すると、現在位置の直後にある文字の漢字コー
ドをエコーエリアに表示します。例えば、カーソルを文字 @samp{А} の上に置
いて @kbd{$} を入力すると、

@example
@group
-------------------- Echo Area --------------------
`А' KUTEN: 07-01, JIS: 2721, EUC: a7a1, SJIS: 8440
-------------------- Echo Area --------------------
@end group
@end example

@noindent
がエコーエリアに表示され、この文字がロシア文字であることがわかります。

@node ▼モードの特殊キー
@section ▼モードの特殊キー

@menu
* 確定動作を行うキー::
* 候補の選択に用いるキー::
* ▼モードでのRET::
* ▼モードでのBS::
* 送りあり変換中のC-g::
@end menu

@node 確定動作を行うキー
@subsection 確定動作を行うキー
@kindex C-j

@table @code
@item skk-kakutei-key
@vindex skk-kakutei-key

この変数の値は、明示的な確定動作を行うキーを指定します。標準設定では
@kbd{\C-j} となっています。
@end table

@node 候補の選択に用いるキー
@subsection 候補の選択に用いるキー

変換において、候補が 5 つ以上あるときは、 5 番目以降の候補は 7 つずつま
とめてエコーエリアに下記のように表示されます
@footnote{@ref{▼モード}.}。

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

この際、候補の選択に用いるキーは、次の変数によって決定されます。

@table @code
@item skk-henkan-show-candidates-keys
@vindex skk-henkan-show-candidates-keys

7 つの異なる文字のリスト。文字は必ず小文字とする
@footnote{@kbd{x}, @key{SPC} および @kbd{C-g} は、それぞれ候補選択中に
おける前候補群の表示、次候補群の表示、取り止めのために割り付けられている
ので、@code{skk-henkan-show-candidates-keys} の中に含めてはいけません。}。
既定値は、以下の通り。

@lisp
(?a ?s ?d ?f ?j ?k ?l)
@end lisp
@end table

メニューによる文字入力
@footnote{@ref{漢字コードまたはメニューによる文字入力}.}の際に候補の選択
に用いられるキーは、下記の 2 変数により変更されます。

@table @code
@item skk-input-by-code-menu-keys1
@vindex skk-input-by-code-menu-keys1

第 1 段階のメニューにおける候補の選択キー。既定値は、

@lisp
(?a ?s ?d ?f ?g ?h ?q ?w ?e ?r ?t ?y)
@end lisp

@noindent
です。このリストには 12 個の異なる文字を含む必要があります。

@item skk-input-by-code-menu-keys2

第 2 段階のメニューにおける候補の選択キー。既定値は、

@lisp
(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u)
@end lisp

@noindent
です。このリストには 16 個の異なる文字を含む必要があります。
@end table

上記 2 変数のすべての要素を、全て小文字で指定することを強くお勧めします
@footnote{小文字が指定された場合は、候補の選択の際に対応する大文字キーが
入力されても候補の選択が可能となるように設計されています。その一方で、大
文字が指定された場合、候補の選択の際に対応する小文字キーが入力されても候
補の選択ができません。これは現在の仕様です。}。

@node ▼モードでのRET
@subsection ▼モードでの@key{RET}

標準設定では、

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定
@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
のように、▼モードで @key{RET} を入力すると、確定し、かつ改行を行います。
この挙動を変えるためのユーザーオプションが用意されています。

@table @code
@item skk-egg-like-newline
@vindex skk-egg-like-newline

この変数の値を非 @code{nil} にすると、▼モードで @key{RET} を入力した
ときに確定のみ行い、改行はしません @footnote{従って、辞書登録モードに
おいて▼モードであるときの @key{RET} 入力時の挙動も変化します。標準の
確定、登録の動作については、@w{@ref{辞書登録モード}} を参照してくださ
い。}。

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定@point{}
------ Buffer: foo ------
@end group
@end example
@end table

@node ▼モードでのBS
@subsection ▼モードでの@key{BS}
@kindex @key{BS}

標準設定では、▼モードで @key{BS} を押すと、前の一文字を削除した上で確定
します。

@example
@kbd{D e n k i y a @key{SPC}}

@group
------ Buffer: foo ------
▼電気屋
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
電気
------ Buffer: foo ------
@end group
@end example

@table @code
@item skk-delete-implies-kakutei
@vindex skk-delete-implies-kakutei

この変数の値を @code{nil} に設定すると、▼モードで @key{BS} を押した時
に一つ前の候補を表示します。例えば、

@example
でんき /電気/伝記/
@end example

@noindent
という辞書エントリがあるとき、以下のようになります。

@example
@kbd{D e n k i}

@group
------ Buffer: foo ------
▽でんき
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼電気
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼伝記
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▼電気
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▽でんき
------ Buffer: foo ------
@end group
@end example
@end table

@node 送りあり変換中のC-g
@subsection 送りあり変換中の@kbd{C-g}
@kindex C-g

送りありの変換中に @kbd{C-g} を入力すると、▼モードを抜け、その見出し語
と送り仮名を現在のバッファに挿入し、▽モードに入ります。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
▽なく
------ Buffer: foo ------
@end group
@end example

@table @code
@item skk-delete-okuri-when-quit
@vindex skk-delete-okuri-when-quit

この変数の値を非 @code{nil} に設定すると、送りありの変換中に @kbd{C-g}
を入力したときの挙動が変化します。具体的には、送り仮名を消し、▽モード
になります @footnote{送り仮名の入力間違いを修正するのには便利です。}。
例えば、以下のようになります。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
▽な
------ Buffer: foo ------
@end group
@end example
@end table

@node 変換位置の指定方法
@section 変換位置の指定方法
@cindex @file{skk-sticky.el}

SKK では通常、漢字変換の開始および送り仮名開始の位置を大文字で指定します
が、これを任意のキーで指定することで sticky-shift ライクな操作
@footnote{あくまでも「任意のキーで変換位置を指定する」ものであり、
sticky-shift そのものではありません。したがって、アスキーモードや abbrev
モード、また SKK 以外でも sticky-shift を使いたい場合は前述のような設定を
併用する必要があります。}も可能です。

@lisp
(setq skk-sticky-key ";")
@end lisp

@noindent
と設定すると @kbd{;} キーで変換位置が指定できるようになります。
@footnote{@file{skk-hint.el} を併用する場合は @code{skk-hint-start-char}
のデフォルトも @samp{;} なのでどちらかを別のキーに割当てる必要がありま
す。}例えば @samp{有る} が

@example
@kbd{; a ; r u}
@end example

でも入力でき、シフトキーを押す必要がなくなります。操作上は
@w{@xref{Q.3-4 左手の小指を SHIFT で酷使したくありません。}} などにある通
常の sticky-shift と変わりませんが、画面表示は
 
@display
@group
@multitable {打鍵 } {通常の@tie{}sticky} {skk-sticky}
@item 打鍵
@tab 通常の@tie{}sticky
@tab skk-sticky
@item ;
@tab 変化なし
@tab ▽
@item a
@tab ▽あ
@tab ▽あ
@item ;
@tab ▽あ
@tab ▽あ*
@item r
@tab ▽あ*r
@tab ▽あ*r
@end multitable
@end group
@end display

@noindent
と遷移します。skk-sticky は @kbd{;} を押した時点で表示が変化するので若干
分かり易くなるかと思います。

キーの設定方法は割当てるキーの種類によって異なります。

@enumerate
@item
表示可能なキー

@samp{;} などの表示が可能なキーの場合は

@lisp
(setq skk-sticky-key ";")
@end lisp

のように @code{string} を設定して下さい。@code{skk-sticky-key} に設定した
文字そのものを入力したい場合は2回続けて打つと入力できます。

@item
表示されないキー

@key{無変換} のような表示を伴わないキーの場合は

@lisp
(setq skk-sticky-key [muhenkan])   ; Windows 環境ならば [noconvert]
@end lisp

のようにそのキーを表わす @code{vector} を設定して下さい。

@item
同時打鍵

2つのキーを同時に打鍵することでも変換位置を指定できます。例えば
@kbd{f} と @kbd{j} の同時打鍵で指定する場合は

@lisp
(setq skk-sticky-key '(?f ?j))
@end lisp

のように @code{character} のリストを設定して下さい。

Dvorak 配列のような、押しやすい場所に適当なキーがない環境でもこの機能を使
いたい場合に便利かもしれません。
@end enumerate

@node 辞書関連
@section 辞書関連

本節では、辞書の形式、設定方法、その他辞書にまつわる動作や設定を説明しま
す。

@menu
* 辞書の形式::                  辞書の形式と構成。
* 辞書に関する設定::            検索対象と検索順序の設定。
* 個人辞書中の単語の削除::
* 個人辞書の保存動作::
* 変換及び個人辞書に関する統計::
* 辞書候補数の数えあげ::
* 辞書バッファの文字コードの設定::
* 辞書バッファのメジャーモード::
* 辞書バッファのbuffer-file-name::
* 辞書のアノテーション(注釈)::
* アノテーションとして Wikipedia を表示する::
@end menu

@node 辞書の形式
@subsection 辞書の形式

ここでは SKK 辞書の形式について詳しく説明します。

@menu
* 辞書の種別::
* 送りありエントリと送りなしエントリ::
* 送りありエントリのブロック形式::
* エントリの配列::
@end menu

@node 辞書の種別
@subsubsection 辞書の種別

辞書の種別は大きく分けて@b{「共有辞書」}と@b{「個人辞書」}の 2 つがあり
ます。

@table @asis
@item 共有辞書
@cindex 共有辞書
@cindex L 辞書
@cindex M 辞書
@cindex S 辞書
@cindex @file{SKK-JISYO.L}
@cindex @file{SKK-JISYO.ML}
@cindex @file{SKK-JISYO.M}
@cindex @file{SKK-JISYO.S}

@file{SKK-JISYO.S} (「S 辞書」), @file{SKK-JISYO.M} (「M辞書」),
@file{SKK-JISYO.ML} (「ML 辞書」), @file{SKK-JISYO.L}, (「L 辞書」) など
があります。通常、個人辞書よりもサイズが大きく、省資源の面からユーザー間
で共有して参照されます。ユーザーの変換により内容が書き替えられることはあ
りません。
その他の共有辞書、あるいはそれぞれの辞書の詳細については
@url{http://openlab.jp/skk/dic.html} をご参照下さい。

@item 個人辞書
@cindex 個人辞書
@vindex skk-jisyo

変数 @code{skk-jisyo} で指定されるファイル。DDSKK を一番最初に使い始めた
ときにホームディレクトリに自動的に作られます。その後の使用により日々刻々
とエントリが追加され、更新されていきます。

なお、最初の個人辞書として S 辞書をリネームして使用するのも良いかもしれ
ません。

@item @code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo}
@vindex skk-initial-search-jisyo
@vindex skk-kakutei-jisyo

これらは共有辞書、個人辞書という区分のいずれにも属しません。これらは個人
毎に持つものを使用するか、ユーザー間で共有しているものを使用します。その
性格から、辞書内容の更新は行われず、参照のみ行われます。また使用目的
から、通常は小さい辞書を使用します。
@end table

個人辞書、@code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo} は
Emacs のバッファに読み込んで検索を行います。共有辞書は設定により Emacs
のバッファに読み込んで使用するか、または辞書サーバ経由で使用します。

@node 送りありエントリと送りなしエントリ
@subsubsection 送りありエントリと送りなしエントリ

以下は個人辞書の一例です。

@cindex ;; okuri-ari entries.
@cindex ;; okuri-nasi entries.
@example
@group
;; okuri-ari entries.
たとe /例/[え/例/]/
もt /持/[つ/持/]/[って/持/]/[た/持/]/[て/持/]/[ち/持/]/[と/持/]/
たすk /助/[け/助/]/
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@dots{}
;; okuri-nasi entries.
てん /点/・/天/
ひつよう /必要/
さくじょ /削除/
へんこう /変更/
じゅんじょ /順序/
ぐん /群/郡/
こうほ /候補/
いち /位置/一/壱/
@dots{}
@end group
@end example

@noindent
@samp{てん /点/・/天/} を例にして説明します。これは @samp{てん} が見出し
語であり、その候補が、@samp{点}、@samp{・}、@samp{天} です。候補はそれぞ
れ、@samp{/} によって区切られています。SKK では、見出し語と候補群を合わ
せた @w{@samp{てん /点/・/天/}} の一行を@b{「エントリ」}と呼びます。
@cindex エントリ

辞書は単純なテキストファイルで、必ず下記の 2 つの行を持っています。

@example
@group
;; okuri-ari entries.
;; okuri-nasi entries.
@end group
@end example

@noindent
この 2 つの行は、それぞれ送り仮名あり、送り仮名なしのエントリの開始地点
を示すマークです。 @samp{;; okuri-ari entries.} までの行で @samp{;} を行
頭に持つ行はコメント行として無視されます。@samp{;; okuri-ari entries.}
以降にコメント行を含むことはできません。

@w{@samp{;; okuri-ari entries.}} と @w{@samp{;; okuri-nasi entries.}} の
間に囲まれた上半分の部分が送り仮名ありのエントリです。これを@b{「送りあ
りエントリ」}と呼びます。
@cindex 送りありエントリ
@w{@samp{;; okuri-nasi entries.}}以下の下半分部分が送り仮名なしのエント
リです。これを@b{「送りなしエントリ」}と呼びます。
@cindex 送りなしエントリ

@cindex 送りあり変換
@cindex 送りなし変換
送りありエントリを検索する変換を@b{「送りあり変換」}、送りなしエントリを
検索する変換を@b{「送りなし変換」}と呼びます。SKK では送り仮名の有無が変
換方法の 1 つの種別となっています。送り仮名がある変換では送りありエント
リのみが検索され、送り仮名がない変換では送りなしエントリのみが検索されま
す。

1 つの見出し語についてのエントリは 1 行内に書かれます。2 行以上にまたが
ることはできません。改行を含む候補については、@code{(concat "改\n行")}
のように、評価すると改行を該当個所に挿入するような Lisp プログラム
(@w{@pxref{プログラム実行変換}}) に候補を変換して辞書に収めています。

@cindex ローマ字プレフィックス
送りありエントリは、基本的には @samp{もt /持/} のようになっています。送
り仮名部分は、送り仮名をローマ字表現したときの 1 文字目
@footnote{あるかな文字をローマ字表現したときの 1 文字目を@b{「ローマ字プ
レフィックス」}と呼びます。}で表現されています。
この 1 エントリで @samp{持た}、@samp{持ち}、@samp{持つ}、@samp{持て}、
@samp{持と} の 5 つの候補に対応します。その 5 つの候補の送り仮名をローマ
字プレフィックスで表現すれば、いずれも @samp{t} になります。

@node 送りありエントリのブロック形式
@subsubsection 送りありエントリのブロック形式

個人辞書の送りありエントリには @samp{[} と @samp{]} に囲まれたブロックが
あります。これは、そのブロックの先頭にある平仮名を送り仮名に取る候補群で
す。

@example
@group
たとe /例/[え/例/]/
@dots{}
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@end group
@end example

この例で見ると、見出し語 @samp{たとe} の場合は @samp{え} を送り仮名とす
る 1 つのブロックから構成されています。見出し語 @samp{ふくm} の場合は、
@samp{ま}、@samp{み}、@samp{む}、@samp{め}、@samp{も} を送り仮名とする 5
ブロックに分けられています。

@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
この送り仮名毎のブロック部分は、@code{skk-henkan-okuri-strictly} あるい
は @code{skk-auto-okuri-process} のいずれかの変数が 非 @code{nil} で
ある場合に使用されます。その場合、検索において、見出し語の一致に加えて、
更に送り仮名もマッチするかどうかをテストします。例えば、

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
というエントリがあるとします。同じ見出し語 @samp{おおk} であっても、送り
仮名が @samp{き} であれば、候補は @samp{大} のみで @samp{多} は無視されま
す。
@footnote{@xref{送り仮名の自動処理, , skk-henkan-okuri-strictly}.
@xref{送り仮名の厳密なマッチ, , skk-auto-okuri-process}.
@xref{送り仮名の優先的なマッチ, , skk-henkan-strict-okuri-precedence}.
}

@vindex skk-process-okuri-early
現在 @url{http://openlab.jp/skk/dic.html} で配布されている共有辞書では、
@samp{[} と @samp{]} を使用した送り仮名毎のブロックの形式に対応していません。
個人辞書のみがこの形式で書き込まれていきます。
@code{skk-henkan-okuri-strictly} が @code{nil} であっても送り仮名のブロッ
ク形式で書き込まれます。@footnote{ただし @code{skk-process-okuri-early}
の値が @code{non-nil} であれば、送り仮名を決定する前に変換を開始すること
になるので、送り仮名を明示的に入力していても個人辞書にはブロック形式は作
られません。}

@node エントリの配列
@subsubsection エントリの配列

@cindex 辞書のソート方法
共有辞書では、送りありエントリは @w{@samp{;; okuri-ari entries.}} から順
に下方向に、見出し語をキーとして降順に配置されています。送りなしエントリ
は、@w{@samp{;; okuri-nasi entries.}} から順に下方向に、見出し語をキーと
して昇順に配置されています。

降順、昇順に配置されているのは、辞書サイズが大きいことに配慮して二分検索
を行うためです。
@footnote{ソートする際には、見出し語を unsigned-char と見なしています。
この順序は Emacs が 関数 @code{string<} で文字列を比較するときの順序であ
り、UNIX の @code{sort} コマンドでの標準の順序とは異なります。
Emacs のコマンド @code{sort-lines}を用いればファイルをこの順序でソートす
ることができます。Emacs のコマンド @code{sort-columns} は内部的に UNIX コ
マンドの @code{sort} を使っているので、辞書のソートには使えません。}

一方、個人辞書は上の例でも見たように、それぞれ
@w{@samp{;; okuri-ari entries.}}, @w{@samp{;; okuri-nasi entries.}} を基
点として、一番最後に変換を行ったものがそれぞれの最小ポイント
@footnote{正確に言えば、送りあり変換では @w{@code{skk-okuri-ari-min}+ 1}
の位置、送りなし変換では @w{@code{skk-okuri-nasi-min}+ 1} の位置。}に挿
入され辞書が更新されます。個人辞書は通常は共有辞書程はサイズが大きくない
ので、検索時にはそれぞれの基点から直線的に検索が行われます。

個人辞書で見つけられなかった候補については共有辞書から検索されます。そこ
で見つかり確定された場合は、その候補が個人辞書に取り込まれますが、その際
送りありエントリまたは送りなしエントリの最小ポイントに挿入されます。これ
は、次に同じ見出し語の検索が行われた場合に同候補を最初に出力するように
するためです。

@node 辞書に関する設定
@subsection 辞書に関する設定

DDSKK では、個人辞書と共有辞書というように複数の辞書を扱うことが可能です。
複数の辞書を同時に検索するのではなく、指定した順番に検索します。検索の順
番は、@code{skk-search-prog-list} という変数に検索したい順に辞書(正確には、
辞書検索プログラム)を指定します。

まず、DDSKK が複数辞書をどのように検索するかを説明します。
それから、 @code{skk-search-prog-list} で使用する関数および変数を説明しま
す。

@menu
* 複数辞書の検索方法::
* 辞書検索のための関数::
* 辞書ファイルを指定する変数::
* 辞書検索の設定の具体例::
@end menu

@node 複数辞書の検索方法
@subsubsection 複数辞書の検索方法
@findex skk-search-small-dic
@vindex skk-search-prog-list

複数辞書の検索方法は、@code{skk-search-prog-list} で指定された辞書を順番
に検索します。@code{skk-search-prog-list} の最初から検索し、候補が見つか
らなければ、次の辞書を検索します。最後の辞書までに候補が見つからなければ、
辞書登録モードに入ります。

説明を簡単にするため、個人辞書、その次に共有辞書を検索したい場合を例にし
ます。

前提条件として、辞書にはそれぞれ、次の候補のみ登録されているものとします。

個人辞書の内容。
@example
かな /仮名/
@end example

共有辞書の内容。
@example
かんじ /漢字/
@end example

@code{skk-search-prog-list} の設定を模式的に書くと、次のようになります。

@example
@group
 ((1番目に検索したい辞書。例では、個人辞書)
  (2番目に検索したい辞書。例では、共有辞書))
@end group
@end example

@code{skk-search-prog-list} に設定する実際のコードは、次のようになります。

@lisp
@group
((skk-search-jisyo-file skk-jisyo 0 t)
 (skk-search-small-dic))
@end group
@end lisp

上記の設定は、1行目が個人辞書の検索、2行目が共有辞書であるS辞書の検索を
表わします。

では、"仮名"を入力してみましょう。

@example
@kbd{K a n a}

@group
------ Buffer: foo ------
▽かな@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼仮名@point{}
------ Buffer: foo ------
@end group
@end example

"仮名"は個人辞書に登録されていたため、そのまま変換できました。
個人辞書に変換候補が見つかったため、共有辞書の検索は行われませんでした。

次に、"漢字"を入力します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▼漢字@point{}
------ Buffer: foo ------
@end group
@end example

"漢字"は個人辞書に登録されていません。ですので、個人辞書を検索したあと、
共有辞書の検索を行い、共有辞書に"漢字"が見つかったので、変換しました。

それでは、"仮名漢字"と続けて入力してみます。

@example
@kbd{K a n a k a n j i}

@group
------ Buffer: foo ------
▼かなかんじ
------ Buffer: foo ------

------ Minibuffer -------
[辞書登録] かなかんじ@point{}
------ Minibuffer -------
@end group
@end example

"仮名漢字"は、個人辞書、共有辞書に見つからないので、辞書登録モードに入り
ます。

@node 辞書検索のための関数
@subsubsection 辞書検索のための関数

辞書検索のための関数を使いこなすことで、より細かい辞書検索の方法を指定す
ることができます。

@table @code
@item skk-search-kakutei-jisyo-file
@findex skk-search-kakutei-jisyo-file

形式: (skk-search-kakutei-jisyo-file FILE LIMIT &optional NOMSG)

@cindex 確定変換
@vindex skk-kakutei-henkan-flag
@b{「確定変換」}を行う検索プログラム。検索対象の辞書ファイルは Emacs
のバッファに読み込まれます。検索対象のファイルから候補を見つけると、内部
変数 @code{skk-kakutei-henkan-flag} を立てて、いきなり確定します。このためユー
ザーが確定する必要はありません。

第 1 引数は検索対象辞書。

@cindex 二分検索
@cindex 直線的検索
第 2 引数は領域の大きさを指定します。一つの見出し語に対する変換動作に対
し、検索対象の領域の大きさが第 2 引数に指定された大きさより小さくなるま
では二分検索が行われ、最後に直線的検索が 1 回行われます。第 2 引数に
0 を指定すると常に直線的検索のみが行われます。

第 3 引数が @code{nil} であるとき、辞書をバッファに読み込むときにミニバッ
ファに読み込んでいる旨のメッセージを出力します。非 @code{nil} を与えると
出力をしません。

@item skk-search-jisyo-file
@findex skk-search-jisyo-file

形式: (skk-search-jisyo-file FILE LIMIT &optional NOMSG)

通常の検索を行うプログラム。個人辞書の検索や、共有辞書で辞書サーバを使わ
ない検索を行う場合はこのプログラムを使用します。辞書ファイルは Emacs
のバッファに読み込まれます。

第 1 引数、第 2 引数、第 3 引数の意味はいずれも
@code{skk-search-kakutei-jisyo-file} の場合と同様です。

@item skk-okuri-search
@findex skk-okuri-search

形式: (skk-okuri-search)

自動送り処理を行うプログラム。変数 @code{skk-auto-okuri-process} の値
が 非 @code{nil} のときだけ機能します。

個人辞書の送りありエントリを検索対象としているので、個人辞書のバッファを
流用します。そのため、専用の辞書バッファは作りません。

@item skk-search-server
@findex skk-search-server

形式: (skk-search-server FILE LIMIT &optional NOMSG)

辞書サーバ経由で検索するプログラム。辞書サーバが使用不能になると辞書ファイル
を Emacs のバッファに読み込んで検索を行います。

第 1 引数、第 2 引数、第 3 引数はいずれも
@code{skk-search-kakutei-jisyo-file} のそれと同じですが、第 2 引数及び第
3 引数は、辞書ファイルを Emacs のバッファに読み込んだときのみ利用されま
す。
@end table

@node 辞書ファイルを指定する変数
@subsubsection 辞書ファイルを指定する変数

@table @code
@item skk-kakutei-jisyo
@vindex skk-kakutei-jisyo

確定変換用の辞書。
@footnote{@xref{確定変換とその取り消し, , 確定変換}.}

この辞書は、標準の配布パッケージには含まれていないので、使用するのであれ
ばユーザー側で用意する必要があります。
@footnote{確定変換用辞書の見出し語の配列については、サイズが大きければ共
有辞書と同じ配列にして二分検索を行い、サイズが小さければ適当な配置で直
線的検索を行うことをお勧めします。@w{@ref{辞書の形式, , 共有辞書の配置}.}
を参照してください。}

@item skk-initial-search-jisyo
@vindex skk-initial-search-jisyo

通常は、個人辞書の前に検索を行う辞書。

変数 @code{skk-jisyo} に指定された辞書の前に検索が行われます。
@footnote{このため、この辞書を適当に切り替えることにより最初に出てくる候
補を操作することができます。例えば、複数の専門用語毎の辞書を用意しておい
て @code{skk-initial-search-jisyo} の値を切り替えることにより、専門分野
毎の専門用語を切り替えて入力することができます。}

この辞書は、標準の配布パッケージには含まれていないので、使用するのであれ
ばユーザー側で用意する必要があります。

@item skk-jisyo
@vindex skk-jisyo

個人辞書。DDSKK を一番最初に起動したときにファイルがなければ自動的に作ら
れます。

@code{skk-search-prog-list} の既定値では、個人辞書より先に検索するのは、
確定辞書と @code{skk-initial-search-jisyo} のみです。これはこのままにす
ることをお勧めします。

個人辞書の見出し語は、常に一番最近に変換された語が最小ポイントに挿入され
ます。
@footnote{その配列はバラバラなので、二分検索はできません。}

@item skk-large-jisyo
@vindex skk-large-jisyo

共有辞書。ユーザーの用途と資源に合わせて、S 辞書、M 辞書、L 辞書の中から選
びます。

通常は、関数 @code{skk-search-jisyo-file} の第 1 引数として指定します。

@item skk-aux-large-jisyo
@vindex skk-aux-large-jisyo

共有辞書。ユーザーの用途と資源に合わせて、S 辞書、M 辞書、L 辞書の中から選
びます。

通常は、関数 @code{skk-search-server} の第 1 引数として指定します。

@item skk-backup-jisyo
@vindex skk-backup-jisyo

個人辞書の予備 (バックアップ) 辞書。

これは、@code{skk-search-prog-list} に入れてはいけません。あくまで個人辞
書の予備辞書として指定してください。
@end table

@node 辞書検索の設定の具体例
@subsubsection 辞書検索の設定の具体例

@code{skk-search-prog-list} の具体例を挙げると以下の様になります。

@lisp
@group
((skk-search-kakutei-jisyo-file skk-kakutei-jisyo 10000 t)
 (skk-search-jisyo-file skk-initial-search-jisyo 10000 t)
 (skk-search-jisyo-file skk-jisyo 0 t)
 (skk-okuri-search)
 (skk-search-jisyo-file skk-large-jisyo 10000)
 (skk-search-server skk-aux-large-jisyo 10000))
@end group
@end lisp

上記の例では、
@enumerate
@item
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}の順に検索を行い、

@item
次に個人辞書を使って送り仮名の自動処理を行い、

@item
その後、@code{skk-large-jisyo} の検索を行い、

@item
最後に @code{skk-aux-large-jisyo} に辞書サーバ経由でアクセスしています。

@end enumerate
もし確定辞書で候補が見つかったらそのまま自動的に確定されます。1 回
@key{SPC} を押す動作に対し、プログラム側では新たな候補を見つけるまで上記
の動作を進めます。例えば、
@enumerate

@item
確定辞書では候補は見つけられなかったが @code{skk-initial-search-jisyo}
に候補がある場合、そこで一旦止まりユーザーにその候補を表示します。

@item
更に @key{SPC} が押されると、次は個人辞書を検索します。そこで候補が見つ
かり、しかもその候補が@code{skk-initial-search-jisyo} で見つけた候補とは
異なるものであったときは、そこでまた一旦止まりその候補をユーザーに表示し
ます。

以降、共有辞書についても同様の繰り返しを行います。
@end enumerate

@code{skk-search-prog-list} の設定方法としては、例えば
@code{skk-large-jisyo} に S 辞書か M 辞書を指定し、S 辞書、M 辞書は Emacs
のバッファに読み込んで検索して、@code{skk-aux-large-jisyo} に L 辞書を指
定し、L 辞書には辞書サーバ経由でアクセスする、という選択肢もあります。

@noindent
また、辞書サーバ経由のアクセスも決して遅くはないので、

@lisp
(skk-search-jisyo-file skk-large-jisyo 10000)
@end lisp

@noindent
を削除するという選択肢もあります。
@footnote{ちなみに辞書ファイルを指定する変数の値が @code{nil} であれば、
そのファイルを引数とした検索プログラムが @code{skk-search-prog-list}
に指定されていても、その検索は行われません。例えば、
@code{skk-search-prog-list} に上記変更をする代わりに

@lisp
(setq skk-large-jisyo nil)
@end lisp

@noindent
という設定をしてもふつう結果は同じです。}
@footnote{@file{skk-auto.el} を読みこむと、

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストが @code{skk-search-prog-list} に自動的に追加されます。実際
には、@file{skk-auto.el} は必要に応じてオートロードされるので明示的に読みこむ必
要はありません。オートロードされるのは、具体的には
@code{skk-auto-okuri-process} を非 @code{nil} に設定したとき、 あるいは

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストを @code{skk-search-prog-list} に明示的に指定したときなどで
す。}
@footnote{@file{skk-server.el} を読みこむと、

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストが @code{skk-search-prog-list} に自動的に追加されます。実際
には、@file{skk-server.el} は必要に応じてオートロードされるので明示的に読みこむ
必要はありません。オートロードされるのは、具体的には
@code{skk-server-host} または @code{skk-servers-list} を非 @code{nil}
に設定したとき、あるいは

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストを @code{skk-search-prog-list} に明示的に指定したときなどで
す。}


@node 個人辞書中の単語の削除
@subsection 個人辞書中の単語の削除
@cindex 個人辞書エントリの削除
@cindex 誤登録

誤って個人辞書
@footnote{@xref{辞書の形式, 個人辞書}.}に登録した単語を削除する機能があ
ります。

削除したい単語を変換により求め、その単語が得られた時点で @kbd{X} を入力
します。ミニバッファに確認が出るので、それに対し @kbd{y e s}と答えます。
すると、個人辞書の対応するエントリが削除されます。現在のバッファに先程入
力した誤りの変換結果も削除されます。

@example
さいきてき /再起的/
@end example

@noindent
というエントリを誤って登録したという仮定で、その誤登録を削除する場合を例
にとって説明します。

@example
@kbd{S a i k i t e k i @key{SPC}}

@group
------ Buffer: foo ------
▼再起的
------ Buffer: foo ------
@end group

@kbd{X}

@group
------------------ MiniBuffer ------------------
Really purge ``さいきてき /再起的/''?(yes or no)
------------------ MiniBuffer ------------------
@end group

@kbd{y e s @key{RET}}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group

@end example

@node 個人辞書の保存動作
@subsection 個人辞書の保存動作
@cindex 個人辞書
@cindex 個人辞書のオートセーブ
@kindex C-x C-c

個人辞書の保存動作について説明します。

個人辞書の保存が行われる場合として、次の 3 通りがあります。

@enumerate
@item
@kbd{C-x C-c} (または @kbd{M-x save-buffers-kill-emacs}) により Emacs を
終了させようとした場合。

@item
@kbd{M-x skk-save-jisyo} と入力するか、メニューバーより @samp{Save
Jisyo} を選択した場合。

@item
変数 @code{skk-jisyo-save-count} で指定された回数、辞書の更新を行った結
果として、自動保存 (オートセーブ) 機能が働くとき。
@end enumerate

保存動作を分析して考えます。まず、 Emacs に読み込んだ個人辞書が更新され
ているかどうかを調べます。更新されていたら保存動作に入ります。Emacs の個
人辞書バッファを一時ファイルに保存して、そのファイルサイズが現存の (セー
ブ前の) 個人辞書より小さくないかどうかをチェックします。個人辞書より小さ
いときは、保存動作を継続するかどうか、確認のための質問がされます。
@footnote{通常の使用の範囲では @kbd{M-x skk-purge-from-jisyo} した場合、あ
るいは個人辞書をユーザーが意図的に編集した場合、複数の Emacs で DDSKK を
使用した場合などに、個人辞書が小さくなることがあります。他の場合はバグの
可能性があります。}

@example
@group

--------------------------- Minibuffer -----------------------------
New ~/.skk-jisyo will be 11bytes smaller.  Save anyway?(yes or no)
--------------------------- Minibuffer -----------------------------

@end group
@end example

@noindent
ここで @kbd{n o @key{RET}} と答えた場合は、そこで保存動作が中止され、個
人辞書は以前の状態のままになります。@kbd{y e s @key{RET}} と答えた場合は
元の個人辞書を退避用の辞書に退避し、一時ファイルに保存した新しい個人辞書
を @code{skk-jisyo} に保存します。

もし、一時ファイルのサイズが 0 である場合は、なんらかの異常と考えられる
ので、保存動作は直ちに中止されます。その場合は

@lisp
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end lisp

@noindent
で Emacs を終了させ、個人辞書 (@code{skk-jisyo})、および個人辞書の退避用
辞書 (@code{skk-backup-jisyo}) をチェックするよう強くお勧めします
@footnote{@code{skk-jisyo} が既に壊れていても、@code{skk-backup-jisyo}
にそれ以前の個人辞書が残っている可能性があります。}。

@table @code
@item skk-compare-jisyo-size-when-saving
@vindex skk-compare-jisyo-size-when-saving

この変数の値を @code{nil} に設定すると、保存前の個人辞書とのサイズ比較
を行いません。

@item skk-jisyo-save-count
@vindex skk-jisyo-save-count

この変数で指定された回数、個人辞書の更新を行った場合に個人辞書の自動保
存が行われます。既定値は 50 です。また、この値を @code{nil} にすると、
個人辞書の自動保存機能が無効になります。

ここで、個人辞書の更新回数は確定回数と一致します。また、同じ候補について
確定した場合でもそれぞれ 1 回と数えられます
@footnote{これは、個人辞書の最小ポイントに、常に最後に変換を行ったエン
トリを移動させるために、エントリ数、候補数が全く増えていなくとも、確定に
より個人辞書が更新されているからです。}。
@end table

@node 変換及び個人辞書に関する統計
@subsection 変換及び個人辞書に関する統計

DDSKK では、Emacs の終了時に変換及び個人辞書に関する統計を取っています。
その結果は ファイル @file{~/.skk-record} に保存されます。保存される内容
は以下のような形式です。

@example
@group
Sun Jul 28 09:38:59 1996  登録:   4  確定:  285  確定率:  98%  語数:  3042
@end group
@end example

上記の「語数」の欄は 1 行を 1 語として数えているので、1 つの見出し語に対
し複数の候補を持っている場合、2 つ目以降の候補を無視しています。

@table @code
@item skk-record-file
@vindex skk-record-file

統計の結果を保存するファイル名を指定します。

@item skk-keep-record
@vindex skk-keep-record

この変数の値を @code{nil} に設定すると、本節で説明した統計機能を無効に
します。ただし数値であれば、@code{skk-record-file} を指定数値の行数よ
り大きくしません。

@item skk-count-private-jisyo-candidates-exactly
@vindex skk-count-private-jisyo-candidates-exactly

この変数の値を非 @code{nil} に設定すると、「語数」の数え方を変更します。
具体的には、 1 行を 1 語として数えるのではなく、正確に語数を数えます。
なお、その分時間がかかります。また、この場合でも @samp{[} と @samp{]}
に囲まれた送り仮名毎のブロック形式内は数えません。
@end table

@node 辞書候補数の数えあげ
@subsection 辞書候補数の数えあげ
@cindex Menu Bars
@cindex メニューバー
@findex skk-count-jisyo-candidates
@kindex M-x skk-count-jisyo-candidates

コマンド @kbd{M-x skk-count-jisyo-candidates} を使うと、辞書の候補数を数
えることができます。

@example
@group

@kbd{M-x skk-count-jisyo-candidates}

--------------- MiniBuffer --------------
Jisyo file: (default: /your/home/.skk-jisyo) ~/
--------------- MiniBuffer --------------
@end group
@group

@kbd{. s k k - j i s y o @key{RET}}

-------------- Echo Area --------------
Counting jisyo candidates... 100% done
-------------- Echo Area --------------
@end group

@group

------ Echo Area ------
3530 candidates
------ Echo Area ------
@end group
@end example

ただし、@samp{[} と @samp{]} に囲まれた送り仮名毎のブロック形式内は数えませ
ん。

また、メニューバーが使用できる環境では、メニューバーを使ってこのコマンド
を呼び出すことができます。@w{@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.}

@node 辞書バッファの文字コードの設定
@subsection 辞書バッファの文字コードの設定

@table @code
@item skk-jisyo-code
@vindex skk-jisyo-code

この変数の値は辞書ファイルの漢字コードを決定します。

この変数は以下のような値を取ります
@footnote{Mule 2.3 では @w{@code{*euc-japan*}}, @w{@code{*sjis*}},
@w{@code{*junet*}} などのシンボルを指定することができます。
Emacs 20 では、@code{euc-jp}, @code{shift_jis}, @code{junet} などのシン
ボルを指定することができます。}。

@itemize @bullet
@item @w{``euc''}, @w{``ujis''}, @w{``sjis''}, @w{``jis''} などの文字列
@item Emacs によって coding system と認められるシンボル
@item Emacs によって coding system を示すのに使われるシンボル
@item nil
@end itemize

既定値は @code{nil} です。この場合、DDSKK 側で辞書の漢字コードを設定する
ことはせず、Emacs に任せます。
@end table

@node 辞書バッファのメジャーモード
@subsection 辞書バッファのメジャーモード
@cindex @file{dabbrev.el}
@cindex @samp{ *SKK-JISYO.L*}
@findex fundamental-mode
@vindex major-mode
@vindex mode-name
@vindex skk-large-jisyo
@cindex 辞書バッファの名付け規則

辞書検索プログラムを実行すると、必要ならば辞書が Emacs のバッファに読み
込まれます。このバッファを辞書バッファと呼びます。

辞書バッファの名前は、

「空白+@samp{*}+辞書ファイル名(ディレクトリ抜き)+@samp{*}」

という規則に基づいて付けられます。例えば、変数 @code{skk-large-jisyo} の
値が

@w{@file{/usr/local/share/skk/SKK-JISYO.L}}

であるとき、これに対する辞書バッファ名は、

@w{@samp{ *SKK-JISYO.L*}}

@noindent
となります。

このバッファのメジャーモードは @code{fundamental-mode} です。しかし、諸
般の事情により、変数 @code{major-mode} の値をシンボル @w{skk-jisyo-mode}、
変数 @code{mode-name} の値を文字列 @samp{SKK dic} としています
@footnote{これは、Emacs の @file{dabbrev.el} の機能との調和を考えての措
置です。
Dabbrev においては、現在のバッファと同じモードの他のバッファを検索して
abbreviation の展開を行うように設定することができるのですが、仮に辞書
バッファにおける変数 @code{major-mode} の値が @w{fundamental-mode} のま
まだとすると、 Dabbrev が辞書バッファを検索してしまう可能性があります。
この措置によって、そのような事態を回避しています。}。

@node 辞書バッファのbuffer-file-name
@subsection 辞書バッファの@code{buffer-file-name}
@vindex buffer-file-name
@findex save-some-buffers

Emacs には @code{save-some-buffers} という関数があります。この関数は、ファ
イルに関連付けられている各バッファについて、変更があればファイルに保存し
ますが、実際に保存するかどうかをユーザに質問します。

Emacs のコマンドには @kbd{M-x compile} のように、
@code{save-some-buffers} を呼び出すものがあります。もし、個人辞書の辞書
バッファがファイル名と関連付けられていたとしたら、こうしたコマンドを
実行するたびに個人辞書を保存するかどうか質問されるので、面倒です。

DDSKK では、このような事態を避けるため、辞書バッファにおける変数
@code{buffer-file-name} の値を @code{nil} に設定しています。

@node 辞書のアノテーション(注釈)
@subsection 辞書のアノテーション(注釈)
@vindex skk-show-annotation
@vindex skk-annotation-show-as-message
@findex skk-annotation-update-jisyo-format
@findex skk-annotation-add
@findex skk-annotation-kill
@findex skk-annotation-remove
@findex skk-annotation-function

辞書にアノテーション (注釈)を付けることができます@footnote{
Viper 対策はまだ行われていません。@file{~/.viper} に次のように書いて下
さい。

@display
(viper-harness-minor-mode "skk-annotation")
@end display
}。

まだ、アノテーション機能を一度も使用していない場合は次の操作を行って下さ
い。個人辞書を読みこみ、辞書を読み込んだバッファで

@display
M-x skk-annotation-update-jisyo-format
@end display

を実行して下さい@footnote{
@code{;} の文字を含んだ候補は、eval すると @code{;} になる Lisp 式として
quote されて辞書候補として収められなければなりません。
@code{skk-annotation-update-jisyo-format} を実行することにより、この作業
を行うことができます。アノテーション機能が使われる前の既存の辞書(個人
辞書、SKK-JISYO.L)については是非行っておいて下さい}。

アノテーションを付けるには、アノテーションを付けたい単語を確定した直後
に同じバッファで

@display
M-x skk-annotation-add
@end display

とします。アノテーションを編集するバッファが開いて、カレントバッファにな
ります。そこへアノテーションを付けます。編集が終わったら @kbd{C-c C-c} し
ます。

@code{M-x skk-annotation-add} したものの、アノテーションを付けずに置きた
いときは、

@display
M-x skk-annotation-kill
@end display

とします。

また、最後に確定した候補についてのアノテーションを取り去りたいときは、

@display
M-x skk-annotation-remove
@end display

とします。

アノテーションを表示させるには、変数 @code{skk-show-annotation} を
@code{non-nil} にします。辞書の候補にアノテーションがあればエコーエリ
ア @footnote{変数 @code{skk-annotation-show-as-message}を @code{nil}
にした場合は、other-window を一時的に開いてアノテーションを表示します。
other-window はその候補について確定するか、その候補の選択を止める (次
の候補を選択したり、quit したり) すると自動的に閉じられます。}に表示し
ます。

上記の動作でユーザが付けたアノテーションを「ユーザアノテーション」
と呼びます。ユーザアノテーションは、次の形式で個人辞書に保存されます。

@display
「きかん /期間/機関;*機関投資家/基幹;*基幹業務/」
@end display

このように @code{;} の直後に @code{*} の文字が自動的に振られます。これは
ユーザが独自に付けたアノテーションであることを示します @footnote{
@code{*} の文字は変換時には表示されません}。

一方、共有辞書に元々付けられているアノテーションを「システムアノテー
ション」と呼び、これは @code{;} の直後に @code{*} の文字を伴いません。
例えば、辞書の形式は次のようになります。

@display
「いぜん /以前;previous/依然;still/」
@end display

システムアノテーションは、L 辞書等に採用されています。

ユーザアノテーションとシステムアノテーションを区別することで、ユーザアノ
テーションだけを表示したり、あるいはその逆を行うことが可能です。
@code{skk-annotation-function} に表示したいアノテーションを
@code{non-nil} と判定する関数を書きます。

@lisp
@group
(setq skk-annotation-function
      #'(lambda (annotation)
          (eq (aref annotation 0) ?*)))
@end group
@end lisp

上記の例では、アノテーションの先頭が @code{*} で始まる「ユーザアノテー
ション」の場合に @code{t} を返すので、ユーザアノテーションだけを表示し
ます。

@node アノテーションとして Wikipedia を表示する
@subsection アノテーションとして Wikipedia を表示する

候補にアノテーションがない場合、アノテーションに代えて Wikipedia
(@url{http://ja.wikipedia.org/}) による解説を表示することができます。

▼モードで候補を表示しているときに @key{TAB} を押すと、
skk-annotation-wikipedia-sources で指定された順で解説を取得しエコーエリ
アに表示@footnote{変数 skk-show-tooltip が Non-nil の場合、Tooltip で表
示します。} します。

@example
B o k u j o u

----- Buffer: foo -----
▽ぼくじょう@point{}
----- Buffer: foo -----

@kbd{SPC}

----- Buffer: foo -----
▼牧場@point{}
----- Buffer: foo -----

@kbd{TAB}

----------------------------- Echo Area ------------------------------
牧場（ぼくじょう）とは、ウシ、ウマなどの家畜を飼養する施設。訓読みされ
てまきばと呼ばれることもある。
----------------------------- Echo Area ------------------------------
@end example

エコーエリアに解説が表示されている最中に @kbd{C-o} を押すと、
関数 @code{browse-url} を用いて、その解説の元となった URL をブラウズしま
す。

@defvr {ユーザ変数} skk-annotation-show-wikipedia-url
デフォルトは nil。Non-nil とすると、見出し語を @kbd{SPC} で変換した際に
その見出し語の注釈が存在しない場合に限り、 Wikipedia (日本語版) でその語
が参照されるための URL を注釈として表示します。表示中に @kbd{C-o} を押す
と、関数 @code{browse-url} を用いてその URL をブラウズします。
@end defvr

@defvr {ユーザ変数} skk-annotation-wikipedia-sources
アノテーションとして表示する Wikimedia のソースを指定します。
デフォルトは ja.wikipedia、en.wiktionary、simple.wikipedia、en.wikipedia、
ja.wiktionary の順です。
@end defvr

@node DDSKK 以外のツールを用いた辞書変換
@section DDSKK 以外のツールを用いた辞書変換

@menu
* skk-lookup::                  Lookup を用いた辞書変換
* skk-look::                    look コマンドを用いた辞書変換
@end menu

@node skk-lookup
@subsection skk-lookup
@cindex @file{skk-lookup.el}
@cindex Lookup
@vindex skk-lookup-search-agents
@findex skk-lookup-search

@file{skk-lookup.el} を使用すると、辞書検索ツールの Lookup
(@url{http://openlab.jp/edict/lookup/}) で検索できる辞書を用いて単語
の候補を出すことができるようになります @footnote{@file{skk-lookup.el}
は @file{skk-look.el} とは別ものです。}。

DDSKK のインストール過程で @code{(require 'lookup)} が成功する場合は
@file{skk-lookup.el} も自動的にインストールされます。
Lookup がインストールされているにも関わらず、うまく @file{skk-lookup.el} が
インストールされない場合は、@file{SKK-CFG} を編集して @file{lookup.el}
があるパスを @code{ADDITIONAL_LISPDIR} に設定し、再度 DDSKK をインストールして
下さい。
@footnote{関数 @code{skk-lookup-search} が @file{skk-autoloads.el} に
追加されます (@pxref{辞書検索のための関数}).}。

@file{~/.skk} に以下のように設定します。

@lisp
@group
(setq skk-search-prog-list
      (append skk-search-prog-list
              (list
               '(skk-lookup-search))))
@end group
@end lisp

@noindent
DDSKK が用意している検索プログラムの中で最も遅いため@footnote{6 倍速
CD-ROM ドライブではストレスを感じる程、遅くありませんでした。ローカルマ
シンのハードディスクにコピーして利用すると、速度的にはサーバと遜色ありま
せん。ちなみに広辞苑の第四版を epwutil で @code{squeeze} すると辞書デー
タのサイズは 45MB 弱になります。}、@code{skk-search-server} の後ろに持っ
てきてサーバの検索より後にします。

Lookup の agent で利用するのは、 @code{lookup-search-agents} から ndkks,
ndcookie, ndnmz を取り去ったものです
@footnote{@code{skk-lookup-search-agents} にセットして検索するように
しています。Lookup とは異なる設定をする場合、この変数の設定を変更すれば
可能です}。

@node skk-look
@subsection skk-look
@cindex @file{skk-look.el}

@file{skk-look.el} は、 @code{look} コマンドを使って次の 3 つの機能を提供します
@footnote{@file{skk-look.el} は @file{skk-lookup.el} とは名前が似てい
ますが全くの別ものです}。

@menu
* 英単語の補完::
* 英単語をあいまいに変換して取り出す::
* 英単語をあいまいに変換して取り出した後、更に再帰的な英和変換を行う::
@end menu

@node 英単語の補完
@subsubsection 英単語の補完
@vindex skk-use-look

@code{skk-use-look} を @code{non-nil} に設定すると @file{skk-look.el}
が使用できるようになります。

例えば、 @file{~/.skk} で以下のように設定します。

@lisp
(setq skk-use-look t)
@end lisp

@noindent
SKK abbrev mode が拡張されて、@code{look} コマンドを使用した補完が有効
になります。

@example
@kbd{/abstr}

@group
------ Buffer: foo ------
▽abstr
------ Buffer: foo ------
@end group

@kbd{@key{TAB}}

@group
------ Buffer: foo ------
▽abstract
------ Buffer: foo ------
@end group

@end example

と補完してくれます。通常の補完と同様に、@kbd{.} で次の補完候補、@kbd{,} で
ひとつ前の補完候補に移動できます。

SKK 形式の英和辞書@footnote{SKK 形式の英和辞書 edict が提供されています。
@xref{辞書の入手}.}があれば、ここから @key{SPC} を押して英和変換ができます。

@node 英単語をあいまいに変換して取り出す
@subsubsection 英単語をあいまいに変換して取り出す
@vindex skk-search-excluding-word-pattern-function

見出し語にアスタリスク (*) を入れて、@key{SPC} を押すと英単語をあいまい
にして変換できます。

@example

@group
------ Buffer: foo ------
▽abstr*
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼abstract
------ Buffer: foo ------
@end group

@end example

確定すると、@samp{abstr*} を見出し語、@samp{abstract} を候補とする
エントリが個人辞書に追加されます。このようなエントリを追加したくない場合、
ユーザー変数、@code{skk-search-excluding-word-pattern-function} を適切に
設定します。

例えば次のような設定です。

@lisp
@group
(add-hook 'skk-search-excluding-word-pattern-function
          ;; 返り値が non-nil の時、個人辞書に取り込まない。
          ;; KAKUTEI-WORD を引数にしてコールされるので、不要でも引数を取る
          ;; 必要あり
          #'(lambda (kakutei-word)
              (and skk-abbrev-mode
                   (save-match-data
                     ;; SKK-HENKAN-KEY が "*" で終わるとき
                     (string-match "\\*$" skk-henkan-key)))))
@end group
@end lisp


@node 英単語をあいまいに変換して取り出した後、更に再帰的な英和変換を行う
@subsubsection 英単語をあいまいに変換して取り出した後、更に再帰的な英和変換を行う
@vindex skk-look-recursive-search
@vindex skk-look-expanded-word-only

@code{skk-look-recursive-search} の値を @code{non-nil} にセットして下
さい。

@example
▽abstr* (SPC)

  ---> ▼abstract (SPC) -> ▼アブストラクト (SPC) -> ▼抽象 (SPC)
    -> ▼abstraction (SPC) -> ▼アブストラクション
@end example

@noindent
このように英単語 + その英単語を見出し語にした候補の「セット」を変換
結果として出力することができます。

この際、@code{skk-look-expanded-word-only} の値が @code{non-nil} であ
れば、再帰検索に成功した英単語の「セット」だけを出力することができます
(再帰検索で検出されなかった英単語は無視して出力しません) 。

SKK 辞書に

@example
   abstract /アブストラクト/抽象/
   abstraction /アブストラクション/
@end example

@noindent
というエントリがあることを前提としています
@footnote{edict 辞書、@file{SKK-JISYO.edict} があれば例えば、

@lisp
@group
(setq skk-search-prog-list
      (append skk-search-prog-list
              (list
               '(skk-search-jisyo-file "/your-path/SKK-JISYO.edict" 0 t))))
@end group
@end lisp

@noindent
のように設定することにより、 edict 辞書を使用できます。}。

@node 飾りつけ
@section 飾りつけ

@menu
* 仮名文字のローマ字プレフィックスのエコー::
* 入力モードを示すモードラインの文字列の変更::
* 入力モードを示すカーソル色に関する設定::
* 変換候補一覧の表示方法::
* ▼モードにおける変換候補のハイライト表示::
* 変換候補の更なる装飾::
* XEmacs & Emacs 21 のモードライン::
@end menu

@node 仮名文字のローマ字プレフィックスのエコー
@subsection 仮名文字のローマ字プレフィックスのエコー

@defvr {ユーザ変数} skk-echo

この変数の値は、仮名文字のローマ字プレフィックス
@footnote{@xref{辞書の形式, ローマ字プレフィックス}.}
のエコーの有無を制御します。
@end defvr

変数 @code{skk-echo} の値が 非 @code{nil} であれば、仮名文字のローマ字
プレフィックスが、入力時点で一旦現在のバッファに挿入され、続く母音の入
力の際に、かな文字に変換された時点で現在のバッファから消去されます。

@example
@group
@kbd{t}

------ Buffer: foo ------
t
------ Buffer: foo ------

@end group
@group
@kbd{a}

------ Buffer: foo ------
た
------ Buffer: foo ------
@end group
@end example

変数 @code{skk-echo} の値が @code{nil} であれば、仮名文字のローマ字プレ
フィックスのエコーは行われません。これを上記の例で考えると、@samp{t} が現
在のバッファに挿入されず、続く母音 (@kbd{a}) が入力されたとき @samp{た}
の文字が挿入されます。

@defvr {ユーザ変数} skk-prefix-hiragana-face
@end defvr
@defvr {ユーザ変数} skk-prefix-katakana-face
@end defvr
@defvr {ユーザ変数} skk-prefix-jisx0201-face

それぞれかなモード、カナモード、JISX0201 モードにおけるローマ字プレフィッ
クスのフェイスを指定します。
@end defvr

@node 入力モードを示すモードラインの文字列の変更
@subsection 入力モードを示すモードラインの文字列の変更

下記の変数の値を変更することにより、モードラインにおいて入力モードを示す文字
列が変更されます。

@table @code
@item skk-latin-mode-string
@vindex skk-latin-mode-string

アスキーモードを示す文字列。標準では、``SKK''。

@item skk-hiragana-mode-string
@vindex skk-hiragana-mode-string

かなモードを示す文字列。標準では、``かな''。

@item skk-katakana-mode-string
@vindex skk-katakana-mode-string

カナモードを示す文字列。標準では、``カナ''。

@item skk-jisx0208-latin-mode-string
@vindex skk-jisx0208-latin-mode-string

全英モードを示す文字列。標準では、``全英''。

@item skk-abbrev-mode-string
@vindex skk-abbrev-mode-string

SKK abbrev モードを示す文字列。標準では、``aあ''。

@end table

@node 入力モードを示すカーソル色に関する設定
@subsection 入力モードを示すカーソル色に関する設定

@table @code
@item skk-use-color-cursor
@vindex skk-use-color-cursor

この変数の値が非 @code{nil} ならば、カーソルに色付けします。@code{nil}
ならば、この機能を無効にします。

標準では、ウィンドウシステムを使用していてなおかつ色表示が可能な場合に限
り、この機能が有効になります。
@end table

この機能が有効になっているとき、以下の変数の値を変更することで、各モード
におけるカーソルの色が変更されます。

@table @code
@item skk-cursor-default-color
@vindex skk-cursor-default-color

SKK モードがオフであることを示すカーソル色。標準では、カーソルのある該当
フレームにおける標準のカーソル色を使います。

@item skk-cursor-hiragana-color
@vindex skk-cursor-hiragana-color

かなモードであることを示すカーソル色。標準では、背景の明暗により
``coral4'' または ``pink'' を用います。

@item skk-cursor-katakana-color
@vindex skk-cursor-katakana-color

カナモードであることを示すカーソル色。標準では、背景の明暗により
``forestgreen'' または ``green'' を用います。

@item skk-cursor-jisx0201-color
@vindex skk-cursor-jisx0201-color
JISX0201 モードであることを示すカーソル色。標準では、背景の明暗により
``blueviolet'' または ``thistle" を用います。

@item skk-cursor-jisx0208-latin-color
@vindex skk-cursor-jisx0208-latin-color

全角英字モードであることを示すカーソル色。標準では、``gold'' を用います。

@item skk-cursor-latin-color
@vindex skk-cursor-latin-color

アスキーモードであることを示すカーソル色。標準では、背景の明暗により
``ivory4'' または ``gray'' を用います。

@item skk-cursor-abbrev-color
@vindex skk-cursor-abbrev-color

skk abbrev モードであることを示すカーソル色。標準では、``royalblue'' を
用います。

@end table

@node 変換候補一覧の表示方法
@subsection 変換候補一覧の表示方法

変換候補一覧の表示方法は大きく以下の 4 つに分かれます。

@itemize @bullet
@item エコーエリア
@item 現在のウインドウと別のウイントウ (ポップアップ)
@item 現在のウインドウ (インライン)
@item ツールティップ
@end itemize

ここではその表示方法の制御について解説します。

@defvr {ユーザ変数} skk-show-inline

この値が非 @code{nil} の場合、候補一覧を現在のポイント位置でインライン表
示します。

また、値が @code{vertical} の場合は各候補を縦にインライン表示します
(XEmacs を除く)。

@defvr {ユーザ変数} skk-inline-show-face

インラインで候補を表示する際のフェイスを指定します。

候補文字列のフェイス属性をそのまま使いたい場合は @code{nil} に設定して下
さい。
@end defvr

@defvr {ユーザ変数} skk-inline-show-background-color

インラインで候補を表示する際の背景色を指定します。

@code{skk-inline-show-face} または
@code{skk-treat-candidate-appearance-function} で背景色が指定されていない
文字に対してのみ作用します。
@end defvr
@end defvr

@defvr {ユーザ変数} skk-show-tooltip

この値が非 @code{nil} の場合、候補一覧をツールティップとして表示します。
この設定はまた、注釈 (アノテーション) の表示方法も同時に制御します。

@defvr {ユーザ変数} skk-tooltip-face

ツールティップで候補を表示する際のフェイスを指定します。

候補文字列のフェイス属性をそのまま使いたい場合は @code{nil} に設定して下
さい。
@end defvr
@end defvr

@defvr {ユーザ変数} skk-show-candidates-always-pop-to-buffer

この値が非 @code{nil} の場合、画面を上下に分割したうえで、変換一覧を専用
の「*候補*バッファ」で表示します。

候補一覧表示中に、この値を動的に切り換える手段が用意されています。

@defvr {ユーザ変数} skk-show-candidates-toggle-display-place-char
@kindex C-f

これは標準では @kbd{C-f} に設定されています。このキーを候補一覧表示時に
タイプすると、候補一覧の表示位置をエコーエリアとバッファとで切り替えます。
@end defvr
@end defvr

@code{skk-show-inline}, @code{skk-show-tooltip},
@code{skk-show-candidates-always-pop-to-buffer} の 3 変数ともデフォルトは
@code{nil} です。その状態では、候補一覧はエコーエリアに表示されます。

また、もしこれらのうち 2 つ以上が非 @code{nil} の場合、優先順位は上記解
説順となります。

@node ▼モードにおける変換候補のハイライト表示
@subsection ▼モードにおける変換候補のハイライト表示
@cindex @file{canna.el}
@cindex @file{rgb.txt}

@table @code
@item skk-use-face
@vindex skk-use-face

この変数の値が非 @code{nil} であれば、Emacs のフェイス機能を使って変換
候補をハイライト表示します。

@cindex Overlays
@cindex Extents
@cindex Text Properties
このハイライト表示には Emacs のオーバーレイ (overlay) の機能を使います
@footnote{以前のバージョンではテキスト属性 (text property) を使用してい
ました。

オーバーレイ属性はテキスト属性と異なり、テキストの一部とは見なされません。
そのため、テキストのコピーの際にオーバーレイ属性は保存されません。その他
にも、オーバーレイの移動やその属性の変更はバッファの変更とは見なされない
こと、オーバーレイの変更はバッファのアンドゥリストに記録されないこと、な
どが特徴として挙げられます。

なお、XEmacs にはオーバーレイ機能はありません。代わりに extent というも
のが用意されているのでそれを利用します。}。

@item skk-henkan-face
@vindex skk-henkan-face

この変数の値はフェイスであり、このフェイスによって変換候補がハイライト表
示されます。標準では、背景の明暗により ``black/darkseagreen2'' 又は
``white/darkolivegreen'' を用います。
@end table

変数 @code{skk-henkan-face} には、既存のフェイス
@footnote{Emacs 標準 では @w{default}, @w{modeline}, @w{region},
@w{secondary-selection}, @w{highlight}, @w{underline},
@w{bold}, @w{italic}, @w{bold-italic} があります。}を指定できますが、新
たにフェイスを作ることもできます。そのために、以下の関数が用意されていま
す。

@table @code
@item skk-make-face
@findex skk-make-face

形式: (skk-make-face FACE)

この関数は、引数 FACE と同じ名前のフェイスを作成して、そのフェイスを返し
ます。フェイスの前景色・背景色は、引数 FACE によって、例えば以下の例のよ
うに決定されます。

@example
@group
(skk-make-face 'DimGray/PeachPuff1)
(setq skk-henkan-face 'DimGray/PeachPuff1)
@end group
@end example

この場合、前景色は DimGray に、背景色は PeachPuff1 になります。

もうひとつ例を挙げます。

@lisp
(skk-make-face 'RosyBrown1)
(setq skk-henkan-face 'RosyBrown1)
@end lisp

この場合、前景色は RosyBrown1 になります。背景色はもちません。つまり、バッ
ファの背景色がそのまま見えます。
@end table

@node 変換候補の更なる装飾
@subsection 変換候補の更なる装飾

変換候補についてユーザの任意の加工を施すために
変数 @code{skk-treat-candidate-appearance-function} を用意してあります。

@defvr {ユーザ変数} skk-treat-candidate-appearance-function

変数 @code{skk-treat-candidate-appearance-function} に適切な形式で関数を
収めることにより、変換候補をユーザの任意に加工することができます。

「適切な形式」とは、次のとおりです。

@enumerate
@item
引数を 2 つ取ること。

@item
第 1 引数は文字列として扱うこと。これは加工前の文字列に相当する。

@item
第 2 引数が @code{nil} の時は通常の変換時、非 @code{nil} の時は候補一覧表
示時を表すものとして扱うこと。

@item
返り値は以下のいずれかとすること。

@table @asis
@item - 文字列

この場合、この文字列は候補と注釈を両方含みうるものとして処理される。

@item - cons cell (候補 . 注釈)

この場合、候補はもう注釈を含まないものとして処理される。注釈については先
頭が ";" かどうかを調べた上で処理される。

@item - cons cell (候補 . (セパレータ . 注釈))

この場合、候補はもう注釈を含まないものとして処理される。セパレータは通常
の ";" の代わりに利用される。注釈はもうセパレータを含まないものとして処
理される。
@end table
@end enumerate

ファイル @file{etc/dot.skk} に設定例があるほか、サンプルとして関数
@code{skk-treat-candidate-sample1} と @code{skk-treat-candidate-sample2}
を用意してあります。
ファイル @file{~/.skk} に次のいずれかを書いてみて変換候補の装飾を試して
ください。

@example
(setq skk-treat-candidate-appearance-function
      'skk-treat-candidate-sample1)
@end example

@example
(setq skk-treat-candidate-appearance-function
      'skk-treat-candidate-sample2)
@end example

@end defvr

@node XEmacs & Emacs 21 のモードライン
@subsection XEmacs & Emacs 21 のモードライン

XEmacs および Emacs 21 では以下の機能が使用できます。

@menu
* インジケータ::
* アイコン::
@end menu

@node インジケータ
@subsubsection インジケータ
@vindex skk-indicator-use-cursor-color
DDSKK のインジケータをモードラインの左に表示している場合@footnote{デフォルト
では、左です。@w{@xref{起動と終了}.}}、
カーソルの色と同じ色が付くようになりました。また、モードラインの DDSKK のイ
ンジケータをマウスなどのポインティングデバイスの第 2ボタンをクリックする
とメニューが表示されます。

DDSKK のインジケータの色を付けない場合は、変数
@code{skk-indicator-use-cursor-color} を @code{nil} にします。

インジケータに独自色を使いたい場合は、以下のフェイスを設定します。
この場合カーソルの色は参照しません。

Emacs 21 の場合

@vindex skk-e21-hiragana-face
@vindex skk-e21-katakana-face
@vindex skk-e21-jisx0208-latin-face
@vindex skk-e21-jisx0201-face
@vindex skk-e21-abbrev-face

@display
@code{skk-e21-hiragana-face} 
@code{skk-e21-katakana-face} 
@code{skk-e21-jisx0208-latin-face} 
@code{skk-e21-jisx0201-face} 
@code{skk-e21-abbrev-face} 
@end display

XEmacs の場合

@vindex skk-xemacs-hiragana-face
@vindex skk-xemacs-katakana-face
@vindex skk-xemacs-jisx0208-latin-face
@vindex skk-xemacs-latin-face
@vindex skk-xemacs-jisx0201-face
@vindex skk-xemacs-abbrev-face

@display
@code{skk-xemacs-hiragana-face}
@code{skk-xemacs-katakana-face}
@code{skk-xemacs-jisx0208-latin-face}
@code{skk-xemacs-latin-face}
@code{skk-xemacs-jisx0201-face}
@code{skk-xemacs-abbrev-face}
@end display

@node アイコン
@subsubsection アイコン
@vindex skk-show-icon
@vindex skk-icon

変数 @code{skk-show-icon} の値を非 @code{nil} と設定することにより、モー
ドラインに SKK のアイコンが表示されます。
アイコンの画像ファイル(skk.xpm)は、変数 @code{skk-icon} で定義されていま
す。

@node ユーザガイダンス関連
@section ユーザガイダンス関連

@menu
* エラーなどの日本語表示::
* 助言的案内メッセージの表示::
@end menu

@node エラーなどの日本語表示
@subsection エラーなどの日本語表示

標準では、エラー、メッセージおよびミニバッファでのプロンプトは、英語で表
示されます。

@defvr {ユーザ変数} skk-japanese-message-and-error

この変数の値を非 @code{nil} に設定すると、エラー、メッセージおよびミニ
バッファでのプロンプトを日本語で表示します。標準では @code{nil} です。
@end defvr

@defvr {ユーザ変数} skk-show-japanese-menu

この変数の値を非 @code{nil} に設定すると、メニューを日本語で表示します。
@end defvr

@node 助言的案内メッセージの表示
@subsection 助言的案内メッセージの表示

@c http://mail.ring.gr.jp/skk/200704/msg00036.html
@defvr {ユーザ変数} skk-verbose

この変数の値を非 @code{nil} に設定すると、SKK が従来表示しなかったような
入力・変換中の助言的メッセージが表示されます。具体的には、

@itemize @bullet
@item ▽モードで一定時間キー入力がなかったとき、プレフィックスによる変換
プログラム切換え方法をメッセージで案内します。

@item ▼モードで一定時間キー入力がなかったとき、アノテーション機能の使い
方に関してメッセージで案内します。
@end itemize
@end defvr

@defvr {ユーザ変数} skk-verbose-wait

助言的メッセージを表示するまでの待ち時間 (秒)。標準は 2.5 秒です。
@end defvr

@node VIP/VIPERとの併用
@section VIP/VIPERとの併用
@cindex VIP
@cindex VIPER
@cindex @file{vip.el}
@cindex @file{viper.el}

@table @code
@item skk-use-viper
@vindex skk-use-viper
@c XXX VIP 3.7 について言及する。

この変数の値を非 @code{nil} に設定すると、VIPER に対応します。
@end table

VIPER については @ref{Top, , VIPER, viper, VIPER Manual}. を参照してください。

また、VIPER の前身である VIP にも対応します。ただし、正式に対応している
バージョンは 3.5 のみです。これは Mule 2.3 に標準添付します
@footnote{ちなみに、VIP 3.5 の作者は、SKK の原作者でもある佐藤雅彦教授で
す。VIP 3.5 の発展版である VIPER は現在もメンテナンスされています。Emacs
19, 20 には、VIP 、VIPER とも標準添付します。}。

@node I-search関連
@section I-search関連
@cindex I-search
@cindex Incremental search
@cindex @file{~/.skk}

@menu
* 起動時の入力モードの指定::
* 間に空白等を含む文字列の検索::
@end menu

@node 起動時の入力モードの指定
@subsection 起動時の入力モードの指定

@table @code
@item skk-isearch-use-previous-mode
@vindex skk-isearch-use-previous-mode

この変数の値が非 @code{nil} であれば、次のインクリメンタル・サーチ起動
時の入力モードは、前回のインクリメンタル・サーチでの入力モードになります。

@item skk-isearch-start-mode
@vindex skk-isearch-start-mode

この変数の値は、インクリメンタル・サーチの起動時の入力モードを決定します。
ただし変数 @code{skk-isearch-use-previous-mode} の値が非 @code{nil} な
らば、そちらの機能が優先されます。

この変数は以下の値を取り得ます。

@table @asis
@item latin

アスキーモード

@item hiragana

かなモード

@item jisx0208-latin

全英モード
@end table
@end table

@node 間に空白等を含む文字列の検索
@subsection 間に空白等を含む文字列の検索
@cindex Incremental regexp search

@samp{検索} という文字列をインクリメンタル・サーチにより検索する場合に、
バッファが以下のような状態になっていることがあります。

@example
@group
-------- Buffer: foo --------
この行末から始まる文字列を検
索して下さい。
-------- Buffer: foo --------
@end group
@end example

このような場合のために、Emacs は正規表現によるインクリメンタル・サーチを
提供しています。DDSKK はこの正規表現によるインクリメンタル・サーチにも対
応しているため、空白や改行を含んだ検索も可能です。

@table @asis
@item @kbd{M-x isearch-forward-regexp}
@findex isearch-forward-regexp
@kindex M-x isearch-forward-regexp
@kindex C-u C-s
@kindex M-C-s

前方への正規表現によるインクリメンタル・サーチ。
@kbd{C-u C-s} または @kbd{M-C-s} で起動します。

@item @kbd{M-x isearch-backward-regexp}
@findex isearch-backward-regexp
@kindex M-x isearch-backward-regexp
@kindex C-u C-r
@kindex M-C-r

後方への正規表現によるインクリメンタル・サーチ。
@kbd{C-u C-r} または @kbd{M-C-r} で起動します。
@end table

以下は空白や改行の処理を制御する変数です。

@table @code
@item skk-isearch-whitespace-regexp
@vindex skk-isearch-whitespace-regexp

この変数の値は正規表現です。この正規表現にマッチする要素は、正規表現によ
るインクリメンタル・サーチにおいては、単語を区切る要素ではないと判断され
ます。この変数の既定値は以下のようになっています。

@example
"\\(\\s \\|[ \t\n\r\f]\\)*"
@end example
@end table

変数 @code{skk-isearch-whitespace-regexp} の値を変更することで、正規表現
によるインクリメンタル・サーチを拡張することができます。例えば、電子メー
ルの引用部分を検索する場合を考えます。

@example
> 引用部分も検
> 索できる。
@end example

上記のうち、「検索」という語は 2 行にわたっているうえ引用マークが挿入さ
れています。ここで

@lisp
(setq skk-isearch-whitespace-regexp "\\(\\s \\|[ \t\n\r\f<>|]\\)*")
@end lisp

@noindent
と設定することにより、「検索」を検索できるようになります。

@node skk-init-fileのコンパイル
@section @code{skk-init-file}のコンパイル

@table @code
@item skk-byte-compile-init-file
@vindex skk-byte-compile-init-file

この変数の値が非 @code{nil} であれば、DDSKK の起動時に DDSKK の設定ファ
イル (標準では @file{~/.skk}) を必要に応じてバイトコンパイルします。

この変数の値が @code{nil} であれば、DDSKK の設定ファイルをバイトコンパイ
ルしたファイルを消去します。

この機能を有効にしたい場合は、@file{~/.emacs} に

@lisp
(setq skk-byte-compile-init-file t)
@end lisp

@noindent
と記述します。
@footnote{この変数は DDSKK の設定ファイルが読み込まれる前に調べられるの
で、DDSKK の設定ファイルに上記の設定を書いてもこの機能は有効になりません。}
@end table

@node picture-modeとの併用
@section @code{picture-mode}との併用
@cindex @key{BS}
@cindex move-to-column
@cindex move-to-column-force
@cindex @file{picture.el}
@cindex picture-mode

SKK モードを @code{picture-mode} において使用した場合は、以下のような問
題点があります。ただし、これらは @code{picture-mode} の問題なので、現在
のところ DDSKK 側では対処していません。

@enumerate
@item
SKK モードで全角文字を入力した場合に、@key{BS} で全角文字を消すことができ
ません。現状では、後方にある文字を消したい場合は、その文字にポイントを合
わせ、@kbd{C-c C-d} で一文字づつ消す必要があります。

@item
コマンド @code{picture-movement-up} や @code{picture-movement-down} によ
り上下に全角文字を挿入した場合に、桁がずれる場合があります。
@end enumerate

関数 @code{move-to-column-force} の中で使用されている関数
@code{move-to-column} の引数として、全角文字を無視した桁数が与えられるこ
とがあり、そのときカーソル移動ができないため、これらの問題が生じます。

@node サーバ関連
@section サーバ関連

@table @code
@item skk-servers-list
@vindex skk-servers-list

この変数を使うと、複数のホスト上の辞書サーバを使い分けることができます。

この変数の値は、辞書サーバ毎の情報リストです。各リストは 4 つの要素か
ら成ります。4 つの要素はそれぞれ、ホスト名、サーバ名 (フルパス)、サーバ
が読みこむ辞書名、サーバが使用するポート番号、となります。ただし、辞書、
およびポート番号は、サーバ自身が決定することもあるため、そのような場合は
@code{nil} として構いません。

例えば、以下のように設定します。

@lisp
@group
(setq skk-servers-list
      '(("host1" "/your/path/to/skkserv" nil nil)
        ("host2" "/your/path/to/skkserv" nil nil)))
@end group
@end lisp

上記の設定の場合、まず host1 上のサーバと接続します。接続できなくなると、
次に host2 上のサーバと接続します。

@item skk-server-report-response
@vindex skk-server-report-response

この変数の値が非 @code{nil} であれば、変換時に、サーバの送出する文字を
受け取るまでに関数 @code{accept-process-output} が実行された回数を報告
します。

@item skk-server-inhibit-startup-server
@vindex skk-server-inhibit-startup-server

この変数を @code{nil} に設定すると、SKK サーバと接続できない場合に、
SKK サーバプログラムを @code{call-process} して立ち上げようと試みます
(デフォルト値は @code{t} です)。inetd 経由で立ち上げられる多くの SKK
サーバは、@code{call-process} で立ち上げることができませんが、
@file{skkserv} のように立ち上げることができるサーバを利用している場合
には、この変数を @code{nil} に設定するのが良いかもしれません。

@item skk-server-remote-shell-program
@vindex skk-server-remote-shell-program

この変数には、リモートシェルのプログラム名を指定します。既定値は、システ
ム依存性を考慮する必要があるため、以下の Emacs Lisp コードを評価すること
により決定されています。

@lisp
@group
(or (getenv "REMOTESHELL")
    (and (boundp 'remote-shell-program) remote-shell-program)
    (cond
     ((eq system-type 'berkeley-unix)
      (if (file-exists-p "/usr/ucb/rsh") "/usr/ucb/rsh" "/usr/bin/rsh"))
     ((eq system-type 'usg-unix-v)
      (if (file-exists-p "/usr/ucb/remsh") "/usr/ucb/remsh" "/bin/rsh"))
     ((eq system-type 'hpux) "/usr/bin/remsh")
     ((eq system-type 'EWS-UX/V) "/usr/ucb/remsh")
     ((eq system-type 'pcux) "/usr/bin/rcmd")
     (t "rsh")))
@end group
@end lisp
@end table

@node ローマ字入力以外の入力方式
@chapter ローマ字入力以外の入力方式

DDSKK は、SKK 旧来のローマ字式かな入力 (訓令式、ヘボン式) 方式のほか、各
種キー配列と入力方式に対応しています。

@menu
* AZIK::
* ACT::
* TUT-code::
* かな入力と親指シフト::
@end menu

@node AZIK
@section AZIK
@cindex AZIK

AZIK (エイズィック) は QWERTY 配列をベースとした拡張ローマ字入力です。
一般のローマ字入力がそのまま使える上での拡張であることが特徴です。

@url{http://hp.vector.co.jp/authors/VA002116/azik/azikindx.htm}

@defvr {ユーザ変数} skk-use-azik

この値が非 @code{nil} であれば AZIK 拡張が有効となります。@file{~/.skk}
に

@lisp
(setq skk-use-azik t)
@end lisp

@noindent
と書きます。
@end defvr

@node ACT
@section ACT
@cindex ACT

ACT は AZIK の考え方を Dvorak 配列に適用し、Dvorak 配列でかなを快適にタ
イプできるように考案された方式です。

@url{http://www1.vecceed.ne.jp/~bemu/act/act_index.html}

@defvr {ユーザ変数} skk-use-act

この値が非 @code{nil} であれば ACT 拡張が有効となります。@file{~/.skk}
に

@lisp
(setq skk-use-act t)
@end lisp

@noindent
と書きます。
@end defvr

@node TUT-code
@section TUT-code
@cindex TUT-code

TUT-code は 2 ストローク系の日本語直接入力方式の一つです。

@url{http://plone.crew.sfc.keio.ac.jp/groups/tut-code}

使用するには、SKK のインストール時にいくつかのファイルをインストールする
必要があります。SKK ソースの @file{tut-code} ディレクトリにある

@itemize @bullet
@item skk-tutcdef.el
@item skk-tutcode.el
@end itemize

@noindent
を、SKK ソースのトップディレクトリにコピーして、SKK のインストールを再度
行います。

@xref{DDSKK のインストール}.

その後、@file{~/.skk} に

@lisp
(require 'skk-tutcdef)
@end lisp

@noindent
と書きます。

@node かな入力と親指シフト
@section かな入力と親指シフト
@cindex かな入力
@cindex 親指シフト
@cindex NICOLA

DDSKK はローマ字式ではない、いわゆるかな入力方式をサポートします。具体的
には

@itemize @bullet
@item 旧 JIS 配列でのかな入力
@item 親指シフト方式でのかな入力
@end itemize

@noindent
に対応しています。これを使うにはまず、nicola-ddskk 拡張パッケージをイン
ストールする必要があります。SKK ソースディレクトリの @file{nicola} ディ
レクトリに移動し、ドキュメントに従ってインストールしてください。

@url{http://openlab.jp/skk/skk/main/nicola/README.ja}

つづいて設定をします。

@defvr {ユーザ変数} skk-use-kana-keyboard

これを非 @code{nil} に設定すると、かな入力サポートが SKK 起動時に有効に
なります。

@lisp
(setq skk-use-kana-keyboard t)
@end lisp

@end defvr

@defvr {ユーザ変数} skk-kanagaki-keyboard-type

この設定で、かな入力サポートの種類を切換えます。

@table @code
@item 106-jis

日本語 106 キーボード (旧 JIS 配列) でのかな入力に対応します。

@lisp
(setq skk-kanagaki-keyboard-type '106-jis)
@end lisp

@item nicola-jis

日本語 106 キーボード (旧 JIS 配列) での親指シフトエミュレーションに対応
します。

@lisp
(setq skk-kanagaki-keyboard-type 'nicola-jis)
@end lisp

@item omelet-jis

@code{nicola-jis} と同様ですが、より入力しやすい配列が考慮されています。

@lisp
(setq skk-kanagaki-keyboard-type 'omelet-jis)
@end lisp
@end table
@end defvr

かな入力方式使用時の■モードでは以下のコマンドなどが役に立ちます。

@table @asis
@item @kbd{F1 1}
@kindex F1 1

かな入力方式での特殊キー定義の一覧を表示します。

@item @kbd{F1 2}
@kindex F1 2

かな入力方式でのかなキー配列を表示します。

@item @kbd{F12} または @kbd{M-x skk-kanagaki-toggle-rom-kana}
@kindex F12
@kindex M-x skk-kanagaki-toggle-rom-kana

かな入力方式とローマ字入力方式とを切り換えます。
@end table

なお、親指シフト方式については以下が参考になります。

@url{http://nicola.sunicom.co.jp/}

@node SKKに関する情報
@chapter SKKに関する情報

@menu
* 最新情報::
* SKKメーリングリスト::
* SKK関連ソフトウェア::
* SKK辞書について::
* 辞書ツール::
* SKKの作者::
* SKKの歴史::
* このマニュアルについて::
* 謝辞::
@end menu

@node 最新情報
@section 最新情報

DDSKK についての最新情報は、

@display
@url{http://openlab.jp/skk/}
@end display

@noindent
から得ることができます。

SKK の開発は、 CVS によってなされています。CVS を使って最新の SKK を取得
する場合、CVS account を取得して開発に参加される場合は、以下を参照してく
ださい。

@display
@url{http://openlab.jp/skk/cvs-ja.html}
@end display

最新版 DDSKK の変更内容と更に過去の変更点については以下のリソースを参照
してください。

@display
@url{http://openlab.jp/skk/skk/main/READMEs/NEWS.ja}
@end display

また、将来のバージョンにおける拡張アイディアについては、TODO としてまと
められています。

@display
@url{http://openlab.jp/skk/skk/main/READMEs/TODO.ja}
@end display

SKK Openlab では、開発者、文章の整備にご協力いただける方、テスター、よろ
ずものを言う人などなど、常に募集しています。また要望、拡張の具体的アイディ
アがあれば、メーリングリストに連絡いただけることを期待します。

@display
@xref{SKKメーリングリスト}.
@end display

@node SKKメーリングリスト
@section SKKメーリングリスト

SKK Openlab メーリングリストは、統一された一つの ML です。利用者用、開発
者用などと分かれていない他、SKK 辞書、DDSKK の開発議論が中心ですが、 SKK
サーバやフロントエンド、 SKK 辞書ツールの話題なども議論の範囲に入ります。

@table @asis
@item メーリングリストに参加する場合

@email{skk-subscribe@@ring.gr.jp} 宛てに空のメールを送って下さい。確認の
為のメッセージが指定されたアドレス宛に送信されます。その確認の為のメッセー
ジに対して、返信することで加入手続きは終了します。

@item メーリングリストから脱会する場合

@email{skk-unsubscribe@@ring.gr.jp} 宛てに空のメールを送って下さい。確認
の為のメッセージが指定されたアドレス宛に送信されます。その確認の為のメッ
セージに対して、返信することで脱退手続きは終了します。

@item 登録したアドレスの変更する場合

古いアドレスについて一旦 unsubscribe して、新しいアドレスから再度
subscribe して下さい。

@item 記事の投稿

@email{skk@@ring.gr.jp} へ送ります。メーリングリストに登録されている人全
員にメールが配信されます。

@item 過去ログの閲覧

@url{http://mail.ring.gr.jp/skk}

@url{news://news.ring.gr.jp/ring.openlab.skk}
@end table

@node SKK関連ソフトウェア
@section SKK関連ソフトウェア

SKK 関連ソフトウェアに関しては、以下の URL にリンクをまとめてありますの
で参照してください。

@table @asis

@item SKK 辞書 Wiki におけるリンク集
@url{http://openlab.jp/skk/wiki/wiki.cgi?page=%A5%EA%A5%F3%A5%AF%BD%B8}
@end table

@node SKK辞書について
@section SKK辞書について

SKK 辞書は多くのユーザの方々から提供された辞書によりコピーフリーの辞書と
しては最大規模の辞書になっています。今後もこの方式により SKK 辞書をより
充実したものにしていきたいと思います。

SKK 辞書に追加したい単語、誤登録として削除したい単語があるようでしたら、
@url{http://openlab.jp/skk/registdic.cgi} にて Web/cgi を利用
した登録・削除希望フォームを運用しておりますので、是非ご利用下さい。

@node  辞書ツール
@section 辞書ツール

SKK 辞書に関するツールには、Perl, C の各言語により書かれていましたが、
Perl によるツールは現在十分メンテナンスされていません。現在は C, ruby の
プログラムが開発・メンテナンスされています。

@table @asis
@item 辞書メンテナンスツール
@url{http://openlab.jp/skk/wiki/wiki.cgi?page=%BC%AD%BD%F1%A5%E1%A5%F3%A5%C6%A5%CA%A5%F3%A5%B9%A5%C4%A1%BC%A5%EB}
@end table

@node SKKの作者
@section SKKの作者

SKK の原作者は、現京都大学の
@uref{http://www.sato.kuis.kyoto-u.ac.jp/member/masahiko-j.html,
佐藤雅彦教授}です。

現在の DDSKK は、大勢のボランティアの貢献により成立しています。以下は確
認されている貢献者名です。ここに入っていない貢献者がおられる場合、email
address が変更になり credit をこれに合わせたい場合には、追加、修正いたし
ますので、ご遠慮なく SKK Openlab の管理人
@w{@email{skk-owner@@ring.gr.jp}} までご一報ください。

@itemize @asis
@item 中津山 恒 @email{hisashi@@rst.fujixerox.co.jp}
@item 小関 吉則 @email{kose@@emailizard.tamra.co.jp}
@item 小野 孝男 @email{takao@@hirata.nuee.nagoya-u.ac.jp}
@item 松井孝雄/MATUI Takao @email{mat@@nuis.ac.jp}
@item 進藤裕志 @email{shindo@@super.ees.saitama-u.ac.jp}
@item 沈志勇 @email{jshen@@cas.org}
@item 柘植 正大 @email{ma-tsuge@@kdd.co.jp}
@item Akihiro Motoki  @email{amotoki@@dd.iij4u.or.jp}
@item Chikanobu Toyofuku @email{unbound@@papaya.juice.or.jp}
@item Daiki Ueno @email{ueno@@unixuser.org}
@item EGUCHI Satoshi @email{eguchi@@kyoto-wu.ac.jp}
@item Eiji Obata @email{obata@@suzuki.kuee.kyoto-u.ac.jp}
@item FUKANO Masaaki @email{fukano-m@@alp.cs.uec.ac.jp}
@item Fukaya Shigeru @email{SFUKAYA@@oracle.co.jp}
@item FURUE Hideyuki @email{furue@@kke.co.jp}
@item GUNJI Takao @email{gunji@@sils.shoin.ac.jp}
@item G. Yoshida @email{grothendieck@@max.hi-ho.ne.jp}
@item Haru Mizuno @email{mizu@@cs3.cs.oki.co.jp}
@item Haru'yasu Ueda @email{hal@@sics.se}
@item Hideki Sakurada @email{sakurada@@kuis.kyoto-u.ac.jp}
@item Hiroya Murata @email{lapis-lazuli@@pop06.odn.ne.jp}
@item Hiroyuki KUROSAKI  @email{noir@@st.rim.or.jp}
@item Hisao Kuroda @email{kuroda@@msi.co.jp}
@item IIDA Yosiaki @email{iida@@ring.gr.jp}
@item IRIE Tetsuya @email{irie@@t.email.ne.jp}
@item ISHIKAWA Naoya @email{ml@@be.to}
@item Jun-ichi Nakamura @email{nakamura@@pluto.ai.kyutech.ac.jp}
@item Katuya Tomioka @email{tomioka@@culle.l.chiba-u.ac.jp}
@item Kazuo Hirokawa @email{hirokawa@@rics.co.jp}
@item Kazushi Marukawa @email{kazushi@@kubota.co.jp}
@item Keisuke Nishida @email{kxn30@@po.cwru.edu}
@item Kenichi OKADA @email{okada@@opaopa.org}
@item Kenji Rikitake @email{kenji@@reseau.toyonaka.osaka.jp}
@item Kenji Yamashita @email{kenji@@cs.titech.ac.jp}
@item Kentaro Fukuchi @email{fukuchi@@users.sourceforge.net}
@item KIHARA Hideto @email{deton@@m1.interq.or.jp}
@item Kimura Chikahiro @email{kimura@@oa1.kb.nec.co.jp}
@item Kimura Fuyuki @email{fuyuki@@hadaly.org}
@item Kitamoto Tsuyoshi @email{fmv5200na8x@@yahoo.co.jp}
@item Koichi MORI @email{kmori@@onsei2.rilp.m.u-tokyo.ac.jp}
@item KOIE Hidetaka (鯉江英隆) @email{hide@@koie.org}
@item Koji Uchida @email{uchida@@cfd.tytlabs.co.jp}
@item KURIHARA Kenichi @email{kenichi_kurihara@@nifty.com}
@item Makoto MATSUSHITA @email{matusita@@ics.es.osaka-u.ac.jp}
@item Manabu Kawashima @email{kaw@@lp.nm.fujitsu.co.jp}
@item Martin Buchholz @email{martin@@xemacs.org}
@item Masahiko Suzuki @email{suzmasa@@sm.sony.co.jp}
@item Masahiro Doteguchi @email{xdote@@rp.open.cs.fujitsu.co.jp}
@item Masakazu Takahashi @email{masaka-t@@ascii.co.jp}
@item Masatake YAMATO @email{masata-y@@is.aist-nara.ac.jp}
@item NAKAJIMA Mikio @email{minakaji@@osaka.email.ne.jp}
@item MINOURA Itsushi @email{minoura@@uni.zool.s.u-tokyo.ac.jp}
@item MITA Yuusuke @email{clefs@@mail.goo.ne.jp}
@item MIYOSHI Tsutomu @email{minkov@@fuzzy.or.jp}
@item Motohiko Mouri @email{mouri@@jaist.ac.jp}
@item Murata Shuuichirou @email{mrt@@notwork.org}
@item Naoki HAMADA @email{nao@@mimo.jaist-east.ac.jp}
@item Naoki Wakamatsu @email{naoki-w@@ht-net21.ne.jp}
@item NEMOTO Takashi @email{tnemoto@@mvi.biglobe.ne.jp}
@item NISHIDA Keisuke @email{knishida@@nn.iij4u.or.jp}
@item Norio Maeda  @email{nmaeda@@dd.iij4u.or.jp}
@item ONODA Arata  @email{onoto@@ma.nma.ne.jp}
@item Rei FURUKAWA @email{furukawa@@tcp-ip.or.jp}
@item Ryoichi Hashimoto @email{gnu@@ipri.go.jp}
@item SAKAI Kiyotaka @email{ksakai@@kso.netwk.ntt-at.co.jp}
@item Satoshi Harauchi @email{satoshi@@sys.sdl.melco.co.jp}
@item Seiichi NAMBA @email{sn@@asahi-net.email.ne.jp}
@item Sekita Daigo @email{sekita@@mri.co.jp}
@item Shigeru OKUMURA @email{shigeru@@okunet.gr.jp}
@item Shuhei KOBAYASHI @email{shuhei@@aqua.ocn.ne.jp}
@item Shuji Ashizawa @email{ashizawa@@zuken.co.jp}
@item SIMOYAMA Takasi @email{simo@@festa.or.jp}
@item SL Baur @email{steve@@altair.xemacs.org}
@item sphere @email{sphere@@pop12.odn.ne.jp}
@item Stephen Turnbull @email{turnbull@@sk.tsukuba.ac.jp}
@item SUZUKI Hitoshi @email{sigh@@kuzirabekon.econ.nagasaki-u.ac.jp}
@item TAKAHASHI Kaoru @email{kaoru@@kaisei.org}
@item Takao KAWAMURA @email{kawamura@@ike.tottori-u.ac.jp}
@item Takeshi OHTANI @email{ohtani@@iias.flab.fujitsu.co.jp}
@item Tatsuya Kinoshita @email{tats@@vega.ocn.ne.jp}
@item Thierry Emery @email{Thierry.Emery@@nmu.alcatel.fr}
@item TOKUYA Junichi @email{tokuya@@crab.fuji-ric.co.jp}
@item Tomotaka SUWA @email{cooper@@saitama.fujimic.fujisankei-g.co.jp}
@item Tomoyuki Hiro @email{hiro@@momo.it.okayama-u.ac.jp}
@item Toru YANO @email{toru@@maid.ne.jp}
@item Toyonobu Yoshida @email{toyono-y@@is.aist-nara.ac.jp}
@item Tsugutomo Enami @email{enami@@ptgd.sony.co.jp}
@item Tsukamoto Tetsuo @email{czkmt@@remus.dti.ne.jp}
@item TSUMURA Tomoaki @email{tsumura@@kuis.kyoto-u.ac.jp}
@item Tsuyoshi AKIHO @email{akiho@@sky.email.ne.jp}
@item Wataru Matsui @email{matsui@@atr-rd.atr.co.jp}
@item Wataru Matsui @email{matsui@@gf.hm.rd.sanyo.co.jp}
@item YAGI Tatsuya @email{ynyaaa@@ybb.ne.jp}
@item YAMASHITA Junji @email{ysjj@@unixuser.org}
@item Yoshida Toyonobu @email{toyono-y@@is.aist-nara.ac.jp}
@item Yukihiro Nakai @email{ynakai@@redhat.com}
@item Yoshiki Hayashi @email{yoshiki@@xemacs.org}
@item YOSHIZAWA Masahiro @email{manbou@@ceres.dti.ne.jp}
@item Yuh Ohmura @email{yutopia@@t3.rim.or.jp}
@item Yukiyoshi Kameyama @email{kameyama@@kuis.kyoto-u.ac.jp}
@end itemize

@node SKKの歴史
@section SKKの歴史

SKK の成り立ちと歴史に関しては以下の URL を参照してください。

@table @asis
@item SKK の誕生秘話

@url{http://openlab.jp/skk/born-ja.html}

@item ``SKK = I''

@url{http://openlab.jp/skk/SKK.html}

@item SKK の歴史 (付 Emacs の歴史の一部)

@url{http://openlab.jp/skk/history-ja.html}
@end table

@node このマニュアルについて
@section このマニュアルについて

本マニュアルは、SKK オープンラボの有志の貢献により、従来のマニュアルに加
筆修正したものです。

@node 謝辞
@section 謝辞

DDSKK の開発は、@uref{http://openlab.jp, Ring Server Open
Laboratory} (オープンラボラトリ) に @samp{SKK Openlab} として参加する形
で行われています。@samp{SKK Openlab} は Ring から共有ディスク、CVS 及び
ML の提供を受けています。オープンラボラトリの運営は、完全にボランティア
により行われております。Ring 並びにオープンラボラトリにかかわる皆さんに
深く感謝いたします。

(以降の記載は、SKK の原作者、佐藤雅彦教授により記載された旧来のマニュア
ルのものですが、歴史的意義を踏まえて、そのまま掲載します。)

SKK の設計方針は TAO/ELIS 上の日本語入力システム Kanzen の影響を受けてい
ます。Kanzen のデモを行ってくださり、また Kanzen を使う機会を与えてくだ
さった NTT の竹内郁雄さんに感謝します。

第 1 版の辞書作成のための読みの入力を行ってくださった東北大学電気通信研
究所佐藤研究室の 安藤大君、猪岡美紀さん、奥川淳一君、佐々木昭彦君、佐藤
克志君、山岸信寛君に感謝します。

SKK 辞書第 2, 3, 4, 5, 6, 7, 8 版作成のためのデータを提供してくださっ
た方々に感謝します。

SKK 辞書第 6, 7 版作成にあたり協力してくださった高橋裕信氏に感謝します。

@node よくある質問とその回答(FAQ)
@chapter よくある質問とその回答(FAQ)

@c @include{skk-faq.texi}

これは SKK に対するよくある質問と、それに対する回答集です。

@menu
* Introduction::                SKK のなぜなに。
* Installation::                SKK の入手から導入まで。
* Customization::               SKK の基本設定からお好みのカスタマイズまで。
* Dictionaries::                SKK 辞書関連。
* Miscellaneous::               SKK の活用法その他。
@end menu

@node Introduction
@section SKK のなぜなに

@menu
* Q.1-1 Daredevil SKK って SKK とは違うのですか?::
* Q.1-2 SKK はシンプルなのが長所だったのでは?::
* Q.1-3 DDSKK はどの Emacs で使えますか?::
* Q.1-4 DDSKK はどんなオペレーティングシステムで使えますか?::
* Q.1-5 APEL って何? 必要ですか?::
* Q.1-6 SKK における「モード」の意味とは?::
@end menu

@node Q.1-1 Daredevil SKK って SKK とは違うのですか?
@unnumberedsubsec Q.1-1 Daredevil SKK って SKK とは違うのですか?

SKK Openlab で開発、リリースされる SKK は、京大の佐藤先生が中心になっ
て開発していた SKK と区別するために、@samp{Daredevil SKK} と呼ぶことに
しました。その略称は @samp{DDSKK} で、SKK Openlab で最初に
@samp{Daredevil SKK} としてリリースされた version は 11.1 です (オリジ
ナルの version を継承しました)。

なお、@samp{Daredevil} の名前の採択は、開発陣の一人が講読している某ラ
ジオ英会話講座の、ある日のスキット名が「Daredevil なんとか」で、その内
容は「とにかくやってみよう。うぎゃぁぁぁ、やられたぁ」というものでした。
これがあまりに自分の開発ポリシーに合致していた、ということに由来します。

@node Q.1-2 SKK はシンプルなのが長所だったのでは?
@unnumberedsubsec Q.1-2 SKK はシンプルなのが長所だったのでは?

かような議論は 10 年来行われてきており、結論は出ていませんが、事実として
現在まで開発が続けられています。

@display
「シンプルな操作性の維持と多機能化・高機能化は両立できる」
@end display

@noindent
というのが現在の開発陣の考えであるようです。

SKK が Simple Kana to Kanji conversion program の略である通り、かなを漢
字に変換するルーチンの簡単さが SKK を定義付けています。その周辺の拡張に
関する制約は基本的にはありません。

多機能化と言っても多くはユーザーオプションによって無効にすることができま
すし、@file{skk.el} 本体が複雑化しないようにモジュール化されています。

@node Q.1-3 DDSKK はどの Emacs で使えますか?
@unnumberedsubsec Q.1-3 DDSKK はどの Emacs で使えますか?

基本的には、GNU Emacs と Mule 機能付きの XEmacs で使えます。

対応する Emacs のバージョンについては以下をご覧ください。

@display
@xref{このバージョンのSKKについて}.
@end display

@node Q.1-4 DDSKK はどんなオペレーティングシステムで使えますか?
@unnumberedsubsec Q.1-4 DDSKK はどんなオペレーティングシステムで使えますか?

基本的にサポート対象の Emacs がその OS で動いているなら、SKK の基本的
な機能は動くはずです。 Windows でも Mac OS X でも使えます。

拡張機能については、UNIX の各種コマンドを前提としているものがいくつか
あります (@code{look} や @code{ispell} など)。これらがお使いの OS にも
あれば該当の拡張機能も基本的には使えるでしょう。

Mac 版 Emacs に特化した情報については、以下のファイルを参照してください。
@display
@url{http://openlab.jp/skk/skk/main/READMEs/README.MacOSX.ja}
@url{http://openlab.jp/skk/skk/main/READMEs/README.Mac.ja}
@end display

@node Q.1-5 APEL って何? 必要ですか?
@unnumberedsubsec Q.1-5 APEL って何? 必要ですか?

APEL は A Portable Emacs Library の略です。APEL の主な機能は異なる Emacs
間の非互換性を吸収することです。これは現在開発コストの削減に役立っており、
現状では APEL を使い続ける方針です。

@node Q.1-6 SKK における「モード」の意味とは?
@unnumberedsubsec Q.1-6 SKK における「モード」の意味とは?

外観すると以下のようになります。

@table @asis
@item マイナーモード
@table @asis
@item SKK モード (skk-mode)                 @kbd{C-x C-j}
@end table
@item 入力モード
@table @asis
@item かなモード/カナモード (skk-j-mode)    @kbd{C-j}
@item アスキーモード (skk-latin-mode)         @kbd{l}
@item 全英モード (skk-jisx0208-latin-mode)  @kbd{L}
@item Abbrev モード (skk-abbrev-mode)       @kbd{/}
@end table
@item 変換モード
@table @asis
@item ■モード (eq skk-henkan-mode nil)     かななど確定入力
@item ▽モード (eq skk-henkan-mode 'on)     変換前
@item ▼モード (eq skk-henkan-mode 'active) 変換中
@end table
@item その他のモード
@table @asis
@item 辞書登録モード
@end table
@end table

@node Installation
@section SKK の入手から導入まで

@menu
* Q.2-1 SKK を使うのに何が必要ですか?::
* Q.2-2 SKK 辞書はどこにありますか?::
* Q.2-3 SKK サーバはどこにありますか?::
@end menu

@node Q.2-1 SKK を使うのに何が必要ですか?
@unnumberedsubsec Q.2-1 SKK を使うのに何が必要ですか?

APEL, SKK 本体と SKK 辞書が必要です。オプションで SKK 辞書サーバを用意す
ることができます。

@display
@xref{APEL のインストール}.
@end display

SKK 本体は以下から入手できます。

@display
@url{http://openlab.jp/skk/maintrunk}
@end display

@node Q.2-2 SKK 辞書はどこにありますか?
@unnumberedsubsec SKK 辞書はどこにありますか?

以下を参照してください。

@display
@xref{SKK辞書について}.
@end display

@node Q.2-3 SKK サーバはどこにありますか?
@unnumberedsubsec Q.2-3 SKK サーバはどこにありますか?

DDSKK 13 は サーバの種類、バージョンには依存していません。

@display
@url{http://openlab.jp/skk/skkserv-ja.html}
@end display

@noindent
からお好きなサーバを入手して下さい。

@node Customization
@section SKK の基本設定からお好みのカスタマイズまで

@menu
* Q.3-1 「．」、「，」 が入力できるようにカスタマイズしたいのですが。::
* Q.3-2 「ゐ」や「ヰ」 が入力できるようにカスタマイズしたいのですが。::
* Q.3-3 検索する辞書を増やしたいのですが。::
* Q.3-4 左手の小指を SHIFT で酷使したくありません。::
* Q.3-5 全く漢字が出てきません。::
* Q.3-6 チュートリアルが起動できません。::
@end menu

@node Q.3-1 「．」、「，」 が入力できるようにカスタマイズしたいのですが。
@unnumberedsubsec Q.3-1 「．」、「，」 が入力できるようにカスタマイズしたいのですが。

3通りの方法を紹介します。

@enumerate
@item
通常 @samp{.} で「．」、@samp{,} で「，」を入力したい場合

@file{~/.skk} に以下を設定します。

@lisp
@group
(setq skk-kutouten-type 'en)
@end group
@end lisp

@item
一時的に @samp{.} で「．」、@samp{,} で「，」を入力したい場合

@kbd{M-x skk-toggle-kutouten} を実行すると、その場で「，」「．」に切り替える
ことができます。「、」「。」に戻すには、もう一度
@kbd{M-x skk-toggle-kutouten} を実行を実行します。
特定のバッファでのみ「，」「．」に切り替えたい場合は、 File Variables
(@pxref{File Variables, , File Variables, emacs, GNU Emacs Manual})
を参照下さい。
例えば、 tex モードでのみ「，」「．」に切り替えたい場合は、つぎの設定を
texファイルの最後に追加します。

@example
% Local Variables:
% skk-kutouten-type: en
% end:
@end example

@item
常に @samp{.} で「．」、@samp{,} で「，」を入力したい場合

@code{skk-rom-kana-rule-list} を直接変更します。
なお、この設定をすると、@kbd{M-x skk-toggle-kutouten} での切り替えが
効かなくなるので、注意して下さい。

@file{~/.skk} に以下を追加します。

@lisp
@group
(setq skk-rom-kana-rule-list
      (append '(("." nil "．") ("," nil "，"))
              skk-rom-kana-rule-list))
@end group
@end lisp

この設定方法は応用が効き、細かく制御することが可能です。
@samp{．} と @samp{，} のところをそれぞれ、@samp{.} と @samp{,} とすることで、
「かなモード」「カナモード」でも、@samp{.} と@samp{,} を直接入力することが
できます。
@end enumerate

@node Q.3-2 「ゐ」や「ヰ」 が入力できるようにカスタマイズしたいのですが。
@unnumberedsubsec Q.3-2 「ゐ」や「ヰ」 が入力できるようにカスタマイズしたいのですが。

一つ前の Q. の変形問題ですね。かな/カナモードでそれぞれ出力する文字
を変えるやり方です。

@file{~/.skk} に

@lisp
@group
(setq skk-rom-kana-rule-list
      (append '(("wi" nil ("ヰ" . "ゐ")))
              skk-rom-kana-rule-list))
@end group
@end lisp

@noindent
と書いてみましょう。

一番内側の cons cell は car がカナモード、cdr がかなモー
ドでの入力文字を表しています。

一つ前の Q. に対する答えのように、カナモード、かなモードともに入力す
る文字が変わらなければ、cons cell の代りに文字列を書くことができます。

@node Q.3-3 検索する辞書を増やしたいのですが。
@unnumberedsubsec Q.3-3 検索する辞書を増やしたいのですが。

@code{skk-search-prog-list} で設定をしましょう。
@vindex skk-search-prog-list

まず、現在の設定を確認しましょうね。*scratch* バッファに
@code{skk-search-prog-list} と書いてそのシンボルの末尾にポイントを置いて
@kbd{C-j} してみましょう。例えば次のように出力されます。

@lisp
@group
((skk-search-jisyo-file skk-jisyo 0 t)
 (skk-search-server skk-aux-large-jisyo 10000))
@end group
@end lisp

上記の例は 2 つの要素を持ったリストになっています。設定によりもっと多
くの要素があるかもしれません。

各要素は検索する関数と辞書を指定したリストです。要素の順番に検索がなさ
れます。上記の例だとまず最初に @code{skk-jisyo} (個人辞書) を
@code{skk-search-jisyo} という関数を使ってリニアサーチ、次に
@code{skk-search-server} という関数を使って @code{skk-aux-large-jisyo}
をサーチします。

変換の際、@key{SPC} を押しますよね?  1 回 @key{SPC} を押すと、SKK は候
補が見つかるまでの間、@code{skk-search-prog-list} の要素を前から読んでいっ
て検索を行い、見つかればそこで一旦検索を止めてユーザに候補を提示します。

ユーザが @key{SPC} を更に押してゆき最初の要素のプログラムが見つけた候補が尽
きると、SKK は中断していた個所から再び @code{skk-search-prog-list} の次
の要素を見つけ、ここで指定されている関数を使って検索する、で新しい候補が
見つかればまた提示する、というシステムになっています。

では、サーバを使って検索した後に、JIS 第 2 水準の単漢字辞書、
@file{SKK-JISYO.JIS2} を検索したい場合はどうすれば良いでしょう?  もう分
かりますよね?  サーバを使った検索式の次に第 2 水準辞書の検索式を書いた
リストを @code{skk-search-prog-list} に指定すれば良いのです。
@file{~/.skk} に次のように書きましょう。

@lisp
@group
(setq skk-search-prog-list
      '((skk-search-jisyo-file skk-jisyo 0 t)
        (skk-search-server skk-aux-large-jisyo 10000)
        (skk-search-jisyo-file "~/dic/SKK-JISYO.JIS2" 0)))
@end group
@end lisp

@code{skk-search-jisyo-file} の第 2 引数、0 の数字はリニアサーチにて検索
するよう指定しています。第 2 水準辞書はあまり大きくないので、リニアサー
チで十分でしょう。大きな辞書を検索する場合などは、

@lisp
(skk-search-jisyo-file "~/dic/SKK-JISYO.L" 10000)
@end lisp

@noindent
のようにすると良いでしょう。SKK は Emacs のバッファに読み込まれた
@file{~/dic/SKK-JISYO.L} の検索リージョンのポイント差が 10,000 未満にな
るまではバイナリサーチを行い、その後リニアサーチを行います。大きな辞
書ではバイナリサーチを行う方がはるかに効率が良いです。嘘だと思うなら、
@file{SKK-JISYO.L} を読み込んでリニアサーチするような設定にして試してみ
て下さい。

ちなみに、@file{SKK-JISYO.JIS2} は、最大でもリージョン間のポイント差が
8,500 程度です。

@node Q.3-4 左手の小指を SHIFT で酷使したくありません。
@unnumberedsubsec Q.3-4 左手の小指を SHIFT で酷使したくありません。

SKK を標準の状態で使っている場合、変換のためにシフトキーを多用しますの
で小指への負担が大きくなります。
@footnote{このため、ある人々は SKK を小指キラーと呼びます。}

この苦しみを回避するためにここでは 3 つの方法を紹介します。

@enumerate
@item
親指の近くにあるキーを利用してシフトキーの代用とする。

日本語 106 キーボードのように無変換、変換などのキーがある場合は、これ
らをシフトキーの代用とすることが可能です。こうすると、例えば

@display
@key{SHIFT} を押しながら @kbd{a} を押す
@end display

@noindent
というキー操作は

@display
@key{無変換} を押して、その後で @kbd{a} を押す
@end display

@noindent
という操作で置き換えることができるようになります。

それでは具体的なやり方を説明しましょう。まず、使用中の Emacs が無変換
キーを何という名前で認識しているか調べます。それには

@example
@kbd{M-x describe-key}
@end example

@noindent
というコマンドを実行し、続いて 無変換キーを押してみます。XFree86 上で
なら、おそらく

@example
muhenkan is undefined
@end example

@noindent
という答えが返ってくるでしょう。次に、この名前を使って @file{~/.emacs}
に設定を書きこみます。以下は @key{無変換} = @key{muhenkan} の場合の例で
す。

@lisp
@group
(unless (keymapp key-translation-map)
  (setq key-translation-map (make-sparse-keymap)))

(let ((i ?a))
  (while (<= i ?z)
    (define-key key-translation-map
                (vector 'muhenkan i) (vector (- i 32)))
    (setq i (1+ i))))
@end group
@end lisp
@vindex key-translation-map

この設定を終えると、@kbd{@key{muhenkan}-a} で @kbd{A} が入力できるように
なります。つづいて、SKK を起動してみましょう。@kbd{@key{muhenkan}-a} で
@samp{▽あ} となります。送りの開始点も、もちろん同様の操作で指定できます。
@footnote{変数 @code{key-translation-map} の意味を調べてみてください。

@kbd{M-x describe-variable} @key{RET} key-translation-map}

@item
xmodmap を使う。

X Window System 上では、xmodmap というプログラムを使ってキー配列を変更で
きます。例えば、無変換キーをシフトキーとして使いたければ
@cindex xmodmap

@example
% xmodmap -e 'add Shift = Muhenkan'
@end example

@noindent
とします。これで無変換キーは通常のシフトキーと同じような感じで使えるよ
うになります。

@item
@file{skk-sticky.el} を使う。

@xref{変換位置の指定方法}

@item
親指シフト入力のエミュレーション機能を利用する。
@cindex 親指シフト入力

これは 1, 2 とはかなり違ったアプローチです。SKK 本来のローマ字的入力を捨
てて、富士通のワープロ OASYS のような親指シフト入力を修得します。
@footnote{親指シフト入力の詳細については、ここでは述べません。興味がある
場合は、日本語入力コンソーシアムの Web サイト

@display
@url{http://nicola.sunicom.co.jp/}
@end display

@noindent
を訪れてください。}
@cindex OASYS
@cindex NICOLA
@cindex 日本語入力コンソーシアム

この機能は、SKK 10 では利用できません。Daredevil SKK 11.3 以降には、
NICOLA-DDSKK というプログラムが付属しており、これをインストールすると
親指シフト入力が可能になります。インストール自体は簡単で、

@example
% cd experimental/nicola (Daredevil SKK 11.4 以降 では cd nicola )
% make install
@end example

@noindent
とした後に、@file{~/.skk} に

@lisp
@group
(setq skk-use-kana-keyboard t)
(setq skk-kanagaki-keyboard-type 'omelet-jis)
@end group
@end lisp

@noindent
と書くだけです。詳しいことは、NICOLA-DDSKK 付属のドキュメントを参照し
てください。

NICOLA 配列は、特別に日本語入力のために考えられた配列なので、慣れれば
非常に効率的な日本語入力ができるようになると期待されます。一方で、ロー
マ字的入力方式に慣れてしまっている人にとっては、NICOLA 配列に慣れるま
でかなり練習を要することは確かです。
@end enumerate

@node Q.3-5 全く漢字が出てきません。
@unnumberedsubsec Q.3-5 全く漢字が出てきません。

恐らく辞書の設定ができていないのでしょう。

@file{SKK-JISYO.L} というファイルがインストールされている場所を確認して
ください。普通は

@display
@file{/usr/local/share/skk}
@file{/usr/share/skk}
@end display

@noindent
といった場所にインストールされています。XEmacs のパッケージならば

@display
@file{/usr/local/lib/xemacs/mule-packages/etc/skk}
@end display

@noindent
などを確認します。その後で @file{~/.skk} に

@lisp
(setq skk-large-jisyo "/usr/local/share/skk/SKK-JISYO.L")
@end lisp
@vindex skk-large-jisyo

@noindent
のように設定します。

なお、辞書サーバを使っている場合はこの設定は必要ありません。その場合は、
辞書サーバの設定や、それがちゃんと起動しているかどうかを確認してくださ
い。

また、どこにも辞書がインストールされていない場合は

@display
@url{http://openlab.jp/skk/dic/}
@end display

@noindent
から取得します。

@node Q.3-6 チュートリアルが起動できません。
@unnumberedsubsec Q.3-6 チュートリアルが起動できません。
@cindex チュートリアル

@file{SKK.tut} というファイルがインストールされている場所を確認してくだ
さい。普通は

@display
@file{/usr/local/share/skk}
@file{/usr/share/skk}
@end display

@noindent
といった場所にインストールされています。XEmacs のパッケージならば
@cindex パッケージ

@display
@file{/usr/local/lib/xemacs/mule-packages/etc/skk}
@end display

@noindent
などを確認します。その後で @file{~/.emacs} に

@lisp
(setq skk-tut-file "/usr/local/share/skk/SKK.tut")
@end lisp
@vindex skk-tut-file

@noindent
のように設定します。

@node Dictionaries
@section SKK 辞書関連

@menu
* Q.4-1 SKK には郵便番号辞書がありますか?::
* Q.4-2 SKK の辞書には、品詞情報がないんですね。::
* Q.4-3 複数の SKK 辞書を結合できますか?::
* Q.4-4 SKK 形式の英和辞書があると聞いたのですが。::
@end menu

@node Q.4-1 SKK には郵便番号辞書がありますか?
@unnumberedsubsec Q.4-1 SKK には郵便番号辞書がありますか?

CVS から辞書を取得した場合は、@file{zipcode} というディレクトリに入って
います。WWW では、

@display
@url{http://openlab.jp/skk/dic/}
@end display

@noindent
より入手できます。使用方法は

@display
@url{http://openlab.jp/skk/skk/dic/zipcode/README.ja}
@end display

@noindent
を御覧下さい。

@node Q.4-2 SKK の辞書には、品詞情報がないんですね。
@unnumberedsubsec Q.4-2 SKK の辞書には、品詞情報がないんですね。
@cindex 品詞情報

SKK は漢字とかなとの区切りをユーザーが指定する方式により、品詞情報を使っ
た解析を用いることなく効率的入力ができます。

TODO としては、辞書に品詞情報を持たせることでさらなる入力の効率化ができ
るという提案がなされており、そのような辞書の作成がすでに試みられています。
興味のある方は

@display
@url{http://openlab.jp/skk/wiki/wiki.cgi?page=SKK%BC%AD%BD%F1}
@end display

における @file{SKK-JISYO.notes} の項目をご覧ください。

@node Q.4-3 複数の SKK 辞書を結合できますか?
@unnumberedsubsec Q.4-3 複数の SKK 辞書を結合できますか?
@cindex 辞書のマージ

SKK 本体のパッケージには同封されていませんが、skk-tools という別パッケー
ジがあります。以下をご覧ください。

@display
@xref{辞書ツール}.
@end display

@node Q.4-4 SKK 形式の英和辞書があると聞いたのですが。
@unnumberedsubsec Q.4-4 SKK 形式の英和辞書があると聞いたのですが。
@cindex @file{edict2skk.awk}
@cindex @code{skkdic-expr}
@cindex @code{skkdic-sort}
@cindex edict
@cindex 英和辞書

edict は和英辞書ですが、これを SKK 辞書形式の英和辞書に変換したものを

@display
@url{http://openlab.jp/skk/dic/SKK-JISYO.edict}
@end display

@noindent
として置いています。これは edict を単純に機械的に変換した後、バグの修正
や、エントリ・候補の追加が SKK Openlab で独自に行われているものです。

edict を自分で加工して上記と同等のものを作成することもできます。edict は

@display
@url{ftp://ftp.u-aizu.ac.jp:/pub/SciEng/nihongo/ftp.cc.monash.edu.au/}
@end display

@noindent
などから入手できます。

加工には日本語の通る @code{gawk} と skk-tools の中のプログラムを使い、下
記のように行います。

@example
% jgawk -f edict2skk.awk edict > temp
% skkdic-expr temp | skkdic-sort > SKK-JISYO.E2J
% rm temp
@end example

できた @file{SKK-JISYO.E2J} の利用方法は色々ありますが、

@example
% skkdic-expr SKK-JISYO.E2J + /usr/local/share/skk/SKK-JISYO.L | \
  skkdic-sort > SKK-JISYO.L
@end example

@noindent
などとして、@file{SKK-JISYO.L} とマージして使うのが手軽です。

なお、edict の配布条件は GNU GPL (General Public License) ではありません。

@display
@url{http://www.csse.monash.edu.au/groups/edrdg/newlic.html}
@end display

@noindent
をご覧下さい。@file{SKK-JISYO.edict} のヘッダー部分にもそのダイジェスト
が記載されています。

@node Miscellaneous
@section SKK の活用法その他

@menu
* Q.5-1 abbrev モードって何ですか?::
* Q.5-2 abbrev モードでもっと英単語を利用した変換ができませんか?::
* Q.5-3 市販の CD-ROM 辞書やネットワークの辞書サーバが利用できますか?::
* Q.5-4 他の FEP を使用中にも SHIFT を押してしまいます。::
@end menu

@node Q.5-1 abbrev モードって何ですか?
@unnumberedsubsec Q.5-1 abbrev モードって何ですか?
@cindex abbrev モード

@example
  @kbd{▽is} @key{SPC}
       @expansion{} @samp{インクリメンタル・サーチ}
@end example

@noindent
などのように短い英語見出しから変換できると便利だとは思いませんか?

かな/カナモードで、@kbd{/} キーを入力してみて下さい。@samp{▽}が出てアス
キー文字が入力できるようになるはずです。ここで英文字を入力して @key{SPC}
を押せば変換できます。

もちろん対応するエントリが辞書にないと単語登録モードに入りますよ。

@node Q.5-2 abbrev モードでもっと英単語を利用した変換ができませんか?
@unnumberedsubsec Q.5-2 abbrev モードでもっと英単語を利用した変換ができませんか?
@cindex @code{look}
@cindex @file{skk-look.el}
@cindex edict
@cindex 英単語の検索
@cindex 和英変換
@kindex ,
@kindex .
@vindex skk-look-expanded-word-only
@vindex skk-look-recursive-search
@vindex skk-look-use-ispell
@vindex skk-use-look

UNIX @code{look} コマンドと @file{skk-look.el} を利用すると、色々できま
すよ。まず、 @file{~/.skk} か @file{~/.emacs} で @code{skk-use-look} を
t にセットして Emacs/SKK を立ち上げ直して下さい。

さぁ、下記のような芸当が可能になりました。

@enumerate
@item
英単語の補完ができます。

@example
  ▽abstr(@key{TAB}) @expansion{} ▽abstract
@end example

通常の補完機能同様、@kbd{.} で次の補完候補、@kbd{,} でひとつ前の補完候補
に移動できます。SKK 形式の英和辞書があれば、ここから @key{SPC} を押して
英和変換ができますね。また、@code{skk-look-use-ispell} の値が
@code{non-nil} であれば、@code{look} で検索する前に @code{ispell} でス
ペルチェック・修正をします。

@item
英単語をあいまいに変換して取り出すことができます。上記同様、
@code{skk-look-use-ispell} の値が @code{non-nil} であれば、@code{look}
で検索する前に @code{ispell} でスペルチェック・修正をします。

@example
  ▽abstr* (@key{SPC}) @expansion{} ▼abstract
@end example

見出し語に @samp{*} を入れるのをお忘れなく。

@item
あいまいに変換した後、更に再帰的な英和変換を行うことができます。

まず、@code{skk-look-recursive-search} の値を @code{non-nil} にセット
して下さい。Emacs/SKK を再起動する必要はありません。すると、例えば、

@example
  ▽abstr* (@key{SPC})
       @expansion{} ▼abstract (@key{SPC})
       @expansion{} ▼アブストラクト (@key{SPC})
       @expansion{} ▼抽象 (@key{SPC})
       @expansion{} ▼abstraction (@key{SPC})
       @expansion{} ▼アブストラクション
@end example

このように英単語 + その英単語を見出し語にした候補の「セット」を変換結果
として出力することができます。

この際、@code{skk-look-expanded-word-only} の値が @code{non-nil} であ
れば、再帰検索に成功した英単語の「セット」だけを出力することができます
(再帰検索で検出されなかった英単語は無視して出力しません) 。

もちろん、SKK 辞書に

@example
  abstract /アブストラクト/抽象/
  abstraction /アブストラクション/
@end example

@noindent
というエントリがあることを前提としています。edict を SKK 辞書形式に変換
すると良いですね。
@end enumerate

なお、@file{skk-look.el} を使った補完・変換が期待するスピードよりも遅
い、補完・変換で余分な候補が出る、とお感じの貴方は、
@code{skk-look-use-ispell} の値を @code{nil} にして @code{ispell} によ
るスペルチェック・修正をオフにしてお試し下さい。

@node Q.5-3 市販の CD-ROM 辞書やネットワークの辞書サーバが利用できますか?
@unnumberedsubsec Q.5-3 市販の CD-ROM 辞書やネットワークの辞書サーバが利用できますか?
@cindex @file{skk-lookup.el}
@cindex Lookup
@vindex skk-search-prog-list
@findex skk-lookup-search

Lookup が扱える辞書はほとんど使えます。Lookup がインストールされている
状態で SKK をインストールすると、SKK と Lookup のゲートウェイプログラ
ム @file{skk-lookup.el} がインストールされます。

インストールで注意すべきは、@code{make} で呼び出される Emacs は
@samp{-q -no-site-file} フラグ付きで呼ばれるので、@file{~/.emacs} や
@file{site-start.el} などは読み込まれないことです。デフォルトで
@code{load-path} の通っているディレクトリに lookup をインストールするか、
@file{SKK-CFG} の中で @var{VERSION_SPECIFIC_LISPDIR} などにディレクトリ
を明示することで解決できます。

さぁ、@file{~/.emacs} か @file{~/.skk} で @code{skk-search-prog-list} の
要素に @code{(skk-lookup-search)} を追加しましょう。他の検索エンジンより
も検索は比較的重いので、最後の方が良いと思います。

こんな感じです。

@lisp
@group
(setq skk-search-prog-list
      '((skk-search-jisyo-file skk-jisyo 0 t)
        (skk-search-server skk-aux-large-jisyo 10000)
        (skk-lookup-search)))
@end group
@end lisp

Lookup については、

@display
@url{http://openlab.jp/edict/lookup/}
@end display

@noindent
をご参照下さい。中島は、ローカルマシンのハードディスクに広辞苑の第四版
をコピーして利用していますが、速度的には十分満足しています。ちなみに
epwutil で @code{squeeze} した辞書データのサイズは 45MB 弱です。

@node Q.5-4 他の FEP を使用中にも SHIFT を押してしまいます。
@unnumberedsubsec Q.5-4 他の FEP を使用中にも @key{SHIFT} を押してしまいます。

治すには SKK をやめるしかありません :-)

Emacs 上以外でも SKK みたいな操作性を実現するソフトウェアがあります。
@ref{SKK関連ソフトウェア} をご覧になってください。

@node 事項索引
@unnumbered 事項索引

@printindex cp

@node 変数索引
@unnumbered 変数索引

@printindex vr

@node 関数索引
@unnumbered 関数索引

@printindex fn

@node キー索引
@unnumbered キー索引

@printindex ky

@summarycontents
@contents
@bye

@c Local Variables:
@c fill-column: 72
@c skk-kutouten-type: jp
@c End:
