\input texinfo @c -*-texinfo-*- coding: iso-2022-jp -*-
@setfilename skk.info
@settitle The SKK Manual
@c 
@c  Author: Masahiko Sato <masahiko@kuis.kyoto-u.ac.jp>
@c          Yukiyoshi Kameyama <kameyama@@kuis.kyoto-u.ac.jp>
@c          Mikio Nakajima <minakaji@osaka.email.ne.jp>
@c  Maintainer: Mikio Nakajima <minakaji@osaka.email.ne.jp>
@c  Version: $Id: skk.texi,v 1.16 2000/08/27 04:56:03 czkmt Exp $
@c  Keywords: japanese
@c  Last Modified: $Date: 2000/08/27 04:56:03 $
@c
@set EDITION 1.4
@set SKK-VERSION 10.61
@set UPDATED $Date: 2000/08/27 04:56:03 $
@c @set UPDATED-MONTH Oct 1998

@direntry
* SKK: (skk).         Simple Kana to Kanji conversion program
@end direntry

@c Texinfo に追加できたら良いなぁと思う点を述べます。私、単なる LaTeX ユー
@c ザーで、Plain TeX マクロの組み方なんて全然知りませんので、ユーザーの立場
@c でやりたいことを卒直に、また無責任に述べるに留めます。あしからず。実現で
@c きる方法をご存知の方がいらっしゃいましたら、是非教えて下さい。
@c
@c (1)日本語の用語についてゴシック体でプリントアウトし、info では "「" 
@c    と "」" を自動的に付けるような@jdfn{}が欲しい。本書では、日本語
@c    の用語定義をとりあえず`「',`」' で囲み、@b コマンドでゴシック体を
@c    出力するようにしている。
@c
@c (2)アスキー文字と全角文字を連接して書いたとしても pTeX がその間に適切
@c    に空白を挿入して印刷してくれる。一方 info は連接したままで空白は挿
@c    入されないので少し見にくい気がする。info ではアスキー文字と全角文
@c    字との間に半角スペースを挿入してはどうか？
@c
@c (3)LaTeX の表を書くコマンドを実装して欲しい (なら Latexinfo を使えと
@c    は言わないでね。互換性が大きく損なわれるから嫌なんです)。

@synindex fn cp
@synindex vr cp
@synindex pg cp
@footnotestyle end
@iftex
@afourpaper
@end iftex

@titlepage
@sp 10
@comment The title is printed in a large font.
@title The SKK Manual
@subtitle Edition @value{EDITION}for SKK Version @value{SKK-VERSION}
@c @subtitle @value{UPDATED-MONTH}
@subtitle @value{UPDATED}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{}1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999
@w{Masahiko Sato}(佐藤雅彦), @*
@w{Yukiyoshi Kameyama}(亀山幸義) and @w{Mikio Nakajima}(中島幹夫).
Revised by @w{Kiyotaka Sakai}(酒井清隆) and @w{Satoshi Harauchi}(原内聡).

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@ifinfo
@node Top, 配布条件, (dir), (dir)
@top SKK

This is Edition @value{EDITION},
last updated @value{UPDATED},
of @cite{The SKK Manual},
for SKK, Version @value{SKK-VERSION}.

@menu
* 概要::                        
* インストール::                
* 基本的な使用方法::            
* 便利な応用機能とユーザーオプション::  
* 辞書ユーティリティプログラム::  
* 拡張アイディア::              
* SKKメーリングリスト::         
* SKKの入手方法::               
* SKK関連ソフトウェア::         
* 謝辞とお願い::                
* 事項索引::                    
* 変数索引::                    
* 関数索引::                    
* キー索引::                    
@end menu

Copyright (C) 1996, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999
Masahiko Sato, Yukiyoshi Kameyama and Mikio Nakajima.
Revised by Kiyotaka Sakai and Satoshi Harauchi.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@node 配布条件, 概要, Top, Top
@comment  node-name,  next,  previous,  up
@include gpl.texi

@node 概要, インストール, Top, Top
@comment  node-name,  next,  previous,  up
@chapter 概要
@cindex Simple Kana to Kanji conversion program

SKK version 10はMule機能を持った各種Emacsenの上に高速で効率的な日本語入
力環境を提供するシステムであり、GNU General Public Licenseに従ったフリー・
ソフトウェアとして配布される。

SKK 10が動作を保証するEmacsenのバージョンは下記の通りである。

@table @asis
@item Emacs 19.28 or later をベースとした Mule 2 or 3
@item Emacs 20.2 or later
@item --with-mule オプション付きでコンパイルされたXEmacs 20.4 or later
@item Meadow 1.00, 1.01, 1.10
@item Mule for Windows 1.21, 1.22
@end table

SKKは、Simple Kana to Kanji conversion programにちなんで名付けられた。
SKKは、いわゆるローマ字入力による、文法的知識を用いない高速変換可能な日本
語入力/変換プログラムである。本体部分のプログラムは、Emacs Lispにより書か
れており拡張性が高い。主な特徴は、下記の通りである。

@itemize @bullet

@item
辞書変換の単位を小さくおさえることにより、文法的知識を用いないで高速に、
かつ効率的にかな漢字変換を行なう。辞書変換単位は通常1単語であり、変換の
アルゴリズムが文法的な知識を用いないので、古語、現代語、方言、文語、口語
等、いずれについても同様に効率的な変換ができる。

@item
辞書変換し選択された候補の単語をどんどん@b{「個人辞書」}
@footnote{辞書を用いた個人の変換内容を逐次記録している辞書。詳細は、
@ref{辞書の形式,, 個人辞書}を参照のこと。}
に取り込むドラスティックな方法を取っており、個人で使用頻度の高い候補順に
優先的に辞書変換されるので、辞書変換の際のヒット率が非常に高い。

@item
独立した辞書登録モードを持たず独立した登録手続きが不要で、品詞の指定など
文法的知識を必要としない。

@item
登録時に辞書にない単語の変換を行なった場合には再帰的な辞書登録モードに入る
など、単語登録の手間が大幅に簡略化されている。

@item
マイナーモードとしてインプリメントされており、SKKを起動しても日本語の入
力が可能となる他は、メジャーモードにほとんど影響を与えず、Emacsとの親和
性が高い。
@xref{Major Modes, ,メジャーモード, emacs, GNU Emacs Manual}.
@xref{Minor Modes, , マイナーモード, emacs, GNU Emacs Manual}.

@item
サーバープログラムを使用することにより、Emacs本体のメモリ使用の軽減を計
れるが、サーバーが仮にダウンしてもSKKの使用を継続することが可能(Emacsの
バッファに辞書を取り込むので、メモリは圧迫するが、高速に辞書アクセスが可
能)。

@item
変換候補としてEmacs Lispで書かれたプログラムを指定することが可能。

@item
ローマ字入力を主体とするが、カスタマイズによりT-Code、TUT-codeによる入力
も可能である。

@item
インクリメンタルサーチ用のプログラムを独自に持っており、日本語のサーチの際
に特別の操作を要しない。

@end itemize

SKKは、複数のプログラムより構成される。プログラムの構成と主な作者は下記
の通り。

@table @asis

@item 本体部分のEmacs Lispプログラム
原作者は、佐藤雅彦@w{<masahiko@@kuis.kyoto-u.ac.jp>}である。SKK
version 10は、主に、Hideki Sakurada氏@w{<sakurada@@kuis.kyoto-u.ac.jp>}、
むらたしゅういちろう氏@w{<mrt@@notwork.org>}及び中島幹夫
@w{<minakaji@@osaka.email.ne.jp>}の3人が開発した。
@c Texinfo 3.9 has a @email command.  For the time being, we shuould use
@c @samp instead of @email for compatibility purpose.  Moreover, @email
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item インクリメンタル・サーチプログラム
榎並嗣智氏@w{<enami@@ba2.so-net.or.jp>}が開発した。

@c @item 辞書サーバ@file{skkserv}
@c 亀山幸義@w{<kameyama@@kuis.kyoto-u.ac.jp>}が開発した。
@c バイナリサーチを行なうパッチは取り込まれたのだろうか？  また、どなた
@c が作ったのか？
@c XXX dbskkd

@item 辞書
その第1版を東北大学電気通信研究所佐藤研究室の 安藤大、猪岡美紀、奥川淳一
、佐々木昭彦、佐藤克志、山岸信寛の各氏が作成し、その後、多数のユーザから
提供された辞書をもとに拡張された。

@item 辞書ユーティリティプログラム
増井俊之氏@w{<masui@@csl.sony.co.jp>}、前田憲男氏および高橋裕信氏
@w{<takahasi@@tiny.or.jp>}により作成された。

@end table

この他、各種Emacsenの差異吸収のために、APEL(A Portable Emacs Library)
@footnote{JAIST(北陸先端科学技術大学院大学)の守岡知彦氏
@w{<tomo@@etl.go.jp>}らが開発している。以前はemuとして知られていた。}
を利用している。また、Emacs Lispで書かれた部分の内部処理のために、Elib
@footnote{Elib とは、the GNU emacs lisp library の略で、キュー、AVL
木構造、二重連結リストなどを扱うためのルーチンが入っている。@xref{What
is Elib?, ,Elib, elib.info, Elib - The Emacs Lisp Library}.}の中のいく
つかのプログラムを利用している。

@node インストール, 基本的な使用方法, 概要, Top
@comment  node-name,  next,  previous,  up
@chapter インストール

@menu
* Makefileの編集とインストール::  
* .emacsの設定::                
* サーバーのインストール::      
@end menu

@node Makefileの編集とインストール, .emacsの設定, インストール, インストール
@comment  node-name,  next,  previous,  up
@section @file{Makefile}の編集とインストール
@cindex @file{Makefile}
@cindex @file{cus-face.el}
@cindex @file{custom-1.9962.patch}
@cindex @file{custom-1.9962.tar.gz}
@cindex @file{pcustom.el}
@cindex @file{texi2dvi}
@cindex @file{tinycustom.el}
@cindex @samp{APEL}
@cindex @var{DATADIR}
@cindex @var{ELISPDIR}
@cindex @var{EMACS}
@cindex @var{INFODIR}
@cindex @var{INSTALL}
@cindex @var{TEXI2DVI}
@findex texinfo-format-buffer

@enumerate
@item
まず APEL をインストールする。SKK 10 では、APEL 9.22 以降が必須である。
APELは、

@w{@samp{ftp://ftp.m17n.org/pub/mule/apel/}}

もしくは

@w{@samp{ftp://ftp.etl.go.jp/pub/mule/apel/}}

から入手できる。

@item
SKK 10は custom パッケージを使ったカスタマイズ機能を持つが、Emacsen の種
類によりいくらか作業が必要となる。
@enumerate

@item
GNU Emacs 20.2 以降、もしくは XEmacs 20.4 以降では、初期状態でこの機能を
利用することが可能。

@item
GNU Emacs 19.30 以降をベースとした Mule では、初めから custom がバンドル
されているが、 SKK のカスタマイズ機能が前提としているインターフェイスを
持っていないので、そのままではカスタマイズ機能が使えない。Emacs 19.32 以
降をベースとした Mule であれば、 

@w{@samp{ftp://ftp.dina.kvl.dk/pub/Staff/Per.Abrahamsen/custom/}}

から @file{custom-1.9962.tar.gz} を入手し、これを使用することができるが、
そのパッケージの @file{cus-face.el} に @file{patch/custom-1.9962.patch}
を当てる必要がある。カスタマイズ機能が使えなくて良ければ何もしなくて良い。
@samp{APEL} が@file{tinycustom.el} により全ての @code{defcustom} を 
@code{defvar} と等価にする。

@item
GNU Emacs 19.28 ベースの Mule では custom はバンドルされておらず、しかも
追加のパッケージをインストールして動作させることも困難なようである。
@samp{APEl} では、19.28 ベースの Mule のため、エミュレーションの目的で 
@file{tinycustom.el} を用意している。このプログラムにより全ての 
@code{defcustom} は、@code{defvar} と等価になる。SKK 10 は、@samp{APEL} 
の@file{pcumstom.el} を要求し、このプログラムが必要に応じ
@file{tinycustom.el} を要求するので、作業は何も必要ない。
@end enumerate

@item
@file{SKK-CFG} を必要に応じ編集する。このファイルは Emacs Lisp で記述す
る。ここで定義した値は、@file{SKK-MK} の値を上書きする。必要であれば 
@file{Makefile} を編集しても良いが、ほとんどのカスタマイズは 
@file{SKK-CFG} で行なえるので、@file{Makefile} を編集する必要はほとんど
ない。

@item
トップディレクトリにて @code{make} を実行する。@code{emacs} のコマンド名
を明示的に指定するには、例えば、@w{@code{make EMACS=mule}} のように変数 
@var{EMACS}の値を指定する。

@item
インストールせずにターゲットディレクトリだけ知りたい場合には、
@w{@code{make what-where}} とする (後述の XEmacs パッケージインストール
の場合は @w{@code{make what-where-package}} とする)。

@item
スーパーユーザになって、@code{make install}する。@code{make}の際、 
@var{EMACS} の値を指定したならば、ここでも @w{@code{make install
EMACS=mule}} のように同様に指定する。 XEmacs においてパッケージとしてイ
ンストールする場合は、@w{@code{make install-package}} を実行する。

@item
SKK 9 と比較して、変数名、関数名が大幅に変更されたので、
@file{skk-obsolete.el}をロードし、@kbd{M-x skk-obsolete-check-all-files} 
を実行することを強くお勧めする。
@end enumerate

@node .emacsの設定, サーバーのインストール, Makefileの編集とインストール, インストール
@comment  node-name,  next,  previous,  up
@section @file{.emacs}の設定
@cindex @file{.emacs}
@findex eval-print-last-sexp
@findex newline-and-indent
@findex picture-duplicate-line
@findex skk-auto-fill-mode
@findex skk-isearch-mode-cleanup
@findex skk-isearch-mode-setup
@findex skk-kakutei
@findex skk-tutorial
@vindex exec-directory
@vindex isearch-mode-end-hook
@vindex isearch-mode-hook
@vindex skk-server-host
@vindex skk-server-prog
@vindex skk-large-jisyo

@file{.emacs}@footnote{OSがMSDOSの場合は@file{_emacs}である。以下同様。}
に以下のフォームを挿入する。

@lisp
@group
(autoload 'skk-mode "skk" nil t)
(global-set-key "\C-x\C-j" 'skk-mode)
(global-set-key "\C-xj" 'skk-auto-fill-mode)
(global-set-key "\C-xt" 'skk-tutorial)
@end group
@group
(add-hook 'isearch-mode-hook
          (function (lambda ()
                      (and (boundp 'skk-mode) skk-mode
                           (skk-isearch-mode-setup)))))

(add-hook 'isearch-mode-end-hook
	  (function
	   (lambda ()
	     (and (boundp 'skk-mode) skk-mode (skk-isearch-mode-cleanup))
	     (and (boundp 'skk-mode-invoked) skk-mode-invoked
		  (skk-set-cursor-properly)))))
@end group
@end lisp

上記の設定では、SKKが起動されているときのみ、付属のインクリメンタルサー
チを使用する。常に付属のインクリメンタルサーチを使用したかったら上記の 
@code{isearch-mode-hook}、@code{isearch-mode-end-hook}の設定を下記の設
定に変更する。

@lisp
@group
(add-hook 'isearch-mode-hook 'skk-isearch-mode-setup)
(add-hook 'isearch-mode-end-hook 'skk-isearch-mode-cleanup)
@end group
@end lisp

サーバーを使わない場合は、更に辞書ファイルを指定する必要がある。

@lisp
(setq skk-large-jisyo "/your/path/to/SKK-JISYO.L")
@end lisp

@code{skk-large-jisyo}はEmacsのバッファに取り込んで使用するので、これに
よりメモリが圧迫されすぎる場合は、上記の@file{SKK-JISYO.L}を
@file{SKK-JISYO.S}や@file{SKK-JISYO.M}に変更する。

Emacsでは本来@kbd{C-x j}と@kbd{C-x J}はコマンド 
@code{register-to-point}に、また@kbd{C-j}は、各メジャーモードにより 
@code{newline-and-indent}、@code{eval-print-last-sexp}、
@code{picture-duplicate-line}などの各コマンドに割り付けられている。SKK
では@kbd{C-x j}を@code{skk-auto-fill-mode}に、@kbd{C-j}を
@code{skk-kakutei}に使用するのが標準的な設定となっているので、これらの
キーに元々バインドされていたEmacsのオリジナルコマンドを@kbd{C-x J}や 
@kbd{C-J}などの大文字キーに退避するか、逆にそれらのオリジナルコマンドを
元の設定のまま残して、SKKの標準設定を変更するかどうかをユーザー側にて検
討する必要がある。Emacsのオリジナルコマンドの退避などを、将来のバージョ
ンのSKKにおいて自動化を検討する予定である。@xref{拡張アイディア}.

@node サーバーのインストール,  , .emacsの設定, インストール
@comment  node-name,  next,  previous,  up
@section サーバーのインストール

サーバーを使用する場合は、本節に従いインストールを行なう必要がある。

@menu
* サーバーの概略::              
* 共通の設定::                  
@end menu

@node サーバーの概略, 共通の設定, サーバーのインストール, サーバーのインストール
@comment  node-name,  next,  previous,  up
@subsection サーバーの概略

@c XXX
@c skkservは、SKKのための辞書サーバである。skkserv(サーバ)は、SKK/Emacs(ク
@c ライアント)とは独立に動作する。一つのサーバは、複数のクライアントの要求
@c を処理することができる。

@c サーバは、起動されると最初にSKK形式の辞書を読みこむ。次に、無限ループに
@c 入り、クライアントからの要求を待つ。サーバは、接続を要求したクライアント
@c ごとに通信路を作り、以後、そのクライアントから文字列変換の要求が起きる毎
@c に辞書を検索して変換文字列を返す。クライアントは、文字列変換要求以外に、
@c サーバのバージョン番号要求や接続終了などのメッセージをサーバに送る。

@c サーバとクライアントの間の通信には、BSD系UNIXのソケットを利用する。
@c System V系UNIXでもBSD系のネットワーク機能を取りこんでいるものは動作する
@c ことがある。詳しくは@file{skkserv/Makefile}の記述を参照のこと。
@c @file{skkserv}のテストは、SunOS 4.0.3, 4.1.1、NEWS OS 4.1.1、Ultrix V4.1、
@c System V release 4.0 の上で行った。また、ユーザのレポートによると、イン
@c ストール時に適切な設定をすることにより、HP-UX、MassComp、386BSD、FreeBSD、
@c Linuxなどの上でも動作することがわかっている。

@c サーバとクライアントは、ネットワークで接続された異なる計算機上で動かすこ
@c とができる。

@node 共通の設定,  , サーバーの概略, サーバーのインストール
@comment  node-name,  next,  previous,  up
@subsection 共通の設定
@cindex @var{SKKSERVER}
@cindex @var{SKKSERV}
@cindex @var{SKK_JISYO}

サーバーを使用する場合には、@file{.emacs}や@file{.skk}を使って 
@code{skk-server-host}、@code{skk-server-prog}及び
@code{skk-server-jisyo}の設定を行なわなければならない。
 
@vtable @code

@item skk-server-host
辞書サーバーを走らせるホスト名。

@item skk-server-prog
辞書サーバープログラム(フルパスで指定する)。

@item skk-server-jisyo
サーバーに渡す辞書(フルパスで指定する)。

@end vtable
  
@smalllisp
@group
(setq skk-server-host "hogehoge")
(setq skk-server-prog "/your/path/to/skkserv")
(setq skk-server-jisyo "/your/path/to/SKK-JISYO.L")
@end group
@end smalllisp

@noindent
のように指定する。また、上記の設定は、環境変数を利用して下記のよう
に設定することで代えることができる。

@table @asis

@item Bシェルの場合
@example
@group
export SKKSERVER=hogehoge
export SKKSERV=/your/path/to/skkserv
export SKK_JISYO=/your/path/to/SKK-JISYO.L
@end group
@end example

@item Cシェルの場合
@example
@group
setenv SKKSERVER hogehoge
setenv SKKSERV /your/path/to/skkserv
setenv SKK_JISYO /your/path/to/SKK-JISYO.L
@end group
@end example

@end table

@c XXX dbskkd-cdb はユーザーが立ち上げることは不可？
@c なお、既に@file{skkserv}が立ち上がっている場合は、上記の
@c @code{skk-server-host}、@code{skk-server-prog}、@code{skk-server-jisyo}
@c あるいはそれらの環境変数はいずれも参照されないが、@file{skkserv}が立ち
@c 上がっていないときは、これらの変数を参照して@file{skkserv}を立ち上げよ
@c うとするので、安全のためにこれらの変数を設定しておく方が良い。
 
@c @node スーパーユーザの権限を持つ人の場合, スーパーユーザの権限を持たない人の場合, 共通の設定, サーバーのインストール
@c @comment  node-name,  next,  previous,  up
@c @subsection スーパーユーザの権限を持つ人の場合
@c
@c まず、@file{skkserv/Makefile}を編集する。自分の計算機の状況に応じて、以
@c 下の変数の値を変更する。
@c
@c @table @var
@c
@c @item SERVERDIR
@c @file{skkserv}がインストールされるディレクトリであり、通常 
@c @var{$EMACS/etc}にする。Emacs 19.29以上のバージョンでは、@code{wakeup}
@c など、かつて@var{$EMACS/etc}に置かれていたプログラムは、
@c @w{@file{/usr/local/libexec/emacs/19.33/i586-pc-linux-gnu/}}のような
@c libexecディレクトリに配置されるようになったので、@var{SERVERDIR}もこち
@c らを指定するのが良いであろう。
@c
@c @item JISYODIR
@c 辞書がインストールされるディレクトリであり、通常@var{$EMACS/etc}にする。
@c
@c @item JISYO
@c SKK辞書の名前であり、通常@file{SKK-JISYO.L}とする。
@c @end table
     
@c 次に@file{skkserv}をコンパイルする。
@c
@c @example
@c % make
@c @end example
@c
@c 最後にスーパーユーザになり、@file{skkserv}をインストールする。
@c
@c @example
@c @group
@c % su
@c Password: XXXXXXXX
@c # make install
@c @end group
@c @end example
@c
@c @noindent
@c 次に@file{/etc/services}に以下の行を追加する。
@c
@c @example
@c skkserv         1178/tcp
@c @end example
@c
@c また、@file{/etc/rc.local}に以下の行を追加する。
@c
@c @example
@c @group
@c if [ -x /your/path/to/skkserv ]; then
@c         /your/path/to/skkserv /your/path/to/SKK-JISYO.L
@c fi
@c @end group
@c @end example
@c
@c NIS(旧名YP)を使っている場合は、更にNISのマスタサーバとなっている計算機で
@c スーパーユーザになり、@file{/etc/services}に
@c
@c @example
@c skkserv               1178/tcp        skk-jisyo-server
@c @end example
@c
@c @noindent
@c という行を加えた後、
@c
@c @example
@c @group
@c # cd /var/yp (または cd /etc/yp)
@c # make services
@c @end group
@c @end example
@c
@c @noindent
@c とする。
@c
@c @node スーパーユーザの権限を持たない人の場合,  , スーパーユーザの権限を持つ人の場合, サーバーのインストール
@c @comment  node-name,  next,  previous,  up
@c @subsection スーパーユーザの権限を持たない人の場合
@c
@c まず、@file{skkserv/Makefile}を編集する。
@c
@c @table @var
@c
@c @item SERVERDIR
@c @file{skkserv}の置き場所である。任意のディレクトリを設定する。
@c
@c @end table
@c
@c @file{Makefile}の後の項目については、
@c @ref{スーパーユーザの権限を持つ人の場合}を参照のこと。
@c     
@c 次に、@file{skkserv}を作り、インストールする。
@c
@c @example
@c @group
@c % make
@c % make install
@c @end group
@c @end example
@c
@c @noindent
@c @file{~/.emacs}や@file{~/.skk}に
@c
@c @example
@c (setq skk-server-portnum 1178)
@c @end example
@c
@c @noindent
@c を追加する。
@c
@c SKKを使う前に@file{skkserv}を動かす計算機の上で、自分で
@c
@c @example
@c % skkserv /your/path/to/SKK-JISYO.L
@c @end example
@c
@c @noindent
@c としてサーバーを起動する。これは、サーバーがSKK呼出し時に自動的に起動さ
@c れるようになっているのだが、必ずしも成功しないためである。
@c @file{SKK-JISYO.L}をフルパスで指定する代りに環境変数@var{SKK_JISYO}を
@c 利用することもできる。@xref{共通の設定}.

@node 基本的な使用方法, 便利な応用機能とユーザーオプション, インストール, Top
@comment  node-name,  next,  previous,  up
@chapter 基本的な使用方法

本章では、SKKの基本的な使用方法をまとめる。本章のみの知識で、とりあえず
SKKを使ってみるには困らないはずである。SKKを使った入力方法に慣れるには、
付属のチュートリアルプログラムが最適なので、お試しいただきたい。

なお、次章の「便利な応用機能とユーザーオプション」は、興味のある個所のみ
をピックアップしてお読みになれば良いと思う。

@menu
* 起動と終了::                  
* モード::                      入力モードと変換モード。
* インクリメンタル・サーチ::    
@end menu

@node 起動と終了, モード, 基本的な使用方法, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section 起動と終了
@cindex オートフィル[おーとふいる]
@cindex 個人辞書[こしんししよ]
@cindex Auto Fill
@findex skk-kill-emacs-without-saving-jisyo
@kindex C-u -1 C-x j
@kindex C-u C-x j
@kindex C-x C-c
@kindex C-x j
@kindex M-- C-x j
@kindex M-1 C-x j
@vindex skk-backup-jisyo
@vindex skk-jisyo

SKKが起動されている状態を@b{「SKKモード」}という。SKKモードは、いわゆる
マイナーモードとしてインプリメントされており、他のメジャーモードやマイナー
モードの動作に可能な限り影響を与えないように設計されている。SKKモードに
入るには@kbd{C-x C-j}、もしくは@kbd{C-x j}とタイプする。マイナーモー
ドの表示には、下記のように@w{@samp{かな}}が追加される。

@example
MULE/7bit----- Buffer-name (Major-mode かな)---
@end example

また、カーソルの色がreverseVideoがoffのときはcoral4に、onのときは
pinkになる@footnote{カラーディスプレイを使用し、カラー表示をサポートして
いるWindow System下で対応するEmacsを使用している場合。}。

@kbd{C-x C-j}、もしくは@kbd{C-x j}を再度タイプすることで、SKKモードに
入る前のオリジナルのモードに戻る。カーソル色は reverseVideoがoffのときは
blackに、onのときはwhileになる。但し、一切の文字変換を行なわない入力モー
ドである @b{「アスキーモード」}では@kbd{C-j}のキーバインドがSKK用に変更
されている以外は、オリジナルのモードと変わりがないので、SKKモードから抜
ける必要はほとんどない。@xref{入力モード, ,アスキーモード}.

@kbd{C-x j}とタイプすれば、SKKモードに入ると同時にオートフィルモード
@footnote{@xref{Auto Fill, , Auto Fill, emacs, GNU Emacs Manual}.}をオン
にする。既にオートフィルモードがオンになっているバッファで@kbd{C-x j}
をタイプすると、オートフィルモードは逆にオフになるので注意すること。バッ
ファの状態にかかわらず強制的にオートフィルモード付でSKKモードに入りたい
場合は、@kbd{M-1 C-x j}や@kbd{C-u C-x j}などとタイプし、このコマンド
に正の引数を渡す@footnote{「引数」については、@ref{Numeric Arguments, ,
Arguments, emacs, GNU Emacs Manual}を参照のこと。}。オートフィルモード
をオフにし、かつSKKモードも終了したい場合には@kbd{M-- C-x j}や
@kbd{C-u -1 C-x j}などとタイプし、このコマンドに負の引数を渡す。

@kbd{C-x C-c}でEmacsを終了しようとすると@code{skk-jisyo}に個人辞書の
内容を自動的に保存する。@xref{辞書の形式, , 個人辞書}.
@code{skk-backup-jisyo}に保存を行なう前の辞書が退避される。個人辞書を保
存せずEmacsを終了させたい場合には、

@example
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end example

@noindent
とタイプする。個人辞書の保存動作について更に詳しくは、
@ref{個人辞書の保存動作}を参照のこと。

@node モード, インクリメンタル・サーチ, 起動と終了, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section モード
@cindex マイナーモード[まいなあもーと]
@cindex メジャーモード[めしゃーもーと]
@cindex SKKモード

SKKモードは、文字種類による4種類の@b{「入力モード」}と、辞書を用いた変換
の状態により3つの@b{「変換モード」}を持つ。本章では、入力モードと変換モー
ドについて説明する。@xref{Minor Modes, , マイナーモード, emacs, GNU Emacs Manual}.

@menu
* 入力モード::                  文字種別毎のモード
* 変換モード::                  辞書を用いた変換の状態毎のモード
@end menu

@node 入力モード, 変換モード, モード, モード
@comment  node-name,  next,  previous,  up
@subsection 入力モード
@cindex かなモード[かなもーと]
@cindex アスキーモード[あすきーもーと]
@cindex カナモード[かなもーと]
@cindex 全英モード[せんえいもーと]

入力モードは、文字種別により下記の4種類に分類される。

@table @b

@item 「かなモード」
ASCIIの小文字をひらがなに変換するモード。マイナーモードの表示は
@w{@samp{かな}}となる。カーソルの色がreverseVideoがoffのときはcoral4に、
onのときはpinkになる。

@item 「カナモード」
ASCII小文字をカタカナに変換するモード。マイナーモードの表示は
@w{@samp{カナ}}となる。カーソルの色がreverseVideoがoffのときは
forestgreenに、onのときはgreenになる。

@item 「全英モード」
ASCII小文字、大文字を全角アルファベットに変換するモード。マイナーモード
の表示は@w{@samp{全英}}となる。カーソルの色がgoldになる(reverseVideoの
off/onともに同一色)。

@item 「アスキーモード」
文字変換を行なわないモード。入力されたキーは@kbd{C-j}を除いて通常のEmacsのコ
マンドとして解釈される。マイナーモードの表示は@w{@samp{SKK}}となる。カー
ソルの色がreverseVideoがoffのときはivory4に、onのときはgrayになる。 

@end table

入力モードに伴なうカーソル色の変更方法については、
@ref{入力モードを示すカーソル色に関する設定}を参照のこと。

各入力モードの変更を行なうキーは下記の通り。

@table @kbd

@item q
「かなモード」、「カナモード」間をトグルする。

@item l
「かなモード」または「カナモード」から「アスキーモード」へ。

@item L
「かなモード」または「カナモード」から「全英モード」へ。

@item C-j
「アスキーモード」または「全英モード」から「かなモード」へ。

@end table

実際にはカナモードや全英モードで長時間入力を続けることはほとんどないの
で、かなモードのままでカナ文字や全英文字を入力する便法が用意されている。
@xref{入力モードの一時変更}.

@node 変換モード,  , 入力モード, モード
@comment  node-name,  next,  previous,  up
@subsection 変換モード

変換モードは、次の3種類のいずれかである。

@table @b

@item 「■モード(確定入力モード)」
あるキー入力に対応する文字列を、辞書を用いた文字変換を行なわずに直接バッ
ファへ入力するモード。入力モードに応じてローマ字からひ
らがな、ローマ字からカタカナ、あるいはアスキー文字から全角アルファベット
への文字変換を行なう。

@item 「▽モード」
辞書変換の対象となる文字列、「見出し語」を入力するモード。

@item 「▼モード」
見出し語について、辞書変換を行うモード。

@end table
また、▽モードの変種として@dfn{SKK abbrev mode}があり、▼モードのサブ
モードとして、@b{「辞書登録モード」}がある。

@menu
* ■モード::                    辞書変換を行なわない確定入力のモード。
* ▽モード::                    辞書変換のため見出し語の入力を行なうモード。
* ▼モード::                    辞書変換を行なうモード。
* 辞書登録モード::              個人辞書への単語登録を行なうモード。
@end menu

@node ■モード, ▽モード, 変換モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ■モード
@cindex 確定入力[かくていにゆうりよく]
@cindex ローマ字入力[ろーましにゆうりよく]

確定入力モードを@b{「■モード」}と呼ぶ。■モードでは、あるキー入力に対応
した特定の文字列への変換のみを行ない、辞書変換は行わない。
ASCII文字列から、入力モードに応じて、ひらがな、カタカナ、あるいは全角ア
ルファベットへの文字変換を行なう。変換を行なうカレントバッファにこのモー
ド特有のマークは表示されない。

かなモード、カナモードで、かつ■モードである場合、ディフォルトの入力方法
はいわゆるローマ字入力である。訓令式、ヘボン式のどちらによっても入力する
ことができる。主な注意点のみ以下に述べる。

@itemize @bullet

@item
@samp{ん}は@kbd{n n}または@kbd{n '}で入力する。直後に@samp{n}、
@samp{y}以外の子音が続くときは@samp{n}だけで入力できる。

@item
促音は、@kbd{c h o t t o}@result{}@samp{ちょっと}、@kbd{m o p p a r a}
@result{}@samp{もっぱら}のように次の子音を重ねて入力する。

@item
促音や拗音(ひらがなの小文字)を単独で入力するときは、@kbd{x a}@result{}
@samp{ぁ}、@kbd{x y a}@result{}@samp{ゃ}などのように@samp{x}を用いる。

@item
長音には、@samp{-}を用いる。@samp{-}@result{}@samp{ー}。
@end itemize

@node ▽モード, ▼モード, ■モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ▽モード
@cindex 辞書変換対象の文字列の決定[ししょへんかんたいしようのもしれつのけつてい]
@cindex ▽マークの付け忘れ[▽まーくのつけわすれ]
@cindex 数字から始まる見出し語の入力[すうしからはしまるみたしこのにゆうりよく]
@kindex @samp{Q}
@kindex C-g
@kindex C-j

@b{「▽モード」}では、辞書変換の対象となる文字列を入力する。かなモード、も
しくはカナモード@footnote{@xref{入力モード, , かなモード、カナモード}.}
で、かつ、■モードであるときに 、キー入力を大文字で開始することで、▽モー
ドに入る。例えば、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
のようにタイプすることで、▽モードに入り、続けて辞書変換の対象となる文字
列、「見出し語」を入力してゆくことができる。@samp{▽}マークは、▽モード
であるという表示であり、また、見出し語開始点を示す表示でもある。

@samp{K}の文字を大文字で入力し忘れた場合は、辞書変換の対象としたい文字
列の先頭までポイント
@footnote{@xref{Point, ,ポイント, emacs, GNU Emacs Manual}.}を戻し 
@samp{Q}をタイプすることで▽モードに入ることができる。例えば、下記のよ
うに行なう(@point{}の地点にカーソルがある)。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{C-u 3 C-b}, @kbd{Q}

@group
------ Buffer: foo ------
▽@point{}かんじ
------ Buffer: foo ------
@end group

@kbd{C-e}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

誤って▽モードに入ってしまったときは@kbd{C-j}とタイプし、■モードに戻
るか@kbd{C-g}とタイプし▽モードで辞書変換と対象となっている文字列を消
去するかの 2 通りの処理の方法がある。具体例を下記に示す。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
あるいは、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group
@end example

@samp{7がつ24にち}のように大文字から始めることができない文字列について、
▽モードにしたい場合は@samp{Q}をタイプし、▽モードにしてから@samp{7が
つ24にち}の文字列を入力する。なお、▽モードでは、文字列の間に空白を含め
ることはできない@footnote{これは、辞書の見出し語に空白を含めることができない制限からきている。}。

@node ▼モード, 辞書登録モード, ▽モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ▼モード
@cindex Overlays
@cindex ハイライト[はいらいと]
@cindex 暗黙の確定[あんもくのかくてい]
@cindex 変換開始[へんかんかいし]

@b{「▼モード」}では、▽モードで入力した見出し語を、辞書に従い変換する作
業を行なう。▽モードで見出し語を入力した後@key{SPC}をタイプすることで
▼モードに入る。@samp{▽}マークから@key{SPC}をタイプしたときのポイント
までの文字列σが見出し語として確定され、@samp{▽}マークは@samp{▼}マーク
で置き換えられ、文字列σが辞書の中で検索される。仮に、辞書に

@example
かんじ /漢字/幹事/
@end example

@noindent
というエントリ@footnote{本マニュアルでは、見出し語と候補群を合わせた一
行を「エントリ」と呼ぶ。詳細は、@ref{辞書の形式}を参照のこと。}を含むと
して、例を示す。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼漢字@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、▽モードにおける@samp{▽}マークからポイントまでの間の文字列
@samp{かんじ}を辞書変換の対象文字列σとして確定し、その文字列σについて辞書
内での検索を行なっている。実際の変換動作では、候補部分がハイライト表示さ
れる@footnote{ハイライト表示はFSF EmacsのOverlays、XEmacs のextentの機
能を使用している。}。

@samp{漢字}が求める語である場合は@kbd{C-j}をタイプすれば、この変換が確
定し、ハイライト表示も@samp{▼}マークも消える。また@kbd{C-j}をタイプせず
に、新たな確定入力を続けて行ない、あるいは新たな変換を開始することで直前
の変換は自動的に確定される。これを@b{「暗黙の確定」}と呼ぶ。副作用として
確定を伴なうキーは、印字可能な文字全てと@key{RET}である。但し、@ref{暗黙の確定のタイミング}
参照のこと。

求めるものが@samp{漢字}でなければ、更に続けて@key{SPC}をタイプすることで、
文字列σに対する次候補を検索する。

@example
@group
------ Buffer: foo ------
▼漢字
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼幹事
------ Buffer: foo ------
@end group
@end example

候補が5つ以上あるときは5番目以降の候補は7つずつまとめてエコーエリアに表
示される。例えば、辞書が

@example
@group
きょ /距/巨/居/裾/嘘/拒/拠/虚/挙/許/渠/据/去/
@end group
@end example

@noindent
というエントリを含むときに@kbd{K y o}の後に@key{SPC}を5回続けて打てば、

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

@noindent
がエコーエリア@footnote{エコーエリアとミニバッファは視覚的には同一の場所にあるが、エコーエリアが単にユーザーへのメッセージを表示するのみであるのに対し、ミニバッファは独立のバッファとして機能する点が違う。}
に表示される。ここで仮に@samp{許}を選択したければ、@samp{k}を入力する。@samp{A},
@samp{S}, @samp{D}, @samp{F}, @samp{J}, @samp{K}, @samp{L}の各文字は、
押し易さを考慮してキーボードのホームポジションから横方向に一直線に配置さ
れているキーが選定されている。また、候補の選択のために押すキーは、大文字、
小文字のいずれでも良い。候補の選択に用いるキーの変更については、
@ref{候補の選択に用いるキー}を参照。

@key{SPC}を連打してしまい、誤って求める候補を通過してしまったときは 
@samp{x}により前候補/前候補群に戻ることができる@footnote{@samp{x}は小文字で入力する必要がある}。

候補を次々と探しても求めるものがなければ、自動的に辞書登録モードになる 
(辞書登録モードは▼モードのサブモードである) 。これについては
@ref{辞書登録モード}にて後述する。

次に送り仮名のある単語について説明する。@samp{動く}を変換により求めたい
ときは@kbd{U g o K u}のように、まず▽モードに入るために@samp{U}を大
文字で入力し、次に送り仮名の開始をSKKに教えるために@samp{K}を大文字で
入力する。送り仮名の@samp{K}をタイプした時点で@key{SPC}をタイプする
ことなく、▼モードに入り辞書変換が行なわれる。送り仮名の入力時、ローマ字
プレフィックスが挿入された瞬間に、プレフィックスの直前に@samp{*}を一瞬挿
入し、送り仮名の開始時点を明示する。プレフィックスに続くキー入力で、かな
文字が完成した時点で@samp{*}は消える。キー入力を分解して追いながらもう少
し詳しく言うと、下記のようになる。

@example
@kbd{U g o}

@group
------ Buffer: foo ------
▽うご
------ Buffer: foo ------
@end group

@kbd{K}

@group
------ Buffer: foo ------
▽うご*k
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
▼動く
------ Buffer: foo ------
@end group
@end example

SKKではこのように送り仮名の開始地点をユーザーが明示的に入力するために、
システム側で送り仮名を分解する必要がなく、高速でヒット効率が高い変換が可能
である。@xref{送り仮名の自動処理, , 送り仮名の自動処理}.

但しサ変動詞の変換では、サ変動詞の語幹となる名詞を@b{「送りなし変換」}
@footnote{詳細は、@ref{辞書の形式, , 送りなし変換}を参照のこと。}
として変換し、その後@samp{する}を■モードで入力した方が効率が良い。
@xref{辞書登録モード, , サ変動詞の入力}.

@node 辞書登録モード,  , ▼モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録モード
@cindex 暗黙の確定[あんもくのかくてい]
@cindex 改行文字を含む文字列の辞書登録[かいきようもしをふくむもしれつのししよとうろく]
@cindex 再帰的辞書登録[さいきてきししよとうろく]
@cindex 辞書登録[ししよとうろく]

SKKは独立の辞書登録モードは持たない。辞書にない単語についての変換を行なっ
た場合に、変換の継続動作として辞書登録モードに入る。例えば辞書に

@example
へんかんちゅう /変換中/
@end example

@noindent
のエントリがない場合に、@samp{変換中}を得ようとして、@kbd{H e n k a n t
y u u @key{SPC}}とタイプすると、下記のように、カレントバッファは▼モー
ドのまま@samp{へんかんちゅう}に対して変換ができない状態で休止し、同時に
ミニバッファに@samp{へんかんちゅう}というプロンプトが表示される。

@example
@group
------ Buffer: foo ------
▼へんかんちゅう
------ Buffer: foo ------

------ Minibuffer -------
へんかんちゅう@point{}
------ Minibuffer -------
@end group
@end example

@noindent
辞書登録モードでは、入力はミニバッファに対して行われる。仮に辞書に

@example
@group
へんかん /変換/
ちゅう /中/
@end group
@end example

@noindent
のようなエントリがあるとして、ミニバッファで@samp{変換中}の文字列を
@samp{変換}と@samp{中}とに分けて作る。

@example
@group
@kbd{H e n k a n @key{SPC}T y u u @key{SPC}}

------ Minibuffer -------
へんかんちゅう 変換▼中
------ Minibuffer -------
@end group
@end example

@noindent
ここで@key{RET}をタイプすれば@samp{変換中}が個人辞書に登録され、辞書
登録モードは終了する@footnote{ここでも暗黙の確定が行なわれるので@kbd{C-j}をタイプする必要はない。但し、@ref{▼モードでのRET}を参照のこと。}。
同時に変換を行なっているカレントバッファには、@samp{変換中}が挿入され確
定される。@xref{辞書の形式, , 個人辞書}.

送り仮名のある単語の登録では、ミニバッファで作る候補に送り仮名そのものを
登録しないように注意しなければならない。仮に辞書に

@example
うごk /動/
@end example

@noindent
というエントリがないとして、例を一つ述べる。

@example
@group
@kbd{U g o K u}

@end group
@group
------ Buffer: foo ------
▼うごく
------ Buffer: foo ------

------ Minibuffer -------
うご*く@point{}
------ Minibuffer -------
@end group
@end example

@noindent
ミニバッファで辞書登録すべき文字列は、@samp{動}のみであり、送り仮名の
@samp{く}は含めない。@samp{動く}を登録してしまうと、次に@kbd{U g o K u}
とタイプしたときに出力される候補が@samp{動くく}になってしまう。

@example
@group
@kbd{D o u @key{SPC}}

@end group
@group
------ Minibuffer -------
うご*く 動@point{}
------ Minibuffer -------

@end group
@key{RET}
@group

------ Buffer: foo ------
動く
------ Buffer: foo ------
@end group
@end example

サ変動詞(名詞の後に@samp{する}を付けた形で構成される動詞) については、
@samp{する}を送り仮名とした送りあり変換@footnote{送り仮名を伴なう変換。詳細は、@ref{辞書の形式, 送りあり変換}を参照のこと。}
を行なわず、@samp{運動}と@samp{する}と分けて入力した方が効率が良い
@footnote{名詞とそのサ変動詞とを別々に辞書に持ったのでは空間的な効率が悪いので、基本的に、辞書がサ変動詞を送りありとして意識した作りとしていない。従い、@samp{する}を送り仮名とした送りあり変換では、辞書に候補がなく辞書登録モードに入ってしまう可能性が高いので、名詞として分解して入力することを勧めている。一方、このように名詞に分解して入力することで、サ変動詞になり得ない名詞が候補として出てくることもあり(例えば@samp{孝行する}という変換を行ないたい場合に@samp{高校}が出てくるなど)、候補の絞り込みという点では必ずしも効率が良くないので、将来のバージョンにおいて改善する方向で検討を進めている。詳細は、@ref{拡張アイディア}を参照のこと。}。
例えば@samp{運動する}は@kbd{U n d o u @key{SPC}s u r u}とタイプするこ
とにより得られる。名詞から作られる形容詞等も同様である。

誤まって辞書登録モードに入ったときは@kbd{C-g}をタイプするか、もしくは
何も登録せず@key{RET}をタイプすると▽モードに戻る。

ミニバッファを再帰的に使い辞書登録を再帰的に行なうことができる。仮に辞書
に

@example
@group
さいきてき /再帰的/
さいき /再帰/
@end group
@end example

@noindent
のようなエントリがなく、かつ

@example
@group
さい /再/
き /帰/
てき /的/
@end group
@end example

@noindent
のようなエントリがあるとする。ここで@kbd{S a i k i t e k i @key{SPC}}
とタイプすると、文字列@samp{さいきてき}に対する候補を見つけられないので、
ミニバッファに@samp{さいきてき}というプロンプトを表示して辞書登録モード
に入る。

@samp{さいきてき}に対する辞書エントリを作るため@kbd{S a i k i
@key{SPC}}とタイプすると、更にこの候補も見つけられないので、ミニバッファ
に@samp{さいき}というプロンプトを表示して、再帰的に@samp{さいき}の辞書登
録モードに入る。@kbd{S a i @key{SPC}K i @key{SPC}}とタイプすると、ミニ
バッファは、

@example
------ Minibuffer -------
さいき 再▼帰
------ Minibuffer -------
@end example

@noindent
となる。ここで@key{RET}をタイプすると、個人辞書には

@example
さいき /再帰/
@end example

@noindent
というエントリが登録され、ミニバッファは@samp{さいきてき}の辞書登録モー
ドに戻り、プロンプトは@samp{さいきてき}となる。今度は@samp{再帰}が変換可
能なので@kbd{S a i k i @key{SPC}T e k i @key{SPC}}とタイプすると、

@example
------ Minibuffer -------
さいきてき 再帰▼的
------ Minibuffer -------
@end example

@noindent
となる。ここで@key{RET}をタイプすることで、@samp{さいきてき}の辞書登
録モードから抜け、個人辞書に

@example
さいきてき /再帰的/
@end example

@noindent
というエントリが登録される。カレントバッファのポイントには、@samp{再帰的}が挿入される。

改行文字を含む文字列を辞書に登録するには、辞書登録モードで改行文字を 
@kbd{C-q C-j}により入力する。例えば、

@example
@group
〒980
仙台市青葉区片平2-1-1
東北大学電気通信研究所
@end group
@end example

@noindent
を辞書に登録するには、辞書登録モードで、

@example
@group
@samp{〒980},
@kbd{C-q C-j},
@samp{仙台市青葉区片平2-1-1},
@kbd{C-q C-j},
@samp{東北大学電気通信研究所},
@key{RET}
@end group
@end example

@noindent
と入力する。

@node インクリメンタル・サーチ,  , モード, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section インクリメンタル・サーチ
@cindex I-search
@cindex Incremental search
@findex isearch-ring-advance
@findex isearch-ring-retreat
@findex isearch-yank-kill
@kindex C-r
@kindex C-s
@kindex M-C-s
@kindex M-C-r
@vindex search-highlight

SKKでは、専用のインクリメンタル・サーチプログラムをEmacs添付のisearch.el
のラッパーとして実装しており、日本語の文字列についてのインクリメンタル・
サーチ(通常の文字列も正規表現を用いたものも両方)をアスキー文字と同様の操
作で行なうことができる。しかも大部分の動作は、オリジナルのインクリメンタ
ル・サーチのもののままである。従ってオリジナルのインクリメンタル・サーチの
コマンド(@kbd{M-y}の@code{isearch-yank-kill}や@kbd{M-p}の 
@code{isearch-ring-retreat}, @kbd{M-n}の@code{isearch-ring-advance}な
ど)やユーザー変数でのカスタマイズ(@code{search-highlight}など)もそのま
ま利用できる。オリジナルのインクリメンタル・サーチについては、
@ref{Incremental Search, ,Incremental Search, emacs, GNU Emacs Manual}
を参照のこと。

インクリメンタル・サーチ中の入力方法は、通常のバッファにおける各入力モー
ド、変換モードでの入力方法と同一である。

@kbd{C-s}や@kbd{C-r}、あるいは@kbd{M-C-s}や@kbd{M-C-r}でインクリメ
ンタル・サーチを起動すると、インクリメンタル・サーチを起動したバッファの
入力モードと同一の入力モードで、キーとなる文字の入力が可能となる。入力モー
ドに合わせて、インクリメンタル・サーチのプロンプトが表示される。プロンプ
トの種類は、以下の5つである。

@table @asis

@item I-search: [aa]
アスキーモード

@item I-search: [か]
かなモード

@item I-search: [カ]
カナモード

@item I-search: [英]
全英モード

@item I-search: [--]
インクリメンタル・サーチモードで@kbd{C-x C-j}などをタイプしてSKKを終
了した場合は、このプロンプトが表示される。

@end table

@node 便利な応用機能とユーザーオプション, 辞書ユーティリティプログラム, 基本的な使用方法, Top
@comment  node-name,  next,  previous,  up
@chapter 便利な応用機能とユーザーオプション

@menu
* 予備知識::                    応用機能を使いこなすために。
* 入力モードの一時変更::        使用頻度の高くない入力モードを少しの間だけ利用する。
* ■モードにおける文字入力::    かな/カナ/全英モードにおける文字入力の設定とカスタマイズ。
* ポイントを戻して▽モードへ::  
* 確定変換とそのアンドゥ::      ユーザー側で確定することなしに確定させる変換方法とそのアンドゥ。
* 確定アンドゥ::                候補の選択ミスをアンドゥ。
* 見出し語関連::                変換のキーとなる語の処理について。
* 送り仮名関連::                送り仮名の処理について。
* 自動変換開始::                @key{SPC}を押さずに変換開始。
* 特殊変換::                    ちょっと変った便利な変換方法。
* 接頭辞・接尾辞::              接頭辞・接尾辞を指定して候補の絞り込み。
* 暗黙の確定のタイミング::      変換後の次入力ですぐに確定するかしばらく放っておくか。
* リージョン一括変換::          スパッとリージョン一括変換。
* 漢字コード関連::              漢字コードにまつわる機能。
* ▼モードの特殊キー::          キーの動作、あるいはキーバインド変更。
* 辞書関連::                    辞書にまつわる機能。
* デコレーション::              様々な表示の設定と変更。
* VIP/VIPERとの併用::           
* I-search関連::                インクリメンタル・サーチにまつわる機能。
* skk-init-fileのバイトコンパイル::  イニシャルファイルの自動バイトコンパイル。
* picture-modeとの併用::        picture-modeとの併用の際の問題点。
* サーバー関連::                
@end menu

@node 予備知識, 入力モードの一時変更, 便利な応用機能とユーザーオプション, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 予備知識

以下のセクションで応用機能とユーザーオプションについて述べるが、その前に 
SKKのファイル構成やユーザーオプションの設定についての一般的注意を述べる。
また、辞書の形式や設定方法についても詳述しておく。辞書の形式や設定方法を
理解することで、様々な応用機能がどう動くのかを理解する助けとなる。

@menu
* ファイル構成::                
* ユーザーオプションの設定方法::  
* 辞書の形式::                  辞書の形式と構成。
* 辞書に関する設定::            検索対象と検索順序の設定。
@end menu

@node ファイル構成, ユーザーオプションの設定方法, 予備知識, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ファイル構成
@cindex @file{queue-m.el}
@cindex @file{skk-auto.el}
@cindex @file{skk-autoloads.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-foreword.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-isearch.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-leim.el}
@cindex @file{skk-look.el}
@cindex @file{skk-num.el}
@cindex @file{skk-obsolete.el}
@cindex @file{skk-server.el}
@cindex @file{skk-tut.el}
@cindex @file{skk-viper.el}
@cindex @file{skk-vars.el}
@cindex @file{skk.el}
@cindex @file{stack-m.el}

SKKバージョン10では、応用機能を提供するプログラムのほとんどを 
@file{skk.el}とは別のファイルに収め、必要に応じオートロードするように設
計されている。各応用機能の概略と該当のファイル名について説明する。

@table @file

@item skk-auto.el
送り仮名の自動処理を行なうプログラムを集めたファイル。
@xref{送り仮名の自動処理}.

@item skk-autoloads.el
autoloadの設定を記述したファイル。XEmacsでpackage installされた場合は使
用しない。

@item skk-comp.el
見出し語の補完を行なうプログラムを集めたファイル。@xref{見出し語の補完}.

@item skk-foreword.el
他のファイルで共通して使用するマクロなどを中心にまとめたファイル。各ファイ
ルの冒頭部分に、あまりユーザーに興味がないものが並んでいたのでは、ユーザー
フレンドリーではないので、このファイルに集中させる仕様となっている。

@item skk-gadget.el
プログラム実行変換を行なうプログラムを集めたファイル。
@xref{プログラム実行変換}.

@item skk-isearch.el
SKKを併用したインクリメンタリサーチ機能を提供するファイル。
@xref{I-search関連}.

@item skk-kakasi.el
KAKASIインターフェイスプログラムを集めたファイル。
@xref{リージョン一括変換}.@xref{KAKASI}.

@item skk-kcode.el
漢字コードまたはメニューによる文字入力を行なうプログラムを集めたファイル。
@xref{漢字コードまたはメニューによる文字入力}.

@item skk-leim.el
LEIM関連プログラムファイル。

@item skk-look.el
lookインターフェイスプログラムを集めたファイル。
@c @xref{lookを使用した補完・変換}. XXX

@item skk-num.el
数値変換を行なうプログラムを集めたファイル。@xref{数値変換}.

@item skk-obsolete.el
@file{.emacs}や@file{.skk}などのユーザー設定ファイルからobsoleteになっ
た変数、関数名などの修正支援プログラム。
@c XXX

@item skk-server.el
SKKサーバーインターフェイスプログラムを集めたファイル。
@xref{サーバー関連}.

@item skk-tut.el
SKKチュートリアルプログラム。

@item skk-viper.el
VIPERインターフェイスプログラムを集めたファイル。

@item skk-vars.el
古いSKK 10をダンプしたXEmacsでSKK 10を動かすためのダミーファイル。

@end table

なお、Elibより@file{queue-m.el}, @file{stack-m.el}の各ファイルをピック
アップしている。

@node ユーザーオプションの設定方法, 辞書の形式, ファイル構成, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ユーザーオプションの設定方法
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@cindex @file{skk-auto.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-num.el}
@cindex @file{skk-server.el}
@cindex @file{skk-viper.el}
@cindex @file{~/.emacs}
@cindex @file{~/.skk}
@vindex skk-auto-fill-mode-hook
@vindex skk-auto-load-hook
@vindex skk-comp-load-hook
@vindex skk-gadget-load-hook
@vindex skk-init-file
@vindex skk-kakasi-load-hook
@vindex skk-kcode-load-hook
@vindex skk-load-hook
@vindex skk-mode-hook
@vindex skk-num-load-hook
@vindex skk-server-load-hook

SKKのカスタマイズは、@file{~/.emacs}あるいは@file{~/.skk}に記述すること
ができる。また、各ファイルの提供するフックを利用することができる。上記の
ファイルやフックを利用した設定がいつ有効になるのか、という点について下記
に述べる@footnote{以前のバージョンでは、どのようなカスタマイズが行なわれ
ている場合でもチュートリアル使用時に標準設定に戻す目的で、変数の宣言に
@code{defconst}を使用していたので、全てのカスタマイズは@file{~/.skk}で行
なう必要があったが、SKK 10では、@code{defcustom}を使用した宣言を行なって
いるので、この制限はなくなった。}。

@table @asis

@item @file{.emacs}
Emacsを起動したときに一度だけ評価される。
@xref{Init File, ,.emacs, emacs, GNU Emacs Manual}.

@item @file{.skk}
SKKを起動した最初の一度だけ評価される。ファイル名のディフォルト値は、OS
の種類によりEmacsの関数@code{convert-standard-filename}により加工される。
また、@file{~/.skk}のファイル名は@code{skk-init-file}で変更することがで
きる。また、このファイルを自動的にバイトコンパイルする機能がインプリメン
トされている。詳細は、@ref{skk-init-fileのバイトコンパイル}を参照のこと。

@item @code{skk-mode-hook}
@kbd{C-x C-j}とタイプしてSKKモードに入る度にコールされる。バッファローカ
ルの設定などを行なう場合が多い。

@item @code{skk-auto-fill-mode-hook}
@kbd{C-x j}とタイプしてオートフィルモード付きでSKKモードに入る度にコール
される。バッファローカルの設定などを行なう場合が多い。

@item @code{skk-load-hook}
@file{skk.el}のロードを完了した時点でコールされる。@file{.skk}はSKKモー
ドを起動しなければロードされないのに対し、このフックは、@file{skk.el}を
ロードしたらSKKモードを起動しなくともコールされる点が違う。

@item @code{skk-auto-load-hook}
@itemx @code{skk-comp-load-hook}
@itemx @code{skk-gadget-load-hook}
@itemx @code{skk-kakasi-load-hook}
@itemx @code{skk-kcode-load-hook}
@itemx @code{skk-num-load-hook}
@itemx @code{skk-server-load-hook}
@itemx @code{skk-viper-load-hook}
@file{skk-auto.el}, @file{skk-comp.el}, @file{skk-gadget.el}, @file{skk-kakasi.el}, 
@file{skk-kcode.el}, @file{skk-num.el}, @file{skk-server.el}, 
@file{skk-viper.el}の各ファイルがロードを完了した直後にコールされるフック。
@end table

@code{load-hook}が提供されていないプログラムであっても、ロード後に何らか
のカスタマイズを行ないたい場合は、@code{eval-after-load}を使用して、例え
ば、

@example
@group
(eval-after-load "skk-look"
  '(
    ...
    ))
@end group
@end example

@noindent
のように記述する。

@node 辞書の形式, 辞書に関する設定, ユーザーオプションの設定方法, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書の形式
@cindex ;; okuri-ari entries.
@cindex ;; okuri-nasi entries.
@cindex L辞書
@cindex M辞書
@cindex S辞書
@cindex エントリ[えんとり]
@cindex ローマ字プレフィックス[ろーましふれふいつくす]
@cindex 共有辞書[きようゆうししよ]
@cindex 個人辞書[こしんししよ]
@cindex 辞書のソート方法[ししょのそーとほうほう]
@cindex 送りありエントリ[おくりありえんとり]
@cindex 送りあり変換[おくりありへんかん]
@cindex 送りなしエントリ[おくりなしえんとり]
@cindex 送りなし変換[おくりなしへんかん]
@cindex @file{SKK-JISYO.L}
@cindex @file{SKK-JISYO.M}
@cindex @file{SKK-JISYO.S}
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-henkan-strict-okuri-precedence 
@vindex skk-initial-search-jisyo
@vindex skk-jisyo
@vindex skk-kakutei-jisyo
@vindex skk-process-okuri-early

辞書の種別は大きく分けて@b{「共有辞書」}と@b{「個人辞書」}の2つがある。

@table @asis

@item 共有辞書
付属の@file{SKK-JISYO.S}(@b{「S辞書」}), @file{SKK-JISYO.M}(@b{「M辞
書」}), @file{SKK-JISYO.L}(@b{「L辞書」}) などがあり、通常、個人辞書より
もサイズが大きく、省資源の面からユーザー間で共有して参照されるが、ユーザー
の変換により内容の変更は行なわれない。

@item 個人辞書
変数@code{skk-jisyo}で指定されるファイルであり、SKKを一番最初に使い始
めたときにホームディレクトリに自動的に作られ、その後の使用により日々刻々
とエントリーが追加され、更新されてゆく辞書である。

@end table

他には@code{skk-initial-search-jisyo}や@code{skk-kakutei-jisyo}など
があるが、これらは個人毎に持つものを使用しても良いし、ユーザー間で共有し
ているものを使用しても良く、共有辞書、個人辞書という区分にはいずれにも属
さない。その性格から、辞書内容の更新は行なわれず、参照のみ行なわれる。ま
た使用目的から通常はサイズが小さい。

個人辞書、@code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo}は
Emacsのバッファに読み込んで検索を行なう。共有辞書は設定によりEmacsの
バッファに読み込んで使用する方法と、サーバー経由で使用する方法とがある。

個人辞書の一例を挙げる。

@example
@group
;; okuri-ari entries.
たとe /例/[え/例/]/
もt /持/[つ/持/]/[って/持/]/[た/持/]/[て/持/]/[ち/持/]/[と/持/]/
たすk /助/[け/助/]/
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@dots{}
;; okuri-nasi entries.
てん /点/・/天/
ひつよう /必要/
さくじょ /削除/
へんこう /変更/
じゅんじょ /順序/
ぐん /群/郡/
こうほ /候補/
いち /位置/一/壱/
@dots{}
@end group
@end example

@noindent
@samp{てん /点/・/天/}を例に取ると、@samp{てん}が見出し語であり、その候
補が、@samp{点}、@samp{・}、@samp{天}である。候補はそれぞれ、@samp{/}に
よって区切られている。SKKでは、見出し語と候補群を合わせた
@w{@samp{てん /点/・ /天/}}の一行を@b{「エントリ」}と呼ぶ。

辞書はプレーンなテキストファイルで、最低限下記の2つの行を持つ。

@example
@group
;; okuri-ari entries.
;; okuri-nasi entries.
@end group
@end example

@noindent
この2つの行は、それぞれ送り仮名あり、送り仮名なしのエントリの開始地点を
示すマークである。@samp{;; okuri-ari entries.}までの行で@samp{;}
を行頭に持つ行はコメント行として無視される。@samp{;; okuri-ari entries.}
以降にコメント行を含むことはできないので、注意すること。

@w{@samp{;; okuri-ari entries.}}と@w{@samp{;; okuri-nasi entries.}}の
間に囲まれた上半分の部分が送り仮名ありのエントリである。これを@b{「送り
ありエントリ」}と呼ぶ。@w{@samp{;; okuri-nasi entries.}}以下の下半分部
分が送り仮名なしのエントリである。これを@b{「送りなしエントリ」}と呼ぶ。
また送りありエントリを検索する変換を@b{「送りあり変換」}、送りなしエント
リを検索する変換を@b{「送りなし変換」}と呼ぶ。SKKでは送り仮名の有無が変
換方法の1つの種別となっているので、基本的には、送り仮名がある変換では送
りありエントリのみが検索され、送り仮名がない変換では送りなしエントリのみ
が検索される。

1つの見出し語についてのエントリは1行内に書かれる(2行以上にまたがることは
できない)。改行を含む候補については、@code{(concat "改\n行")}のように、
評価すると改行を該当個所に挿入するようなLispプログラム
(@pxref{プログラム実行変換})に候補を変換して辞書に収めている。

送りありエントリは、基本的には@samp{もt /持/}のようになっており、送り仮
名部分は、送り仮名をローマ字表現したときの1文字目(あるかな文字をローマ字
表現したときの1文字目を@b{「ローマ字プレフィックス」}と呼ぶ。)で表現され
ている。この1エントリで@samp{持た}、@samp{持ち}、@samp{持つ}、@samp{持
て}、@samp{持と}の5つの候補に対応している。その5つの候補の送り仮名をロー
マ字プレフィックスで表現すれば、いずれも@samp{t}になる。

さて、個人辞書の送りありエントリには@samp{[}と@samp{]}に囲まれたブロッ
クがあるが、これは、そのブロックの先頭にある平仮名を送り仮名に取る候補群
である。上記の例で見ると、見出し語@samp{たとe}の場合は@samp{え}を送り
仮名とする1つのブロックから構成されており、見出し語@samp{ふくm}の場合は、
@samp{ま}、@samp{み}、@samp{む}、@samp{め}、@samp{も}を送り仮名とする5ブ
ロックに分けられている。

この送り仮名毎のブロック部分は、@code{skk-henkan-okuri-strictly}あるい
は@*@code{skk-auto-okuri-process}のいずれかの変数が@code{non-nil}で
ある場合に、検索の際、見出し語としてはマッチしても、更に送り仮名もマッチ
するのかどうかをテストするために使用される。例えば、

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
というエントリがあれば、同じ見出し語@samp{おおk}であっても送り仮名が
@samp{き}であれば、候補は@samp{大}のみであって@samp{多}は無視される。
@xref{送り仮名の自動処理, , skk-henkan-okuri-strictly}.
@xref{送り仮名の厳密なマッチ, , skk-auto-okuri-process}.

現在のところ、付属の共有辞書では、@samp{[}と@samp{]}を使用した送り仮
名毎のブロックの形式に対応していない。個人辞書のみがこの形式で書き込まれ
てゆく。@code{skk-henkan-okuri-strictly}が@code{nil}であっても送り仮
名のブロック形式で書き込まれる。但し@code{skk-process-okuri-early}の値
が@code{non-nil}であれば、送り仮名を決定する前に変換を開始することにな
るので、送り仮名を明示的に入力していても個人辞書には@samp{[}と 
@samp{]}に囲まれた送り仮名毎のブロックは作られないので注意すること 
@footnote{変換開始の直前に内部変数に送り仮名を保存するのだが、送り仮名の確定前に変換を開始するので、個人辞書も送り仮名対応ブロックが作られない。ただ、確定時点では送り仮名が分っているので、確定時点で送り仮名を検索し直し、個人辞書に送り仮名対応ブロックを作ることは可能だが、@code{skk-process-okuri-early}を利用するユーザーにとっては、それは無駄なことなのであろう。}

@footnote{SKKバージョン8では、送り仮名毎のブロックが個人辞書内に既に作られていても@*@code{skk-process-okuri-early}を@code{non-nil}にして確定すると、該当する送りありエントリの送り仮名ブロックの部分が削除されていたが、バージョン9より、既に存在する送り仮名ブロックを保存されるように改良した。@code{skk-process-okuri-early}を常に@code{non-nil}で使用するユーザーにとってはあまり有り難い話ではないのかもしれないが、色々なユーザーオプションを試してみようとするユーザーにとっては、@code{skk-process-okuri-early}を一時期@code{non-nil}にしたばっかりに個人辞書の送り仮名情報がことごとく破壊されるのは酷であろう。ちなみにここで言う「送り仮名ブロックの保存」にかかるコストは大したことはない。}。
@xref{送りあり変換の変換開始のタイミング, , skk-process-okuri-early}.

共有辞書では、送りありエントリは@w{@samp{;; okuri-ari entries.}}から順
に下方向に、見出し語をキーとして降順に配置されている。送りなしエントリは、
@w{@samp{;; okuri-nasi entries.}}から順に下方向に、見出し語をキーとして
昇順に配置されている。降順、昇順に配置されているのは、辞書サイズが大きい
ことに配慮してバイナリサーチを行なうためである。なお、ソートする際には、
見出し語をunsigned-charと見なしている。この順序はEmacsが@code{string<}
で文字列を比較するときの順序であり、UNIXの@file{sort}コマンドでの標準
の順序とは異なるので注意が必要である。Emacsのコマンド@code{sort-lines}
を用いればファイルをこの順序でソートすることができる@footnote{Emacsコマンドの@code{sort-columns}は内部的にUNIXコマンドの@code{sort}を使っているので、辞書のソートには使わないこと。}。

一方、個人辞書は上の例でも見たように、それぞれ
@w{@samp{;; okuri-ari entries.}}, @*
@w{@samp{;; okuri-nasi entries.}}を基点として、一番最後に変換を行なった
ものがそれぞれのミニマムポイント@footnote{正確に言えば、送りあり変換では@w{@code{skk-okuri-ari-min}+ 1}の位置、送りなし変換では@*@w{@code{skk-okuri-nasi-min}+ 1}の位置である。}
に挿入され辞書が更新される。個人辞書は通常は共有辞書程はサイズが大きくな
いので、検索時にはそれぞれの基点からリニアサーチが行なわれる。個人辞書で
見つけられなかった候補については共有辞書から検索され、そこで見つかり確定
された場合はその候補が個人辞書に取り込まれ、次に同じ見出し語の検索を行なっ
た場合に同候補を最初に出力すべく、それぞれのミニマムポイントに挿入される。

@node 辞書に関する設定,  , 辞書の形式, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書に関する設定
@cindex DBM
@cindex Perl
@cindex バイナリサーチ[はいなりさーち]
@cindex リニアサーチ[りにあさーち]
@cindex 確定変換[かくていへんかん]
@c @cindex @file{pskkserv}
@vindex skk-backup-jisyo
@vindex skk-kakutei-flag
@vindex skk-search-prog-list

@code{skk-search-prog-list}の各要素に辞書検索プログラム名、辞書名、引数
をセットにしたリストを埋め込むことにより、辞書ファイルの指定、検索方法、
検索される辞書の順序などを指定することができる。
@code{skk-search-prog-list}の具体例を示しながら更に詳しく説明する。

@lisp
@group
'((skk-search-kakutei-jisyo-file skk-kakutei-jisyo 10000 t)
  (skk-search-jisyo-file skk-initial-search-jisyo 10000 t)
  (skk-search-jisyo-file skk-jisyo 0 t)
  (skk-okuri-search)
  (skk-search-jisyo-file skk-large-jisyo 10000)
  (skk-search-server skk-aux-large-jisyo 10000))
@end group
@end lisp

@noindent
関数、@code{skk-search-kakutei-jisyo-file},
@code{skk-search-jisyo-file}, @code{skk-okuri-search}, @*
@code{skk-search-server}は辞書検索プログラムである。

@ftable @code

@item skk-search-kakutei-jisyo-file
@b{「確定変換」}を行なう検索プログラム。第1引数は検索対象辞書。第2引数は
リージョンの大きさを指定する。一つの見出し語に対する変換動作に対し、検索
対象のリージョンの大きさが第2引数に指定されたサイズより小さくなるまでは
バイナリサーチが行なわれ、最後にリニアサーチが1回行なわれる。第2引数に0
を指定すると常にリニアサーチのみが行なわれる。第3引数は辞書をバッファに
読み込むときにミニバッファに読み込んでいる旨のメッセージを出力するかどう
かを指定する。検索対象の辞書ファイルはEmacsのバッファに読み込む。検索対
象のファイルから候補を見つけると、内部変数@code{skk-kakutei-flag}を立
てて、いきなり確定する(ユーザーが確定する必要はない)。

@item skk-search-jisyo-file
通常の検索を行なうプログラム。個人辞書の検索や、共有辞書でサーバーを使わ
ない検索を行なう場合はこのプログラムを使用する。第1引数、第2引数、第3引
数はそれぞれ@code{skk-search-kakutei-jisyo-file}のそれと同じ。辞書ファ
イルはEmacsのバッファに読み込む。

@item skk-okuri-search
自動送り処理を行なうプログラム。引数はない。個人辞書の送りありエントリを
検索対象としているので、個人辞書のバッファを流用し、専用の辞書バッファは
作らない。@code{skk-auto-okuri-process}の値が@code{nil}であれば、
@code{skk-search-prog-list}に@code{(skk-okuri-search)}が含まれていて
も単に無視され、スキップされるので、@code{skk-okuri-search}を動かしたい
ときは必ず@code{skk-auto-okuri-process}の値を@code{non-nil}に設定す
る。

@item skk-search-server
サーバー経由で検索するプログラム。第1引数、第2引数、第3引数はそれぞれ 
@code{skk-search-kakutei-jisyo-file}のそれと同じ。サーバーが使用不能に
なると辞書ファイルをEmacsのバッファに読み込んで検索を行なう。第2引数及び
第3引数は、辞書ファイルをEmacsのバッファに読み込んだときのみ利用される。

@end ftable

変数、@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}, @code{skk-large-jisyo}, @code{skk-aux-large-jisyo}は
辞書ファイルである。

@vtable @code

@item skk-kakutei-jisyo
確定変換用@footnote{@xref{確定変換とそのアンドゥ, , 確定変換}.}の辞書。
候補は1つのみ許される(複数の候補を書いても良いが無視される)。見出し語の
配置は、サイズが大きければ共有辞書と同じ配置
@footnote{@xref{辞書の形式, , 共有辞書の配置}.}にしてバイナリサーチを
行ない、サイズが小さければ適当な配置でリニアサーチを行なうのが良い。この
辞書は、標準の配布パッケージには含まれていないので、使用するのであればユー
ザー側で用意する必要がある。

@item skk-initial-search-jisyo
@code{skk-jisyo}の前に検索を行なう辞書。@code{skk-jisyo}の前に検索が行
なわれるので@code{skk-jisyo}にカバーを掛け、最初に出てくる候補を操作す
ることができるので、例えば、複数の専門用語毎の辞書を用意しておいて 
@code{skk-initial-search-jisyo}の値を切り替えることにより、専門分野毎の
専門用語を切り替えて入力することができて便利かもしれない。見出し語の配置
は、サイズが大きければ共有辞書と同じ配置にしてバイナリサーチを行ない、サ
イズが小さければ適当な配置@footnote{使用頻度の高い候補から降順に配置することができればリニアサーチを行なう場合最も効率が良いが、作業は楽ではないだろう。例えば、@code{skk-initial-search-jisyo}を使って一定時間文章を書いた後@code{skk-jisyo}に挿入されたエントリの内、@code{skk-initial-search-jisyo}にあるものを@code{skk-jisyo}に挿入されている順の配置で抜き出して@code{skk-initial-search-jisyo}の見出し語の配置を変えてゆけば不可能ではないが、結構な労力になろう。}
でリニアサーチを行なうのが良い。この辞書は、標準の配布パッケージには含ま
れていないので、使用するのであればユーザー側で用意する必要がある。

@item skk-jisyo
個人辞書。SKKを一番最初に起動したときにファイルがなければ自動的に作られ
る。個人辞書より先に検索するのは、確定辞書と
@code{skk-initial-search-jisyo}のみの設定とすべき。個人辞書の見出し語は、
常に一番最近に変換された語がミニマムポイントに挿入され、その配置はランダ
ムなものになるので、バイナリサーチを行なってはならない。

@item skk-large-jisyo
共有辞書。ユーザーの用途と資源に合わせて、S辞書、M辞書、L辞書の中から選
ぶ。@code{skk-search-jisyo-file}と対にすることを想定した辞書ファイル。

@item skk-aux-large-jisyo
共有辞書。ユーザーの用途と資源に合わせて、S辞書、M辞書、L辞書の中から選
ぶ。@code{skk-search-server}と対にして使用することを想定した辞書ファイ
ル。

@end vtable

また、@code{skk-search-prog-list}には含まれないが(勿論検索されない)、個
人辞書のバックアップ辞書として@code{skk-backup-jisyo}がある。

上記の例では、
@enumerate
@item
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}の順に検索を行ない、

@item
次に個人辞書を使って送り仮名の自動処理を行ない、

@item
その後、@code{skk-large-jisyo}の検索を行ない、

@item
最後に@code{skk-aux-large-jisyo}にサーバー経由でアクセスしている。

@end enumerate
もし確定辞書で候補が見つかったらそのまま自動的に確定される。1回 
@key{SPC}を押す動作に対し、プログラム側では新たな候補を見つけるまで上記
の動作を進める。例えば、
@enumerate

@item
確定辞書では候補は見つけられなかったが@code{skk-initial-search-jisyo}
に候補があれば、そこで一旦止まりユーザーにその候補を表示する。

@item
更に@key{SPC}が押されると、次は個人辞書を検索する。そこで候補が見つか
り、しかもその候補が@code{skk-initial-search-jisyo}で見つけた候補とは
異るものであったときは、そこでまた一旦止まりその候補をユーザーに表示する。
以降、共有辞書についても同様の繰り返しを行なう。

@end enumerate
@code{skk-search-prog-list}の設定方法としては、例えば 
@code{skk-large-jisyo}にS辞書かM辞書を指定し、S辞書、M辞書はEmacsのバッ
ファに読み込んで検索し@code{skk-aux-large-jisyo}に L辞書を指定して、L
辞書にはサーバー経由でアクセスする、という選択肢もある。

@noindent
また、サーバー経由のアクセスも決して遅くはないので、

@lisp
(skk-search-jisyo-file skk-large-jisyo 10000)
@end lisp

@noindent
を削除するという選択肢もある。ちなみに辞書ファイルの値が@code{nil}であ
れば、そのファイルを引数とした検索プログラムが
@code{skk-search-prog-list}に指定されていても、その検索は行なわれない。

@file{skk-auto.el}をロードすると、

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストが@code{skk-search-prog-list}に自動的に追加される
(@code{skk-auto-okuri-process}を@code{non-nil}に設定すると 
@file{skk-auto.el}がオートロードされる。)。追加される位置は、
@code{skk-jisyo}を検索するリストの次である。あるいは

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストを@code{skk-search-prog-list}の任意の位置に明示的に指定す
ると、@code{skk-okuri-search}を使って最初に検索したときに 
@file{skk-auto.el}がオートロードされる。

@file{skk-server.el}をロードすると、

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストが@code{skk-search-prog-list}に自動的に追加される
あるいは@code{skk-server-host}もしくは@code{skk-servers-list}を設定
するとSKKモードを起動したときに@file{skk-server.el}がオートロードされ
る。これらの場合、追加される位置は、@code{skk-search-prog-list}の末尾で
ある。あるいは

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストを@code{skk-search-prog-list}の任意の位置に明示的に指定す
ると@code{skk-search-server}を使って最初に検索を行なったときに 
@file{skk-server.el}がオートロードされる。

@node 入力モードの一時変更, ■モードにおける文字入力, 予備知識, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 入力モードの一時変更

日常の入力では、一般的に、かなモードを使用することが圧倒的に多いと考えら
れるが、ひらがなの中にカタカナ、全角アルファベットをちりばめて入力したい、
という要求も多いと考えられる。カタカナの入力にはカナモードを、全角アルファ
ベットの入力には全英モードを用いることは前述の通り
@footnote{@xref{入力モード, , カナモード、全英モード}.}であるが、一時的
にカナ文字、全英文字を入力して、また、かなモードに戻ることができる。

また、アスキーファイルを見出し語として使用するために、かなモードから一時
的にアスキー文字を入力する機能が提供されている。▽モードの変種である 
@dfn{SKK abbrev mode}がそれである。この機能を使用することにより、
@samp{is}@result{}@samp{インクリメンタル・サーチ}のような変換を行なう
ことができる。

@menu
* ひらがな/カタカナの一時的入力::  
* 全英文字の一時的入力::        
@end menu

@node ひらがな/カタカナの一時的入力, 全英文字の一時的入力, 入力モードの一時変更, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection ひらがな/カタカナの一時的入力
@kindex @samp{q}
@cindex トグル変換[とくるへんかん]

かなモードもしくはカナモードで、@samp{/}キー以外で一旦▽モードにして文
字列を挿入し、その文字列の末尾で@samp{q}をタイプすることで 
@footnote{@samp{/}キーでSKK abbrev modeに入ってしまうと@samp{q}キー入力が@samp{q}文字の入力として扱われてしまう。}
@samp{▽}マークから@samp{q}をタイプしたポイントまでの文字列が変換され
確定される。変換は、@samp{▽}とポイント間の文字列の種類@footnote{正確に言うと@samp{▽}の次の位置にある文字列をもって文字種の判別を行なっているので、途中で文字種類の違う文字が混在していても無視される。}
をキーとして下記の規則に基づき行なわれる。
@itemize @bullet

@item
カタカナはひらがなへ

@item
ひらがなはカタカナへ

@item
全英文字はアスキー文字へ

@item
アスキー文字は全英文字へ

@end itemize
一例を挙げる。

@example
@kbd{K a t a k a n a}

@group
------ Buffer: foo ------
▽かたかな@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
カタカナ@point{}
------ Buffer: foo ------
@end group
@end example

このトグル変換を上手く利用することにより、かなモードのまま一時的にカタカ
ナを入力したり、またその逆が可能となるので、一々@samp{q}キーにより入力
モードを2度切り換える必要がなく、ひらがな/カタカナ混じり文を書くときには
非常に便利であろう。

全英文字とアスキー文字のトグルでの変換を行なうことができるので、少し混乱
があるかもしれないが、全英モードやアスキーモードでは@samp{Q}やその他の
大文字により▽モードに入ることができないので、上記のトグル変換は行なうこ
とができないので注意すること。かなモード/カナモードにおいて、既に入力さ
れた全英文字、アスキー文字に対して上記の変換を行なうことができるのみであ
る。

なお、上記の変換は、いずれもリージョンに対するコマンドにて行なうこともで
きる。@xref{リージョン一括変換}.

@node 全英文字の一時的入力,  , ひらがな/カタカナの一時的入力, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection 全英文字の一時的入力
@kindex @samp{/}
@kindex C-q

@samp{/}をタイプした後、全角アルファベットとして入力したい文字列を挿入し、
その文字列の末尾で@kbd{C-q}@footnote{SKK abbrev modeに入っている。@kbd{C-q}は@code{skk-abbrev-map}にマッピングされたキーバインドである。@xref{アスキー文字を見出し語とした変換}.}
をタイプすることで、@samp{▽}マークから@kbd{C-q}をタイプしたポイントま
での文字列が全角アルファベットに変換され確定される。

@example
@kbd{/ f i l e}

@group
------ Buffer: foo ------
▽file@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
ｆｉｌｅ@point{}
------ Buffer: foo ------
@end group
@end example

なお、この変換を行なうために、

@example
file /ｆｉｌｅ/
@end example

@noindent
のような辞書エントリを持つ必要がない。辞書を参照せず、アスキー文字を1文
字づつ全英文字に変換しているためである。

@node ■モードにおける文字入力, ポイントを戻して▽モードへ, 入力モードの一時変更, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ■モードにおける文字入力

@menu
* かなモード/カナモードにおける入力::  
* 全英モードにおける入力::      
* 1回のadvertised-undo(undo)の対象::  
* 対になる文字列の一括入力::    
@end menu

@node かなモード/カナモードにおける入力, 全英モードにおける入力, ■モードにおける文字入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection かなモード/カナモードにおける入力

@menu
* ■モードにおける文字変換::    
* 数字や記号文字の入力::        
@end menu

@c @node ローマ字仮名変換ルール, 数字や記号文字の入力, かなモード/カナモードにおける入力, かなモード/カナモードにおける入力
@c @comment  node-name,  next,  previous,  up
@c @subsubsection ローマ字仮名変換ルール
@c @vindex skk-prefix

@c XXX
@c SKKでは、@code{skk-roma-kana-a}, @code{skk-roma-kana-i},
@c @code{skk-roma-kana-u}, @code{skk-roma-kana-e}, @code{skk-roma-kana-o}
@c という5つの連想リストを持ち、母音が入力された時点で対応する連想リストを
@c 走査して入力すべきかな/カナ文字を決定する。

@c 例えば、@code{skk-roma-kana-i}の値は、下記のようになっている。

@c @lisp
@c @group
@c '(("" . ("い" . "イ"))
@c   ("b" . ("び" . "ビ")) ("by" . ("びぃ" . "ビィ"))
@c   ("ch" . ("ち" . "チ")) ("cy" . ("ちぃ" . "チィ"))
@c   ("d" . ("ぢ" . "ヂ")) ("dh" . ("でぃ" . "ディ"))
@c   ("dy" . ("ぢぃ" . "ヂィ"))
@c   ("f" . ("ふぃ" . "フィ")) ("fy" . ("ふぃ" . "フィ"))
@c   ("g" . ("ぎ" . "ギ")) ("gy" . ("ぎぃ" . "ギィ"))
@c   ("h" . ("ひ" . "ヒ")) ("hy" . ("ひぃ" . "ヒィ"))
@c   ("j" . ("じ" . "ジ")) ("jy" . ("じぃ" . "ジィ"))
@c   ("k" . ("き" . "キ")) ("ky" . ("きぃ" . "キィ"))
@c   ("m" . ("み" . "ミ")) ("my" . ("みぃ" . "ミィ"))
@c   ("n" . ("に" . "ニ")) ("ny" . ("にぃ" . "ニィ"))
@c   ("p" . ("ぴ" . "ピ")) ("py" . ("ぴぃ" . "ピィ"))
@c   ("r" . ("り" . "リ")) ("ry" . ("りぃ" . "リィ"))
@c   ("s" . ("し" . "シ")) ("sh" . ("し" . "シ"))
@c   ("sy" . ("しぃ" . "シィ"))
@c   ("t" . ("ち" . "チ")) ("th" . ("てぃ" . "ティ"))
@c   ("ty" . ("ちぃ" . "チィ"))
@c   ("v" . ("う゛ぃ" . "ヴィ")) ("w" . ("うぃ" . "ウィ"))
@c   ("x" . ("ぃ" . "ィ")) ("xw" . ("ゐ" . "ヰ"))
@c   ("z" . ("じ" . "ジ")) ("zy" . ("じぃ" . "ジィ")))
@c @end group
@c @end lisp

@c @noindent
@c @samp{ち}を挿入すべく@kbd{t i}という入力を行なったとすると、最後の母音
@c である@samp{i}の入力時点で、@code{skk-roma-kana-i}を走査することが決
@c 定される。この連想リストの走査キーは、入力される仮名文字のローマ字プレ
@c フィックス@footnote{@xref{辞書の形式, , ローマ字プレフィックス}.}で、こ
@c の例では ``t'' となる。走査結果は、

@c @lisp
@c ("t" . ("ち" . "チ"))
@c @end lisp

@c @noindent
@c となる。かなモードのときは、この結果から@code{cadr}
@c @footnote{@code{cdr}の@code{car}。}の``ち''を、カナモードのときは、
@c @code{cddr}@footnote{@code{cdr}の@code{cdr}。}の``チ''を取り出し、カ
@c レントバッファに挿入する。

@c @samp{ch}や@samp{f}などヘボン式でしか使用しないキーの割付けをやめたい
@c ときは、@file{~/.emacs}や@file{~/.skk}に不要なセルを除いた 
@c @code{skk-roma-kana-i}を直接書くか、@code{skk-load-hook}を利用して、下
@c 記のように書く。

@c @lisp
@c @group
@c (add-hook 'skk-load-hook
@c           (function
@c            (lambda ()
@c              (setq skk-roma-kana-i
@c                    (delq (assoc "ch" skk-roma-kana-i) skk-roma-kana-i)
@c                    skk-roma-kana-i
@c                    (delq (assoc "f" skk-roma-kana-i) skk-roma-kana-i)))))
@c @end group
@c @end lisp

@c @noindent
@c 上記の

@c @lisp
@c (assoc "ch" skk-roma-kana-i)
@c @end lisp

@c @noindent
@c の代りに

@c @lisp
@c ("ch". ("ち" . "チ"))
@c @end lisp

@c @noindent
@c と書いても良いが、その場合は、@code{delq}の代りに@code{delete}を使用
@c すること。

@c XXX
@c 旧バージョンのSKKでは長さ2以上のプレフィックスについて 
@c @code{skk-roma-kana-[aiueo]}を変更したら、対応して 
@c @code{skk-prefix-list}も変更する必要があったが、バージョン10.47ではこれを内
@c 部変数@footnote{改名されて@code{skk-prefix-tree}という変数になった。ElibのAVL木パッケージを利用したAVL木構造となっている。@code{skk-prefix-list}の長さは24と結構長く、@code{skk-kana-input}で頻繁に参照、走査されるので@code{member}による逐次走査よりもAVL木を利用したバイナリーサーチの方が有利と判断した。}
@c として、SKKモードを起動する毎に自動計算するようになった。既にSKKモードに
@c なっているバッファで@code{skk-roma-kana-[aiueo]}を変更した場合は、
@c @kbd{C-x C-j}もしくは@kbd{C-x j}を2度タイプして@code{skk-mode}もし
@c くは@code{skk-auto-fill-mode}を起動し直す必要があるので注意すること。
@c @code{skk-roma-kana-[aiueo]}がユーザー変数であるために、SKK起動後にこれ
@c らの変数が変更される可能性があるので毎度計算し直すように設計されている。

@c @node 有限状態オートマトンを用いた変換, 数字や記号文字の入力, ローマ字仮名変換ルール, かなモード/カナモードにおける入力
@c @comment  node-name,  next,  previous,  up
@c @subsubsection 有限状態オートマトンを用いた変換
@c @cindex T-code
@c @cindex TUT-code
@c @cindex オートマトンの状態遷移規則[おーとまとんのしようたいせんいきそく]
@c @cindex 有限状態オートマトン[ゆうけんしようたいおーとまとん]
@c @vindex skk-rom-kana-rule-list
@c
@c @c XXX
@c ローマ字かな変換は、@code{skk-roma-kana-a}, @code{skk-roma-kana-i},
@c @code{skk-roma-kana-u}, @code{skk-roma-kana-e}, @code{skk-roma-kana-o}
@c という5つの連想リストに従い行われることは前節で述べた通りだが、
@c @code{skk-rom-kana-rule-list}により表現される有限状態オートマトンを用い
@c た変換も併用される@footnote{順序としては、オートマトンの状態遷移規則を用いたリストが先に参照され、そこに該当の規則がなければ、次に上記5リストが参照される。k}。
@c このリストのディフォルト値は、下記の通りである。
@c
@c @lisp
@c @group
@c '(("nn" nil ("ン" . "ん"))
@c   ("n'" nil ("ン" . "ん")))
@c @end group
@c @end lisp
@c
@c @noindent
@c リストの各要素は、オートマトンの状態遷移規則:
@c
@c @example
@c <現在の状態, 入力, 次の状態, 出力>
@c @end example
@c
@c @noindent
@c を
@c
@c @example
@c (現在の状態@@入力 次の状態 出力)
@c @end example
@c
@c @noindent
@c という形のリストで表現したものである。ここで@samp{状態}とは変換される前
@c のローマ字の文字列であり、@samp{入力}は今タイプされた文字を長さ1の文字列
@c とみなしたものである。@samp{@@}は文字列の連接を表わす。@samp{出力}は次
@c の状態に遷移するときにバッファに挿入される文字列のリストであり、かなモー
@c ドでは当該リストの@code{car}、カナモードでは@code{cdr}がバッファに挿
@c 入される。「次の状態」が@code{nil}のときには最終状態に遷移し、ローマ字
@c かな変換を終了する。
@c
@c 従い、上記のディフォルト値は、@kbd{nn}または@kbd{n'}をタイプすると、
@c かなモードでは@samp{ん}が、カナモードでは@samp{ン}がカレントバッファに挿
@c 入されることを示している。また、
@c
@c @lisp
@c @group
@c (setq skk-rom-kana-rule-list
@c       '(("nn" "n" ("ン" . "ん"))
@c         ("n'" nil ("ン" . "ん"))))
@c @end group
@c @end lisp
@c
@c @noindent
@c とすれば、
@c
@c @example
@c hannou @expansion{}はんのう
@c han'ou @expansion{}はんおう
@c @end example
@c
@c @noindent
@c のようにローマ字かな変換が行われる。
@c ところで、
@c
@c @example
@c ohsaka @expansion{}おおさか
@c ohta @expansion{}おおた
@c ohhira @expansion{}おおひら
@c @end example
@c
@c @noindent
@c のように@samp{oh}は特別に処理される。従い、@samp{ohhonn}とタイプする
@c と@samp{おおほん}となり@samp{おっほん}とはならない。
@c
@c @example
@c ohhonn @expansion{}おっほん
@c @end example
@c
@c @noindent
@c のように変換したければ、規則
@c
@c
@c @lisp
@c ("oh" "h" ("" . ""))
@c @end lisp
@c
@c @noindent
@c を追加する。
@c
@c この他、
@c
@c @example
@c tp @expansion{}東北大学
@c skk @expansion{}skk
@c skK @expansion{}SKK
@c @end example
@c
@c @noindent
@c といった変換も、
@c
@c
@c @lisp
@c @group
@c ("tp" nil ("東北大学" . "東北大学"))
@c ("sk" "sk" ("" . ""))
@c ("skk" nil ("skk" . "skk"))
@c ("skK" nil ("SKK" . "SKK"))
@c @end group
@c @end lisp
@c
@c @noindent
@c のような規則を追加すれば可能である。自分の名前を入力することはよくあるの
@c で、適当な省略形を用いて、このリストに追加しておくと便利かもしれない。
@c
@c 更に@code{skk-rom-kana-rule-list}を用いればT-codeやTUT-codeによる日本
@c 語入力を実現することもできる。この場合はルールの数が数千になり、このまま
@c ではルールへのアクセスに多くの時間を要するようになる。このようにルールの
@c 数が多いときは、以下のようにしてあらかじめルールのリストを木の形にコンパ
@c イルしておくと効率が良い。
@c
@c @enumerate
@c @item
@c まず、@file{.emacs}などに下記のフォームを追加する。
@c
@c @lisp
@c @group
@c
@c (setq skk-rom-kana-rule-tree
@c       (skk-compile-rule-list skk-rom-kana-rule-list))
@c
@c @end group
@c @end lisp
@c
@c @item
@c このままではSKKを起動するときに毎回@code{skk-compile-rule-list}を計算
@c することになるので、うまくゆくことが分れば、上記のフォームに代えて、
@c
@c @lisp
@c @group
@c
@c (skk-compile-rule-list skk-rom-kana-rule-list)
@c
@c @end group
@c @end lisp
@c
@c @noindent
@c の値を直に@file{~/.emacs}などに書いておく。
@c @end enumerate

@node ■モードにおける文字変換, 数字や記号文字の入力, かなモード/カナモードにおける入力, かなモード/カナモードにおける入力
@comment  node-name,  next,  previous,  up
@subsubsection ■モードにおける文字変換
@cindex T-code
@cindex TUT-code
@cindex オートマトンの状態遷移規則[おーとまとんのしようたいせんいきそく]
@cindex 有限状態オートマトン[ゆうけんしようたいおーとまとん]
@vindex skk-rom-kana-base-rule-list
@vindex skk-rom-kana-rule-list

XXX
SKKの■モードにおける文字変換は、@code{skk-rom-kana-base-rule-list},
@code{skk-rom-kana-rule-list}により表現される有限状態オートマトンを用い
て行なわれる。リストの各要素は、オートマトンの状態遷移規則:

@example
<現在の状態, 入力, 次の状態, 出力>
@end example

@noindent
を

@example
(現在の状態@@入力 次の状態 出力)
@end example

@noindent
という形のリストで表現したものである。ここで@samp{現在の状態}とは変換さ
れる前のASCII文字の文字列であり、@samp{入力}は今タイプされた文字を長さ1
の文字列とみなしたものである。@samp{@@}は文字列の連接を表わす。@samp{出
力}は次の状態に遷移するときにバッファに挿入される文字列のリストであり、
かなモードでは当該リストの@code{car}、カナモードでは@code{cdr}がバッ
ファに挿入される。「次の状態」が@code{nil}のときには最終状態に遷移し、
■モードにおける文字変換を終了する。

従い、上記のディフォルト値は、@kbd{nn}または@kbd{n'}をタイプすると、
かなモードでは@samp{ん}が、カナモードでは@samp{ン}がカレントバッファに挿
入されることを示している。また、

@lisp
@group

@end group
@end lisp
@c
@noindent
とすれば、

@example
hannou @expansion{}はんのう
han'ou @expansion{}はんおう
@end example

@noindent
のようにローマ字かな変換が行われる。
ところで、

@example
ohsaka @expansion{}おおさか
ohta @expansion{}おおた
ohhira @expansion{}おおひら
@end example

@noindent
のように@samp{oh}は特別に処理される。従い、@samp{ohhonn}とタイプする
と@samp{おおほん}となり@samp{おっほん}とはならない。

@example
ohhonn @expansion{}おっほん
@end example

@noindent
のように変換したければ、規則

@lisp
("oh" "h" ("" . ""))
@end lisp

@noindent
を追加する。

この他、

@example
tp @expansion{}東北大学
skk @expansion{}skk
skK @expansion{}SKK
@end example

@noindent
といった変換も、

@lisp
@group
("tp" nil ("東北大学" . "東北大学"))
("sk" "sk" ("" . ""))
("skk" nil ("skk" . "skk"))
("skK" nil ("SKK" . "SKK"))
@end group
@end lisp

@noindent
のような規則を追加すれば可能である。自分の名前を入力することはよくあるの
で、適当な省略形を用いて、このリストに追加しておくと便利かもしれない。

更に@code{skk-rom-kana-rule-list}を用いればT-codeやTUT-codeによる日本
語入力を実現することもできる。例えば TUT-code による入力についてはソース
アーカイブの @samp{experimental/tut-code} ディレクトリに収録されているソー
スコードを参照されたい。

@node 数字や記号文字の入力,  , ■モードにおける文字変換, かなモード/カナモードにおける入力
@comment  node-name,  next,  previous,  up
@subsubsection 数字や記号文字の入力
@findex skk-insert
@findex skk-set-henkan-point

かなモード/カナモードにおける次のキーは、かつては @code{skk-self-insert} 
関数にバインドされていたが、現在は他のキーと同様に @code{skk-insert} 関
数にバインドされている。

@example
@group
!  #  %  &  '  *  +

-  0  1  2  3  4  5

6  7  8  9  :  ;  <

=  >  ?  "  (  )  [

]  @{  @}  ^  _  `  |

~
@end group
@end example

これらの数字や記号文字のキーに対応し挿入される文字は、ベクトル
@code{skk-input-vector}の値により決定されていたが、このバージョンの SKK 
ではこの変数は廃止された。カスタマイズするためには、代わりに変数
@code{skk-rom-kana-rule-list} を利用する。例えば、SKK 9.6 以前において、

@lisp
(aset skk-input-vector ?! nil)
(aset skk-input-vector ?, nil)
(aset skk-input-vector ?. nil)
(aset skk-input-vector ?: nil)
(aset skk-input-vector ?; nil)
(aset skk-input-vector ?? nil)
@end lisp

このような設定をしていた場合、本バージョンの SKK で同様の入力をするため
には、

@lisp
(setq skk-rom-kana-rule-list
      '(("!" nil "!")
        ("," nil ",")
        ("." nil ".")
        (":" nil ":")
        (";" nil ";")
        ("?" nil "?")))
@end lisp

のような設定に変更する必要がある。

@code{skk-insert}は、Emacsのオリジナル関数である 
@code{self-insert-command}をエミュレートしているので、引数を渡すことに
より同じ文字を複数、一度に挿入することが可能である
@footnote{かつては、@samp{▽あ}などを入力する場合には引数渡しができなかっ
たが、本バージョンでばこれもできるように拡張されている。}。

@example
@group

@kbd{C-u 2 !}

------ Buffer: foo ------
！！
------ Buffer: foo ------
@end group
@end example

@node 全英モードにおける入力, 1回のadvertised-undo(undo)の対象, かなモード/カナモードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 全英モードにおける入力
@vindex skk-jisx0208-latin-vector
@findex skk-jisx0208-latin-insert

全英モードにおける印字可能な全てのキーは@code{skk-jisx0208-latin-insert}に割
り付けられており@code{skk-jisx0208-latin-vector}の値により挿入される文字が決
定される。@code{skk-jisx0208-latin-vector}のディフォルト値は、下記の通り。

@lisp
@group
[nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 "　"  "！" "”" "＃" "＄" "％" "＆" "’"
 "（" "）" "＊" "＋" "，" "−" "．" "／"
 "０" "１" "２" "３" "４" "５" "６" "７"
 "８" "９" "：" "；" "＜" "＝" "＞" "？"
 "＠" "Ａ" "Ｂ" "Ｃ" "Ｄ" "Ｅ" "Ｆ" "Ｇ"
 "Ｈ" "Ｉ" "Ｊ" "Ｋ" "Ｌ" "Ｍ" "Ｎ" "Ｏ"
 "Ｐ" "Ｑ" "Ｒ" "Ｓ" "Ｔ" "Ｕ" "Ｖ" "Ｗ"
 "Ｘ" "Ｙ" "Ｚ" "［" "＼" "］" "＾" "＿"
 "‘" "ａ" "ｂ" "ｃ" "ｄ" "ｅ" "ｆ" "ｇ"
 "ｈ" "ｉ" "ｊ" "ｋ" "ｌ" "ｍ" "ｎ" "ｏ"
 "ｐ" "ｑ" "ｒ" "ｓ" "ｔ" "ｕ" "ｖ" "ｗ"
 "ｘ" "ｙ" "ｚ" "｛" "｜" "｝" "〜" nil]
@end group
@end lisp

挿入される文字の変更方法等については、@ref{数字や記号文字の入力}を
参照のこと。

@code{skk-jisx0208-latin-insert}もEmacsオリジナルの関数 
@code{self-insert-command}をエミュレートしている関係から、引数を渡すこ
とにより同じ文字を複数、一度に挿入することができる。
@code{skk-insert}における動作と同じであるので、前述した例をご参照
いただきたい。@xref{数字や記号文字の入力}.

@node 1回のadvertised-undo(undo)の対象, 対になる文字列の一括入力, 全英モードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 1回のadvertised-undo(undo)の対象
@cindex @file{keyboard.c}
@findex self-insert-command
@findex skk-abbrev-comma
@findex skk-abbrev-period
@findex skk-kana-input
@findex skk-insert
@findex skk-set-henkan-point
@findex skk-jisx0208-latin-insert
@vindex skk-self-insert-non-undo-count

SKKモードになっていないEmacsオリジナルバッファでは、連続する20文字の挿入
が一度のアンドゥの対象となっている。かな・カナ・全英モードにおける入力も、
このオリジナルの動作をエミュレートしている 
@footnote{@code{buffer-undo-list}にEmacsが挿入したアンドゥの境目の目印を取り除く方法でエミュレートしている。}。
正確に言えば、@code{skk-kana-input}, @code{skk-self-insert},
@code{skk-set-henkan-point}, @code{skk-jisx0208-latin-insert} @footnote{SKK abbrevモードでは、アスキー文字入力がEmacsオリジナルの@code{self-insert-command}により行なわれているので、エミュレートのための内部変数である@code{skk-self-insert-non-undo-count}をインクリメントすることができず、アンドゥをエミュレートできない。しかも、カンマやピリオドを挿入した時点で、@code{skk-abbrev-comma}や@code{skk-abbrev-period}を使うことになるので、オリジナルのアンドゥの機能も損なってしまう。ただ、現実問題としては、元来SKK abbrevモードは省略形としての見出し語を挿入するためのモードであるので、長い見出し語を挿入することはあまりなく、問題も小さいと考えられる。}の各関数にバインドされたキー入力については、連続して入力された20文字を1つのアンドゥの対象としている@footnote{`20'はEmacsのソースファイルの一部である@file{keyboard.c}に定められたマジックナンバーと一致する。}。

但し、上記のSKKの関数とEmacsのオリジナルの@code{self-insert-command}を
織り混ぜてキー入力した場合@footnote{かなモードでの入力中、アスキーモードに移行してタイプした場合などがこれにあたるであろう。}は、このエミュレート機能は正常に働かないので注意すること。このエミューレート機能は、Mule-2.3添付の@file{egg.el}を参考にした。

@example
@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o}

------------------------- Buffer: foo -------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{連続する20文字。}
------------------------- Buffer: foo -------------------------
@end group
@group

@kbd{C-_}

------------------------- Buffer: foo -------------------------
                       ;@r{20文字全てがアンドゥの対象となる。}
------------------------- Buffer: foo -------------------------
@end group

@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o n a}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてとな ;@r{連続する21文字。}
-------------------------- Buffer: foo --------------------------
@end group
@group

@kbd{C-_}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{最後の1文字のみがアンドゥの対象となる。}
-------------------------- Buffer: foo --------------------------
@end group
@end example

@node 対になる文字列の一括入力,  , 1回のadvertised-undo(undo)の対象, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 対になる文字列の一括入力
@vindex skk-auto-insert-paren
@vindex skk-auto-paren-string-alist
@vindex skk-rom-kana-rule-list
@vindex yatex-mode
@vindex tex-mode-hook

@c @samp{「}や@samp{」}が上手く処理されない...。
例えば、`「' を入力したら、必ずと言って良いほど `」' を後で入力する必要
がでてくる。`「' の入力時点で、対になる文字を自動挿入してくれるとタイプ
数を減らすことができ、入力忘れの防止にもなる。
@code{skk-auto-insert-paren}の値を@code{non-nil}にすると、上記の自動
挿入を行なう。

@example
@group
------ Buffer: foo ------
彼はこう言った@point{}
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
彼はこう言った「@point{}」
------ Buffer: foo ------
@end group
@end example

@noindent
@c @samp{「}や@samp{」}が上手く処理されない...。
上記のように `「' の入力時点で対となる`」'を自動挿入し、`「'と`」'の間に
ポイントを再配置するので、その位置からかぎかっこに囲まれた文字列を即始め
ることができる。

自動挿入すべきペア文字列は、@code{skk-auto-paren-string-alist}で指定す
る。そのディフォルト値は下記の通り。

@lisp
@group
'(("「" . "」") ("『" . "』") ("(" . ")") ("（" . "）") ("@{" . "@}")
  ("｛" . "｝") ("〈" . "〉") ("《" . "》") ("[" . "]") ("［" . "］")
  ("〔" . "〕") ("【" . "】") ("\"" . "\"") ("“" . "”"))
@end group
@end lisp

@noindent
各リストの@code{car}に指定された文字列を挿入すると、@code{cdr}に指定
された文字列を自動挿入する。このリストの各要素の@code{car}に指定された
文字列は、対になる文字列の自動挿入のために、例えアスキー文字であっても 
@code{skk-rom-kana-rule-list}に指定する必要がある。既にSKKモードになっ
ているバッファで@code{skk-auto-paren-string-alist}を変更した場合は、
@kbd{C-x C-j}もしくは@kbd{C-x j}を2度タイプして@code{skk-mode}もし
くは@code{skk-auto-fill-mode}を起動し直す必要があるので注意すること。

キーとなる文字の挿入が行なわれても、その挿入後のポイントに自動挿入すべき
文字が既に存在している場合には、自動挿入は行なわれない。

@example
@group
------ Buffer: foo ------
@point{}」
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
「@point{}」
------ Buffer: foo ------

@end group
@end example

対になる文字を複数挿入したい場合は、引数を渡して文字を指定する。具体例を
述べる。

@example
@group

@kbd{C-u 2 [}

------ Buffer: foo ------
「「@point{}」」
------ Buffer: foo ------
@end group
@end example

@code{yatex-mode}など、既に同種の機能が付いているモードがある。そのよう
なモードにおいてもこの自動挿入の機能が邪魔になることはないと考えるが、そ
のモードにおいてのみこの機能をオフにしたい場合は、該当のモードに入ったと
きにコールされるフックを利用して設定を行なうことができる。

@lisp
@group
(add-hook 'yatex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (set (make-local-variable 'skk-auto-insert-paren) nil)))))
@end group
@end lisp

特定のモードにおいて、自動挿入すべき文字を変更したい場合にも同様にフック
を用いて操作できる。

@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (cons '("$" . "$") skk-auto-paren-string-alist)))))))
@end group
@end lisp

@noindent
特定のペアを削除したい場合は、例えば下記のように設定する@footnote{何故@code{copy-sequence}を使用するのかについては、@ref{数字や記号文字の入力}を参照。}。
@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (delete
                          '("$" . "$")
                          (copy-sequence skk-auto-paren-string-alist))))))))
@end group
@end lisp

@node ポイントを戻して▽モードへ, 確定変換とそのアンドゥ, ■モードにおける文字入力, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ポイントを戻して▽モードへ
@cindex ▽マークの付け忘れ[▽まーくのつけわすれ]
@kindex M-Q
@vindex skk-allow-spaces-newlines-and-tabs

見出し語の入力を大文字で開始することを忘れた場合の▽マークの付け方につい
ては前述したが@footnote{@xref{▽モード, , ▽マークの付け忘れ}.}、これを
簡略化し、ワンアクションで行なう方法について説明する。

@kbd{M-Q}@footnote{@samp{Q}は大文字で入力する必要がある。}とタイプする
とポイントの直前の文字列について走査し、同種の文字@footnote{ひらがな、カタカナ、全角アルファベット、アルファベットの4種類のいずれか。}が続く限りbackward方向にポイントを戻して▽モードに入り、またポイントを@kbd{M-Q}入力時の地点に戻す。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{M-Q}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

変換開始ポイントの走査時には、スペース文字、タブ文字、長音を表わす
@samp{ー}は無条件にスキップされる。但し、ひらがなの場合は@samp{を}の直前
で、カタカナの場合は@samp{ヲ}の直前で変換開始ポイントの走査を止め、▽モー
ドに入る。変換開始ポイントを@samp{を}、@samp{ヲ}の直前で止めるのは、文章
が@samp{事情を考慮する}のように@samp{×××を○○○}の形態になっており、
@samp{○○○}のみを変換の対象としたい場合が圧倒的に多いからである。

無引数で@kbd{M-Q}を実行した場合は上記のように文字の種類によりポイント
を必要数のみbackward方向へ戻すが、明示的に戻す文字数を指定するには 
@kbd{C-u 5 M-Q}のように引数を渡して実行する。この場合は文字種別を問わず、
与えられた文字数だけ無条件にポイントを戻す。

なお、backward方向にポイントを戻す途中で行頭に到達した場合は、更に上の行
について行末の文字列から同様の走査を行ない、必要があれば更にポイントを戻
す。@code{skk-allow-spaces-newlines-and-tabs}の値を@code{nil}にするこ
とで、行を超えての走査をやめることができる。

@node 確定変換とそのアンドゥ, 確定アンドゥ, ポイントを戻して▽モードへ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 確定変換とそのアンドゥ
@cindex 暗黙の確定[あんもくのかくてい]
@findex skk-search-kakutei-jisyo-file
@vindex skk-kakutei-jisyo

確定変換を行なうプログラム@code{skk-search-kakutei-jisyo-file}と 確定
辞書@code{skk-kakutei-jisyo}については前節で述べたが、ここではその動作
について具体的に説明する。例えば、

@example
せつめい /説明/
@end example

@noindent
というエントリが確定辞書にあったとすると、

@example
@group
@kbd{S e t u m e i}

@group
------ Buffer: foo ------
▽せつめい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
説明
------ Buffer: foo ------
@end group
@end group
@end example

@noindent
のように確定動作をすることなしに(暗黙の確定もなく) いきなり確定する。仮
に確定辞書に

@example
じしょ /辞書/
@end example

@noindent
というエントリを挿入してしまったが、@samp{自署}に変換したい場合は、確定
直後に@samp{x}をタイプすることにより確定変換をアンドゥして▽モードに戻
ることができ、次に@key{SPC}をタイプしたときは、確定辞書は検索を行なわ
ないので、個人辞書、あるいは共有辞書に

@example
じしょ /自署/
@end example

@noindent
のエントリがあれば@samp{自署}への変換を行なうことができる。


@example
@group
@kbd{Z i s y o @key{SPC}}

@group
------ Buffer: foo ------
辞書
------ Buffer: foo ------
@end group

@kbd{x}

@group
------ Buffer: foo ------
▽じしょ
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼自署
------ Buffer: foo ------
@end group

@end group
@end example

@node 確定アンドゥ, 見出し語関連, 確定変換とそのアンドゥ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 確定アンドゥ
@cindex 暗黙の確定[あんもくのかくてい]
@findex skk-undo-kakutei

一番最後に行なった変換についての確定をアンドゥして、再変換を行なうことが
できる。これを@b{「確定アンドゥ」}という。確定変換のアンドゥと混同しない
こと。

下記に例を示す。辞書エントリが

@example
こうこう /高校/孝行/航行/
@end example

@noindent
のようになっているとする。

@example
@kbd{K o u k o u @key{SPC}}

@group
------ Buffer: foo ------
▼高校
------ Buffer: foo ------
@end group

@kbd{s u r u}

@group
------ Buffer: foo ------
高校する@point{}
------ Buffer: foo ------
@end group

@kbd{M-x skk-undo-kakutei}

@group
------ Buffer: foo ------
▼孝行@point{}する
------ Buffer: foo ------
@end group
@end example

@noindent
@samp{高校}の確定についてアンドゥしたので、辞書の第一候補である@samp{高
校}をスキップして、次候補である@samp{孝行}の変換を行なっている。候補
@samp{孝行}について▼モードに入ったところで、▼モードにおいて通常の変換
で@samp{孝行}を得た時点と全く同一の状態にあるので、更に@key{SPC}を押し
てこの例での次候補である@samp{航行}を変換により求めたり、更にもう一度 
@key{SPC}を押して辞書登録モードに入ることもできる。

確定した直後(上記の例では、送り仮名である@samp{する}の入力のための 
@samp{s}の入力前) でなくともアンドゥが可能である。より正確には、次の
新たな確定@footnote{@kbd{C-j}をタイプして明示的に確定した場合は勿論、暗黙の確定を行なった場合も同様である。}を行なうまではアンドゥに関する情報が保持されているので、アンドゥが可能である。

変換、確定に関連しない文字列は、確定アンドゥを行なっても削除されない。上
記の例では、@samp{する}がそのままカレントバッファに残っていることに注意。

@node 見出し語関連, 送り仮名関連, 確定アンドゥ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 見出し語関連

@menu
* 見出し語の補完::              
* 見出し語を補完しながら▼モードへ::  
* 空白・改行・タブを含んだ見出し語の変換::  
* カタカナの見出し語::          
@end menu

@node 見出し語の補完, 見出し語を補完しながら▼モードへ, 見出し語関連, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語の補完
@cindex 読みのコンプリーション[よみのこんふりーしよん]
@cindex 見出し語のコンプリーション[みたしこのこんふりーしよん]
@kindex @samp{,}
@kindex @samp{.}
@kindex @key{TAB}
@vindex skk-dabbrev-like-completion
@vindex skk-search-prog-list

▽モードで@key{TAB}を押すと、見出し語(▽モードにおける入力文字列)に対
する補完が行われる。@key{TAB}を押す直前に▽モードで入力された文字列をσ
とすると、個人辞書@footnote{共有辞書はサーチされない。共有辞書では一般的に先頭の文字を共通にする見出し語が多すぎて、望みの補完が行なえる可能性が低いからである。}の送りなしエントリの中で、先頭がσと一致し長さがσよりも長い見出し語を捜して、そのようなτがもしあれば、σの代わりにτが表示される。見出し語の補完を上手に利用することで、タイプ数を減らすことができる。

▼モードで変換を行なった語の見出し語について、時間的に新しいものから先に
補完が行なわれる。例えば、@samp{斉藤}、@samp{佐藤}の順で変換した後、
@samp{さ}をキーにして見出し語の補完を行なうと、最初に@samp{さとう}が、そ
の次に@samp{さいとう}が補完される。補完が意図したものでなかったときには 
@key{TAB}の直後に@samp{.}(ピリオド)をタイプすると2番目の見出し語が表
示される。以下同様に@samp{.}を続けてタイプすると、見出し語の候補が順次
表示される。意図した見出し語を通りすぎたときは@samp{,}(コンマ)で前の候
補に戻る。

@example
@kbd{S a t o u @key{SPC}C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group

@kbd{S a}

@group
------ Buffer: foo ------
▽さ
------ Buffer: foo ------
@end group

@key{TAB}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@samp{.}

@group
------ Buffer: foo ------
▽さいとう@footnote{@samp{さとう}の次に補完される見出し語は、個人辞書の
内容に依存する。}
------ Buffer: foo ------
@end group

@samp{,}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼佐藤
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group
@end example

なお、個人辞書の検索は、見出し語を得るために行なわれるので、一旦 
@key{SPC}をタイプして▼モードに入れば@code{skk-search-prog-list}の順
に候補が検索される(@code{skk-search-prog-list}で個人辞書の前に検索を行
なうように設定されている検索もスキップせずに行なう)。例えば、
@code{skk-search-prog-list}で確定変換を行なう設定を行なっており、確定辞
書にその見出し語があれば、見出し語を補完した際にも確定変換が行なわれる。

@code{skk-dabbrev-like-completion}の値を@code{non-nil}にすることで、
@samp{.}で2番目以降の補完を行なったときに、最初に補完された語について補
完が行われる。つまり上記の例では@samp{さ}に対し、最初に補完された語は、
@samp{さとう}であるので、以後の補完は、@samp{さとう}を含む語(例えば、
@samp{さとうせんせい}など) について行なわれる。

@node 見出し語を補完しながら▼モードへ, 空白・改行・タブを含んだ見出し語の変換, 見出し語の補完, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語を補完しながら▼モードへ
@cindex 見出し語のコンプリーション[みたしこのこんふりーしよん]
@cindex 読みのコンプリーション[よみのこんふりーしよん]
@kindex M-@key{SPC}

前節で見出し語の補完について述べたが、その見出し語の補完動作を行なった後、
@key{SPC}をタイプし、▼モードに入るまでの動作をワンアクションで行なうこ
とができる。補完される見出し語が予め把握できている状況では、キータイプが
ワンアクション省略できる。長い見出し語の専門用語を連続して入力する場合な
どに威力を発揮する。

@example
@group
@kbd{K a s i t a n n p o s e k i n i n n}

@group
------ Buffer: foo ------
▽かしたんぽせきにん
------ Buffer: foo ------
@end group

@key{SPC}, @key{RET}

@group
------ Buffer: foo ------
瑕疵担保責任
------ Buffer: foo ------
@end group

@kbd{K a}

@group
------ Buffer: foo ------
▽か
------ Buffer: foo ------
@end group

@kbd{M-@key{SPC}}

@group
------ Buffer: foo ------
▼瑕疵担保責任
------ Buffer: foo ------
@end group

@end group
@end example

@node 空白・改行・タブを含んだ見出し語の変換, カタカナの見出し語, 見出し語を補完しながら▼モードへ, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 空白・改行・タブを含んだ見出し語の変換
@vindex skk-allow-spaces-newlines-and-tabs

下記のようにオートフィルモードで折り返された文字列に対し、折り返された状
態のまま変換を行なうことができる。

@example
@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムをさ
くせいしました。@point{}
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 10 C-b Q}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽@point{}さ
くせいしました。
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 5 C-f}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽さ
くせい@point{}しました。
---------------- Buffer: foo ------------------
@end group

@key{SPC}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▼作成@point{}しました。
---------------- Buffer: foo ------------------
@end group
@end example

上記の例では改行だが、空白、タブ文字を中間に含む文字列に対しても変換を行
なうことができる。@code{skk-allow-spaces-newlines-and-tabs}の値を 
@code{nil}にすることで2行以上にまたがる文字列に対する変換を禁止すること
ができる。

@node カタカナの見出し語,  , 空白・改行・タブを含んだ見出し語の変換, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection カタカナの見出し語
@kindex C-u @key{SPC}

@samp{q}によりかなモード、カナモードを度々切り替えて入力を続けていると、
カナモードで誤って▼モードに入ってしまうことがあるので、カナモードで▼モー
ドに入ろうとすると、まず見出し語をひらがなに変換するように設計されている。

更に、送りあり変換で、送り仮名もカタカナにしたい場合については、
@ref{カナモードでの変換の送り仮名の処理}を参照のこと。

あまりないケースだとは思うが、見出し語をカタカナのまま残して変換を行ない
たい場合には@key{SPC}に代えて@kbd{C-u @key{SPC}}のように@kbd{SPC}
に数値引数を渡せば良い。

@node 送り仮名関連, 自動変換開始, 見出し語関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 送り仮名関連

@menu
* 送り仮名の厳密なマッチ::      
* 送り仮名の自動処理::          
* 送りあり変換の変換開始のタイミング::  
* カナモードでの変換の送り仮名の処理::  
@end menu

@node 送り仮名の厳密なマッチ, 送り仮名の自動処理, 送り仮名関連, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の厳密なマッチ
@vindex minibuffer-exit-hook
@vindex minibuffer-setup-hook
@vindex skk-henkan-okuri-strictly
@vindex skk-process-okuri-early

例えば、個人辞書に

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
という送りありエントリがあれば@kbd{O o K i i @key{SPC}}とタイプした場
合、標準では@samp{大きい}と@samp{多きい}という 2 通りの候補が出力可能で
あるが、この内@samp{多きい}を選択することは有り得ない。送りあり変換で、
見出し語が同じ文字列であっても選択する可能性のある候補とない候補が混在し
ている場合が多く、更に候補の絞り込みをしたいという要請が出てくる。

変数@code{skk-henkan-okuri-strictly}の値を@code{non-nil}にすると、見
出し語がマッチするかどうかのチェックの上に、送り仮名がマッチするかどうか
のチェックが行なわれ、送り仮名がマッチしない候補を出力しない。上記の場合
では、送り仮名@samp{き}がマッチする@samp{大きい}のみを出力し、@samp{多き
い}を出力しない。個人辞書の送りありエントリが充実しておれば、標準の設定
よりも候補が絞り込まれるので変換効率がアップするが、個人辞書の送りありエ
ントリが充実していなければ、すぐに辞書登録モードに入ってしまい逆効果とな
る。

このユーザーオプションは@code{skk-process-okuri-early}の値を 
@code{non-nil}にした状態と共存できない。詳細は
@ref{送りあり変換の変換開始のタイミング}を参照のこと。メニューバーを使用
してこのユーザーオプションをオンにすると、自動的に 
@code{skk-process-okuri-early}の値を@code{nil}にすることができる。

変数@code{skk-henkan-okuri-strictly}の値を@code{non-nil}にすると、辞
書登録モードに入っても送り仮名のマッチが厳密に行なわれるので、辞書登録時
に漢字を得るのに一苦労する羽目になる。下記のようにフックを設定することで
辞書登録時のみ、一時的に送り仮名の厳密なマッチをしないようにすることがで
きる。 

@lisp
@group
(add-hook 'minibuffer-setup-hook
          (function
           (lambda ()
             (if (and (boundp 'skk-henkan-okuri-strictly)
                      skk-henkan-okuri-strictly
                      (not (eq last-command 'skk-purge-jisyo)))
                 (progn
                   (setq skk-henkan-okuri-strictly nil)
                   (put 'skk-henkan-okuri-strictly 'temporary-nil t))))))

@end group
@group
(add-hook 'minibuffer-exit-hook
          (function
           (lambda ()
             (if (get 'skk-henkan-okuri-strictly 'temporary-nil)
                 (progn
                   (put 'skk-henkan-okuri-strictly 'temporary-nil nil)
                   (setq skk-henkan-okuri-strictly t))))))
@end group
@end lisp

@noindent
下記のように設定できればもっと簡潔なのだが、
@code{skk-henkan-okuri-strictly}の値は辞書バッファで参照されるために、
ミニバッファのバッファローカル値を変更しても狙った効果は得られないので注
意すること。

@lisp
@group
(add-hook 'minibuffer-setup-hook
          (function
           (lambda ()
             (if (and (boundp 'skk-henkan-okuri-strictly)
                      skk-henkan-okuri-strictly )
                 (set (make-local-variable 'skk-henkan-okuri-strictly)
                      nil )))))
@end group
@end lisp

@noindent
将来のバージョンでは、これを改良し、辞書バッファでの動作に影響するユーザー
変数をバッファローカル化できるようにする予定である。@xref{拡張アイディア}.

@node 送り仮名の自動処理, 送りあり変換の変換開始のタイミング, 送り仮名の厳密なマッチ, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の自動処理
@vindex skk-auto-okuri-process

@menu
* どのように変換されるか::      
* 辞書登録の際に注意すべきこと::  
@end menu

@node どのように変換されるか, 辞書登録の際に注意すべきこと, 送り仮名の自動処理, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection どのように変換されるか
@vindex skk-auto-okuri-process

変数@code{skk-auto-okuri-process}を@code{non-nil}にセットすると、文
法的な知識を用いない送り仮名の自動処理が行なわれる。送り仮名の最初のロー
マ字表現を大文字で始める必要がない
@footnote{@xref{▼モード, , 送り仮名の入力}.}という利点があるが、同時に
ユーザがシステムに与える情報が少なくなるので、意図しない変換をされる割合
が増えるという欠点がある。また下記に述べるようにこの自動処理は個人辞書に
依存しているので、個人辞書の送りありエントリが貧弱な場合は、自動処理がで
きない可能性が高い。ただ、@code{skk-auto-okuri-process}を 
@code{non-nil}にセットしていても、送り仮名の開始位置を大文字のキーをタ
イプして明示的に指定することも可能であり、かつ、送り仮名を明示した場合の
変換には影響を与えないので、送りなし変換で意図しないものまで拾う可能性が
ある他はデメリットもなく、むしろ送り仮名を正確に思い出せない場合に送り仮
名を指定しなくとも変換できるメリットがあるので、この変数の値を常に 
@code{non-nil}にするのも良い選択かもしれない@footnote{専ら補完的に自動
送り処理を利用するのであれば、@code{(skk-okuri-search)}を
@code{skk-search-prog-list}の最後にもってくるのが良いであろう。}。

例えば、@kbd{T a t i a g e r u @key{SPC}}とタイプした場合、@samp{たち
あげる}という見出し語に対し、送り仮名を明示されていないので、まず送りな
し変換として扱い辞書を検索する。このときは、通常の変換同様、個人辞書及び
指定された共有辞書他を検索する。通常はそのような見出し語はないので、今度
は個人辞書のみを検索の対象として、見出し語を最後尾から1文字づつ切り詰め、
「切り詰めの結果残った文字列」と、「切り捨てられた先頭の文字のローマ字プ
レフィックス」を連結した文字列を送りあり変換の見出し語として、検索する。
この例において検索される見出し語の変化を追うと、

@example
@samp{たちあげる}@result{}@samp{たちあげr}@result{}@samp{たちあg}
@result{}@samp{たちa}@result{}@samp{たt}
@end example

@noindent
のようになる。仮に個人辞書エントリが、

@example
@group
たちあg /立ち上/[げ/立ち上/]/[が/立ち上/]/
たt /建/断/経/立/[つ/建/断/経/立/]/[ち/建/断/経/立/]/[て/経/立/建/]/
@end group
@end example

@noindent
の2つのエントリを含むとすると、見出し語を後方から順に切り詰める過程で
@samp{たちあg}と@samp{たt}の2つの見出し語の検索時にこれらの辞書エントリ
がマッチする。

@noindent
次に、マッチしたエントリの各候補に対し、切り捨てられた先頭の文字を送り仮
名として取るかどうかをチェックする。@samp{たちあg}の場合の送り仮名チェッ
クの対象は、切り捨てられた最初の文字の@samp{げ}であるので、

@example
[げ/立ち上/]
@end example

@noindent
の部分のみに注目する。また、@samp{たt}の場合の送り仮名チェックの対象は、
@samp{ち}であるので、

@example
[ち/建/断/経/立/]
@end example

@noindent
のみに注目する。もうお分りのように、マッチする見出し語に対しチェックす
るのは送り仮名ブロック部分だけであり、送り仮名に対応していない全候補を含
む部分(@samp{たt}の場合は、候補の最初の@samp{/建/断/経/立/}の部分)は
単に無視される。

@noindent
送り仮名がマッチする候補@samp{立ち上}、@samp{建}、@samp{断}、@samp{経}、
@samp{立}の5つを文字列の長さ順に昇順にソートし、それぞれの候補と該当の見
出し語から切り捨てられた文字列と連結したもの(「該当の見出し語から切り捨
てられた文字列」を送り仮名とみなして処理している。)を、送り仮名の自動処
理の最終候補として返す。上記の例では、@samp{立ち上げる}、@samp{建ちあげ
る}、@samp{断ちあげる}、@samp{経ちあげる}、@samp{立ちあげる}の5つが最終
候補である。長さ順にソートするのは、変換された部分がより長い候補を先順位
として出力するためである。上記の例の@samp{立ち上げる}と@samp{建ちあげる}
とでは、@samp{立ち上げる}の方が変換された部分が長いので、@samp{立ち上げ
る}を@samp{建ちあげる}より先順位で出力する。

@node 辞書登録の際に注意すべきこと,  , どのように変換されるか, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録の際に注意すべきこと
@vindex skk-kana-rom-vector

個人辞書に見出し語@samp{わたs}についてのエントリが全くない場合、あるいは
個人辞書のエントリが

@example
わたs /渡/[し/渡/]/
@end example

@noindent
のような送り仮名のブロックを持たない場合、@kbd{W a t a s i t a
@key{SPC}}とタイプすると、送り仮名のマッチができないので、候補の選定が
できず辞書登録モードに入る。

@example
@group
@kbd{W a t a s i t a @key{SPC}}

------ Buffer: foo ------
▼わたした
------ Buffer: foo ------

------ Minibuffer -------
わたした@point{}
------ Minibuffer -------
@end group
@end example

@noindent
辞書登録モードで@kbd{W a t a S i t a @key{RET}}と送り仮名を明示的にタ
イプし、@samp{渡した}と変換し登録する。この場合、登録する語の最後が平仮
名で終るので、その最後の平仮名の文字列(上記の例では、@samp{した})が見出
し語の最後と一致するかを調べ、一致する場合には、辞書の登録を送りありエン
トリとして行なうのかどうかの確認を求めてエコーエリアにプロンプトを出す
@footnote{@code{y-or-no-p}はミニバッファを使用しているのではなく、エコー
エリアにプロンプトを表示して次の1文字を待っている。@code{yes-or-no-p}は
ミニバッファを使用している。}。

@example
@group
@kbd{W a t a S i t a}
------ Minibuffer -------
わたした 渡した
------ Minibuffer -------
@end group
@group

@key{RET}

-------------------------- Echo Area --------------------------
Shall I register this as okuri-ari entry: わたs /渡/ ? (y or n)
-------------------------- Echo Area --------------------------
@end group
@end example

@noindent
プロンプトに対し、@samp{y}と回答した場合は、

@example
わたs /渡/[し/渡/]/
@end example

@noindent
という辞書エントリが個人辞書の送りありエントリに書き込まれる。@samp{n}
で回答した場合は、個人辞書の送りなしエントリに

@example
わたした /渡した/
@end example

@noindent
というエントリが書き込まれてしまうので、この例では適当でない。

送り仮名部分をローマ字プレフィックスに分解する際には、ユーザー変数 
@code{skk-kana-rom-vector}の値が参照される。この変数のディフォルト値は、
下記の通り。

@example
@group
["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
 "k" "g" "k" "g" "s" "z" "s" "j" "s" "z" "s" "z" "s" "z" "t" "d"
 "t" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
 "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
 "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
 "x" "w" "n"]
@end group
@end example

このベクトルは、それぞれ下記のかな文字をそのローマ字プレフィックスで現わ
したものである。

@example
@group
ぁ  あ  ぃ  い  ぅ  う  ぇ  え  ぉ  お  か  が  き  ぎ  く  ぐ
け  げ  こ  ご  さ  ざ  し  じ  す  ず  せ  ぜ  そ  ぞ  た  だ
ち  ぢ  っ  つ  づ  て  で  と  ど  な  に  ぬ  ね  の  は  ば
ぱ  ひ  び  ぴ  ふ  ぶ  ぷ  へ  べ  ぺ  ほ  ぼ  ぽ  ま  み  む
め  も  ゃ  や  ゅ  ゆ  ょ  よ  ら  り  る  れ  ろ  ゎ  わ  ゐ
ゑ  を  ん
@end group
@end example

@noindent
従い、ディフォルトでは、例えば見出し語中の送り仮名の@samp{じ}は、
@samp{j}に、@samp{ち}は、@samp{t}に、@samp{ふ}は、@samp{h}のローマ字
プレフィックスに分解される。これらの送り仮名のローマ字プレフィックスをそ
れぞれ@samp{z}、@samp{c}、@samp{f}に変更したい場合は、該当の個所を "z"、
"c"、"f" とするようなベクトルを@file{.emacs}や@file{.skk}に書いてお
く。

@samp{ありがさつき}に対し@samp{有賀さつき}を登録したい場合は、上記と
同様に辞書登録をし、

@example
@group
Shall I register this as okuri-ari entry: ありがs /有賀/ ? (y or n)
@end group
@end example

@noindent
のプロンプトに対し@samp{n}と回答する。この結果、個人辞書の送りなしエン
トリには、

@example
ありがさつき /有賀さつき/
@end example

@noindent
というエントリが書き込まれる。

@node 送りあり変換の変換開始のタイミング, カナモードでの変換の送り仮名の処理, 送り仮名の自動処理, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換の変換開始のタイミング
@kindex C-x C-j
@kindex C-x j
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-jisyo
@vindex skk-kakutei-early
@vindex skk-process-okuri-early

@code{skk-process-okuri-early}の値を@code{non-nil}にすることで、送り
あり変換の変換開始のタイミングを早め、送り仮名のローマ字プレフィックスの
入力時点で変換を開始することができる。

@example
@group
@kbd{U g o K}

------ Buffer: foo ------
▼動k
------ Buffer: foo ------
@end group
@end example

送り仮名が分らないまま変換していることになるので@code{skk-jisyo}が送り
仮名に対応した形に成長しない。つまり@samp{うごk /動/}のような形態のま
まとなる。但し、

@example
@group
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
@end group
@end example

@noindent
のようなエントリが既に@code{skk-jisyo}にあれば、それを破壊しない 
@footnote{@ref{辞書の形式}を参照のこと。}。このユーザーオプションを 
@code{non-nil}にしてSKKモードを起動すると、両立できないオプションである
下記オプションは@code{nil}にセットされる。

@example
@group
@code{skk-kakutei-early}, @c ここに footnote を持ってきても脚注が表われない...
@code{skk-auto-okuri-process}, @code{skk-henkan-okuri-strictly}
@end group
@end example

SKKモード起動後にこのオプションの設定を変更した場合で、カレントバッファ
では既にSKKモードに入っているときは、@kbd{C-x C-j}もしくは@kbd{C-x
j}を2回タイプしてSKKモードを起動し直すことで、これらのユーザーオプショ
ン間の衝突を調整できる。またはメニューバーからこのユーザーオプションをオ
ンにすると、自動的に上記の衝突を調整できる。
@xref{暗黙の確定のタイミング, , skk-kakutei-early}.
@xref{送り仮名の自動処理, , skk-auto-okuri-process}.
@xref{送り仮名の厳密なマッチ, , skk-henkan-okuri-strictly}.

@node カナモードでの変換の送り仮名の処理,  , 送りあり変換の変換開始のタイミング, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection カナモードでの変換の送り仮名の処理
@vindex skk-convert-okurigana-into-katakana

カナモードのまま変換を行なうと、見出し語をひらがなに変換してから辞書の検
索を行なうことは前述の通りだが(@pxref{カタカナの見出し語})、カナモードで
送りあり変換を行なうと、

@example
@group
------ Buffer: foo ------
考えル。
------ Buffer: foo ------
@end group
@end example

@noindent
のように送り仮名の第1文字だけが、ひらがなのまま残ってしまう。カナモード
での変換が誤って行なわれた場合はこれで良いことが多いのだが、漢字・カナ混
じり文を書いているときは、送り仮名の第1文字もカタカナ変換された方が便利
である。@code{skk-convert-okurigana-into-katakana}の値を@code{non-nil}
にすることで、カナモードにて送りあり変換を行なった場合、送り仮名の第1文
字もカタカナに変換するようになる。

@node 自動変換開始, 特殊変換, 送り仮名関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 自動変換開始
@vindex skk-auto-henkan-start
@vindex skk-auto-henkan-start-keyword-list
@vindex skk-auto-okuri-process

▽モードで見出し語の入力中に、単語や文節の区切りとなるような文字を打鍵す
ると、▽マークからポイントの直前の文字までを見出し語とし(最後に入力され
た文字は見出し語には含まれない)、@key{SPC}を打鍵することなく自動的に変
換を開始し▼モードに入るようになっている@footnote{某メーカーのMSDOS上の
FEPの仕様を参考にした。}。単語や文節の区切りとなるような文字列は、
@code{skk-auto-henkan-start-keyword-list}にて指定する。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@group

@kbd{w o}
------ Buffer: foo ------
▼漢字を
------ Buffer: foo ------
@end group
@end example

@code{skk-auto-okuri-process}を@code{non-nil}にして 送り仮名の自動処
理(@pxref{送り仮名の自動処理})を行なっている場合は、下記のような変換も可
能である(辞書に@samp{できr /出来/[る/出来/]/}というようなエントリがあ
るとして)。

@example
@kbd{D e k i r u n n d e s u}

@group
------ Buffer: foo ------
▽できるんです
------ Buffer: foo ------
@end group
@group

@kbd{.}
------ Buffer: foo ------
▼出来るんです。
------ Buffer: foo ------
@end group
@end example

@code{skk-auto-henkan-start-keyword-list}のディフォルト値は下記の通りで
ある。

@lisp
@group
'("を" "、" "。" "．" "，" "？" "」" "！" "；" "：" ")" ";" 
  ":" "）" "”" "】" "』" "》" "〉" "｝" "］" "〕" "@}"
  "]" "?" "." "," "!" )
@end group
@end lisp

この自動変換開始機能をオフにしたければ、@code{skk-auto-henkan-start}の
値を@code{nil}にする。

@node 特殊変換, 接頭辞・接尾辞, 自動変換開始, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 特殊変換

@menu
* 数値変換::                    数を含む文字列の変換。
* アスキー文字を見出し語とした変換::  アスキー文字を使った省略形からの変換。
* 今日の日付の入力::            今日の日付を一発入力。
* プログラム実行変換::          Emacs Lispプログラムを使った変換。
@end menu

@node 数値変換, アスキー文字を見出し語とした変換, 特殊変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 数値変換
@cindex #0
@cindex #1
@cindex #2
@cindex #3
@cindex #4
@cindex #5
@cindex 数をパラメータとする語の変換[かすをはらめーたとするこのへんかん]
@cindex 数値再変換[すうちさいへんかん]
@vindex skk-numeric-conversion-float-num
@vindex skk-use-numeric-conversion

数をパラメータ(引数)とする語には、@samp{４月１５日}、@samp{第１２回}など
がある。日本語ではこれらを@samp{四月一五日}や@samp{第12回}、@samp{第一二
回}、@samp{第十二回}などとも表現することができるが、これらに別々の辞書見
出しを与えていたのでは変換効率をダウンさせる要因となる。従いSKKでは
@samp{第１２回}というような変換を行ないたい場合には、その数字部分を 
@samp{#}で置き換えた見出し語@samp{第#回}を用いる。

これに対応する辞書のエントリとしては、例えば、

@example
だい#かい /第#0回/第#1回/第#2回/第#3回/
@end example

@noindent
のような文字列を与える。@samp{#}の文字に数字@samp{0}、@samp{1}、
@samp{2}、@samp{3}、@samp{4}、@samp{5}、@samp{9}を加えた文字列は、数字
をタイプ別に表わしたもので、その意味は下記の通りである。

@table @samp

@item #0
タイプ0。無変換。入力されたアスキー文字をそのまま出力する。アスキー文字
による数字のみが必要なのであれば、わざわざ変換することはないが、アスキー
文字の数字の前後に他の文字列をもった組合せ@footnote{例えば、@samp{第12
回}など。}を変換するときに必要となる。

@item #1
タイプ1。全角文字での数字。@samp{12}を@samp{１２}に変換する。

@item #2
タイプ2。漢数字で位取りなし。@samp{5500}は@samp{五五〇〇}に変換する。

@item #3
タイプ3。漢数字で位取りあり。@samp{5500}は@samp{五千五百}に変換する。

@item #4
タイプ4。数値再変換。見出し語中の数字そのもの@footnote{@samp{p125}とい
う見出し語であれば、その数値部分である@samp{125}が再変換の見出し語とな
る。}をキーとして辞書を再検索し@samp{#4}の部分を再検索の結果の文字列で
入れ替える。例を後述する。

@item #5
タイプ5。小切手や手形の金額記入の際用いられる標記で変換する。例えば、
@samp{1995}を@samp{壱阡九百九拾伍}に変換する。

@item #9
タイプ9。将棋の棋譜の入力用。@samp{全角数字 + 漢数字}に変換する。例を後
述する。

@end table
いくつか例を述べる。辞書に

@example
# /#3/
@end example

@noindent
というエントリがあるときに、

@example
@group
@kbd{Q 1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}@footnote{または@kbd{/
1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}。}
@end group
@end example

@noindent
とタイプすれば、@samp{百兆二千三億四十万五百}と変換される@footnote{数字
を大文字で入力し始めるわけにはゆかないので@samp{Q}または@samp{/}で▽
モードに入る必要がある。}。

辞書エントリ

@example
#m#d /#0月#0日/
@end example

@noindent
に対し@kbd{/ 2 m 2 5 d @key{SPC}}とタイプすれば、@samp{2月25日}と変換
される@footnote{@samp{m}や@samp{d}などアスキー文字を見出し語として入
力したい場合は@samp{/}キーを最初にタイプしSKK abbrev modeで入力する必
要がある。@xref{アスキー文字を見出し語とした変換, , SKK abbrev mode}.}。

辞書エントリ

@example
#kin /#9金/
@end example

@noindent
に対し、@kbd{/ 3 4 k i n @key{SPC}}とタイプすれば、@samp{３四金}と変換
される。

辞書エントリ

@example
@group
p# /#4/
125 /東京都葛飾区/
@end group
@end example

@noindent
に対し、@kbd{/ p 1 2 5 @key{SPC}}タイプすれば、見出し語@samp{p125}の
候補が@samp{#4}であるので、見出し語の数字部分の@samp{125}に対し辞書
が再検索され、@samp{東京都葛飾区}と変換される。

辞書登録の例を1つ述べる。@samp{２月２５日}を得るために、

@example
@kbd{Q 2 g a t u 2 5 n i t i @key{SPC}}
@end example

@noindent
とタイプしたときに、辞書に見出し語

@example
#がつ#にち
@end example

@noindent
がないときは、辞書登録時のプロンプトは、@w{@samp{#がつ#にち}}となる。全
角数字のタイプは、@samp{#1}なので、@samp{２月２５日}の全角数字部分を 
@samp{#1}で置き換えた文字列@w{@samp{#1月#1日}}をミニバッファで作り登録
する。辞書エントリは、

@example
#がつ#にち /#1月#1日/
@end example

@noindent
となる。

なお、@code{skk-numeric-conversion-float-num}の値を@code{non-nil}にする
と、浮動小数点数を使った見出し語に対応して変換を行なう。但し、その場合は、

@example
#.# /#1．#1/#0月#0日/
@end example

@noindent
などの辞書見出しが使用できなくなるので、注意すること。

数値変換を行ないたくないときは、変数@code{skk-use-numeric-conversion}
の値を@code{nil}にする。

@node アスキー文字を見出し語とした変換, 今日の日付の入力, 数値変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection アスキー文字を見出し語とした変換
@cindex SKK abbrev mode

@dfn{SKK abbrev mode}では、アスキー文字を見出し語とした変換を行なうこと
ができる。

まず、かなモードで@samp{/}を入力することで、見出し語入力の間一時的にこ
のモードに入る。続けて入力する文字は、アスキー文字としてカレントバッファ
に挿入される。見出し語となるアスキー文字を入力し終った時点で@key{SPC}
を押せば、その見出し語についての変換が得られる。仮に、

@example
is /インクリメンタル・サーチ/
@end example

@noindent
というようなエントリが辞書にあるとして、

@example
@kbd{/}

@group
------ Buffer: foo ------
▽
------ Buffer: foo ------
@end group

@kbd{is}

@group
------ Buffer: foo ------
▽is
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼インクリメンタル・サーチ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
インクリメンタル・サーチ
------ Buffer: foo ------
@end group
@end example

@noindent
のように変換が行なわれる。

入力したアスキー文字をそのまま全角アルファベットに変換したい場合について
は、@ref{全英文字の一時的入力, 全角アルファベットへの変換}を参照のこと。

なお、SKK abbrev modeにおいても見出し語の補完を行なうことができる。
@xref{見出し語の補完}.

@node 今日の日付の入力, プログラム実行変換, アスキー文字を見出し語とした変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 今日の日付の入力
@kindex @@
@vindex skk-date-ad
@vindex skk-number-style
@cindex プログラム実行変換[ふろくらむしつこうへんかん]

かな/カナモードで@kbd{@@}をタイプすれば、今日の日付が入力される。

日付の形式は変数@code{skk-date-ad}と@code{skk-number-style}により決
定される。@code{skk-date-ad}の値が@code{non-nil}であれば西暦で、
@code{nil}であれば元号で表示する。@code{skk-date-ad}のディフォルト値は 
@code{nil}である。

また@code{skk-number-style}には下記の種類がある。

@table @code

@item 0
@itemx nil
半角数字。@samp{1996年7月21日(日)}のようになる。

@item 1
@itemx t
全角数字。@samp{１９９６年７月２１日(日)}のようになる。

@item 2
漢数字。@samp{一九九六年七月二一日(日)}のようになる。

@end table

上記の@samp{1996年}、@samp{１９９６年}、@samp{一九九六年}の例は、いず
れも@code{skk-date-ad}の値が@code{nil}であれば@samp{平成8年}のよう
に元号で表示される。@code{skk-number-style}のディフォルト値は、@samp{1}
である。

L辞書@footnote{@xref{辞書の形式, , L辞書}.}には, 見出し語@samp{today}の
もとに、@code{skk-date-ad}と@code{skk-number-style}の全ての組み合わせ
がプログラム実行変換機能@footnote{@xref{プログラム実行変換}.}を用いて登
録されている。従い、@kbd{/ t o d a y @key{SPC}}とタイプすれば、今日の日
付が上の形式で順次候補として表示される。

@kbd{@@}による日付けの変換入力を行ないたくない場合は、

@lisp
(setq skk-rom-kana-rule-tree
      (append skk-rom-kana-rule-tree
              '(("@@" nil "@@"))))
@end lisp

@noindent
のようにすることにより、アスキー文字の@samp{@@}が挿入されるようになる。
あるいは、全角文字の@samp{＠}を挿入したい場合は、

@lisp
(setq skk-rom-kana-rule-tree
      (append skk-rom-kana-rule-tree
              '(("@@" nil "＠"))))
@end lisp

@noindent
のようにする。

@node プログラム実行変換,  , 今日の日付の入力, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection プログラム実行変換
@cindex @file{skk-gadget.el}
@findex skk-calc

辞書の候補にEmacs Lispのプログラムが書いてあれば、そのプログラムをEmacs
の機能で実行し、返り値をカレントバッファに挿入する。これを@b{「プログラ
ム実行変換」}という。例えば、辞書に

@example
now /(current-time-string)/
@end example

@noindent
というエントリがあるときに@kbd{/ n o w @key{SPC}}とタイプすれば、カレ
ントバッファには@code{current-time-string}の返値である 

@example
Sun Jul 21 06:40:34 1996
@end example

@noindent
のような文字列が挿入される。

実行変換プログラムの返り値は文字列である必要がある。プログラム実行変換の
辞書登録は通常の単語と同様に行なうことができるが、その中に改行を含んでは
ならない。@footnote{通常の単語は、物理的な改行を、評価するとその位置に改
行を挿入するような実行変換プログラムに変換して辞書に書き込んでいる
(@pxref{辞書の形式})が、実行変換プログラムは、そのプログラム中の改行だけ
を取り出して、上記のように改行を表現することができない。}。

今日の日付の入力@footnote{@xref{今日の日付の入力}.}で説明した 
@samp{today}の辞書エントリは下記のような実行変換プログラムとなっている。

@lisp
@group
today /(let ((skk-date-ad) (skk-number-style t)) (skk-today))/@dots{}/
@end group
@end lisp

@file{skk-gadget.el}@footnote{@samp{gadget}は「上手く工夫した道具」の
意味。「色々飛び出す気のきいたおもちゃ箱」というような意味で名付けられた。
余談だが、X Windowで使用される@samp{Widget}という言葉は、
@samp{window}+@samp{gadget}から作られた造語らしい。}には、西暦/元号変換
プログラムや、簡単な計算プログラムなど、実行変換プログラムが集められてい
る。その中の1つを説明する。下記は、引数としてoperatorを取り、見出し語の
数字に対しその演算を行なう簡単な計算プログラムである。

@lisp
@group
(defun skk-calc (operator)
  ;;@r{2つの引数を取って operator の計算をする。}
  ;;@r{注意: '/ は引数として渡せないので (defalias 'div '/) などとし、別の形で}
  ;;@r{skk-calc に渡す。}
  ;;@r{辞書見出し例; #*# /(skk-calc '*)/}
  (int-to-string (apply operator (mapcar 'string-to-int skk-num-list))))
@end group
@end lisp

数値変換@footnote{@xref{数値変換}.}で説明した通り、見出し語における数字
は@samp{#}で表わして辞書登録を行なうので@samp{111*45}のような乗算を
行ないたいときは、

@example
#*# /(skk-calc '*)/
@end example

@noindent
という辞書エントリを用意する。@kbd{Q 1 1 0 * 4 5 @key{SPC}}とタイプした
ときの@samp{111}と@samp{45}の2つの数字は、SKK内部では変換時に 
@code{skk-num-list}に@w{@code{("111" "45")}}のように文字列のリストと
して保存される。このリストの各要素に対し乗算を行ないたいので、各要素を一
旦数値に変換し、その数値にoperatorを適用し、その結果を文字列に変換して返
す、という作業を行なっている。

@node 接頭辞・接尾辞, 暗黙の確定のタイミング, 特殊変換, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 接頭辞・接尾辞
@cindex 接頭辞[せつとうし]
@cindex 接尾辞[せつひし]
@vindex skk-special-midashi-char-list

辞書の見出し語の一部に@samp{>}, @samp{<}, @samp{?}を用いることにより接
頭辞(prefix)、接尾辞(suffix)の入力をサポートしている。例えば、辞書に 

@example
>し /氏/
@end example

@noindent
というエントリーがあるとき、@samp{小林氏}を接尾辞入力を用いて、以下のよ
うに入力することができる(@point{}はポイントを表わす)。

@example
@kbd{K o b a y a s h i}

@group
------ Buffer: foo ------
▽こばやし@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼小林@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
小林▽>@point{}
------ Buffer: foo ------
@end group

@kbd{s i}

@group
------ Buffer: foo ------
小林▽>し@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
小林▼氏@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
小林氏@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
このように入力することで、見出し語@samp{し}に対応する語で、接尾辞になり
得ないものを候補に入れずに辞書が構成可能になるので、候補の絞り込みの点で
有利である。同様に辞書に

@example
ちょう> /超/
@end example

@noindent
というエントリーがあるとき、@samp{超大型}を接頭辞入力を用いて以下のよう
に入力することができる。

@example
@kbd{T y o u}

@group
------ Buffer: foo ------
▽ちょう@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
▼超@point{}
------ Buffer: foo ------
@end group

@kbd{O o g a t a}

@group
------ Buffer: foo ------
超▽おおがた@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
超▼大型@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
超大型@point{}
------ Buffer: foo ------
@end group
@end example

接頭辞・接尾辞の入力の指定に使用するキーは、
@code{skk-special-midashi-char-list}の値を変更することによりカスタマイ
ズできる。この変数のディフォルト値は、

@lisp
(?> ?< ??)
@end lisp

である。@samp{?}をタイプした時点で接頭辞・接尾辞入力に移行するのではな
く、全角文字@samp{？}を挿入したい場合には@samp{?}を 
@code{skk-special-midashi-char-list}から外して

@lisp
@group
(setq skk-special-midashi-char-list '(?> ?<))
@end group
@end lisp

@noindent
とする。

@node 暗黙の確定のタイミング, リージョン一括変換, 接頭辞・接尾辞, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 暗黙の確定のタイミング
@cindex 暗黙の確定[あんもくのかくてい]
@vindex skk-kakutei-early
@vindex skk-process-okuri-early

標準の設定では、▼モードにおいて印字可能な文字または@key{RET}をタイプ
すると、暗黙の確定が行なわれ直ちに確定する。具体的には下記のようになる。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
確定s
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
確定す
------ Buffer: foo ------
@end group
@end example

@code{skk-kakutei-early}の値を@code{non-nil}にすることで、暗黙の確定
が行なわれるタイミングを、カッコ類(@samp{(}, @samp{)}, @samp{[},
@samp{]})や句読点(@samp{,}, @samp{.})の入力時、次の変換開始時(@samp{A}
から@samp{Z}までの大文字)、あるいは@key{RET}入力時まで後へずらすこと
ができる。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
▼確定s
------ Buffer: foo ------
@end group

@kbd{u r u}

@group
------ Buffer: foo ------
▼確定する
------ Buffer: foo ------
@end group

@kbd{.}

@group
------ Buffer: foo ------
確定する。
------ Buffer: foo ------
@end group
@end example

@noindent
区切の良いところまで一気に入力しておき、後で候補を選択する、というような
使い方をするときには便利なユーザーオプションであろう。なおこのユーザーオ
プションは@code{skk-process-okuri-early}とは共存できないので、
@code{skk-process-okuri-early}の値を@code{nil}にしておく必要がある。
メニューバーからこのユーザーオプションをオンにしたときは、これらのユーザー
オプション間の衝突は自動的に調整される。

@node リージョン一括変換, 漢字コード関連, 暗黙の確定のタイミング, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section リージョン一括変換
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@cindex 逆引き[きやくひき]
@findex skk-ascii-region
@findex skk-gyakubiki-katakana-message
@findex skk-gyakubiki-katakana-region
@findex skk-gyakubiki-message
@findex skk-gyakubiki-region
@findex skk-hiragana-region
@findex skk-hurigana-katakana-message
@findex skk-hurigana-katakana-region
@findex skk-hurigana-message
@findex skk-hurigana-region
@findex skk-katakana-region
@findex skk-romaji-message
@findex skk-zenkaku-region
@kindex M-x skk-ascii-region
@kindex M-x skk-gyakubiki-katakana-message
@kindex M-x skk-gyakubiki-katakana-region
@kindex M-x skk-gyakubiki-message
@kindex M-x skk-gyakubiki-region
@kindex M-x skk-hiragana-region
@kindex M-x skk-hurigana-katakana-message
@kindex M-x skk-hurigana-katakana-region
@kindex M-x skk-hurigana-message
@kindex M-x skk-hurigana-region
@kindex M-x skk-katakana-region
@kindex M-x skk-romaji-message
@kindex M-x skk-zenkaku-region
@vindex skk-romaji-*-by-hepburn

下記のコマンドを@kbd{M-x}により呼ぶことでリージョン一括変換を行なうこ
とができる。変換の種類と対応するコマンドは以下の通り。

@table @asis

@item カタカナをひらがなへ変換。
@kbd{M-x skk-hiragana-region}

@item ひらがなをカタカナへ変換。
@kbd{M-x skk-katakana-region}

@item 全英文字をアスキー文字へ変換。
@kbd{M-x skk-ascii-region}

@item アスキー文字を全英文字へ変換。
@kbd{M-x skk-zenkaku-region}

@item 漢字をひらがなへ変換。
@kbd{M-x skk-gyakubiki-region}具体的な変換例をあげると、

@example
``漢字をひらがなへ変換。''@expansion{}``かんじをひらがなへへんかん。''
@end example

@noindent
のようになる。引数を渡して、@kbd{C-u M-x skk-gyakubiki-region}のように
することで、複数の候補がある場合は、`@{@}' でくくって表示する。例えば、

@example
``中島''@expansion{}``@{なかしま|なかじま@}''
@end example

@noindent
のようになる。送り仮名がある語は、送り仮名まで含めてリージョンに指定しな
いと誤変換の原因となる。例えば、@samp{五月蝿い}について、送り仮名
@samp{い}を含めずにこのコマンドを実行すると、@samp{ごがつはえ}に変換さ
れてしまう。

@item 漢字をカタカナへ変換。
@kbd{M-x skk-gyakubiki-katakana-region}具体的な変換例は上記を参照のこ
と。引数を渡して、@kbd{C-u M-x skk-gyakubiki-katakana-region}のようにす
ることで、複数の候補がある場合は、`@{@}' でくくって表示する。

@item 漢字にふりがなを付ける。
@kbd{M-x skk-hurigana-region}具体的には例えば、

@example
``漢字の脇に''@expansion{}``漢字[かんじ]の脇[わき]に''
@end example

@noindent
のようにふりがなが振られる。引数を渡して、@kbd{C-u M-x
skk-hurigana-region}のようにすることで、複数の候補がある場合は、
`@{@}' でくくって表示する。

@item 漢字にカタカナのふりがなを付ける。
@kbd{M-x skk-hurigana-katakana-region}変換例は、上記を参照のこと。引
数を渡して、@kbd{C-u M-x skk-hurigana-katakana-region}のようにすること
で、複数の候補がある場合は、`@{@}' でくくって表示する。

@item 漢字、ひらがな、カタカナ、全英文字を全てローマ字へ変換。
@kbd{M-x skk-romaji-region}ディフォルトでは、ローマ字への変換様式にヘ
ボン式を用いる。例えば、

@example
``し''@expansion{}``shi''
@end example

@noindent
@code{skk-romaji-*-by-hepburn}の値を@code{nil}にすると、訓令式(「日本
式」とも言うようだ)を用いる。例えば、

@example
``し''@expansion{}``si''
@end example

@noindent
昭和29年12月9日付内閣告示第一号によれば、原則的に訓令式(日本式)を用いる
かのように記載されているが、今日一般的な記載方法は、むしろ、ヘボン式であ
るように思う。

@end table

メニューバーが使用できる環境では、メニューバーを使ってこれらの一括変換コマ
ンドを起動することができる。
@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.

上記の内、最後の5つについては、KAKASIがインストールされていなければ使用
することができない。@xref{KAKASI}.

また、KAKASI関連コマンドと同様の変換を行なうが、リージョンの文字列を置き
換えるのではなく、変換結果をエコーエリアに表示するコマンドがある。コマン
ド名のみ紹介する。上述のリージョン一括変換コマンドの説明と下記のコマンド
名から容易に動作を想像することができるであろう。引数を渡してコールした場
合の動作も同様である。

@itemize @bullet

@item @kbd{M-x skk-gyakubiki-message}

@item @kbd{M-x skk-gyakubiki-katakana-message}

@item @kbd{M-x skk-hurigana-message}

@item @kbd{M-x skk-hurigana-katakana-message}

@item @kbd{M-x skk-romaji-message}

@end itemize

@node 漢字コード関連, ▼モードの特殊キー, リージョン一括変換, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 漢字コード関連

@menu
* 漢字コードまたはメニューによる文字入力::  
* 漢字コードを知る方法::        
@end menu

@node 漢字コードまたはメニューによる文字入力, 漢字コードを知る方法, 漢字コード関連, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードまたはメニューによる文字入力
@cindex JISコード
@cindex EUCコード
@kindex @samp{\}

@samp{\}キーをタイプすることにより、漢字コード(JISまたはEUCコード) ま
たはメニューによる文字入力が可能となる。ミニバッファには、
@w{@samp{JIS or EUC code (00nn or CR for Jump Menu): }}というプロンプト
が出る。

漢字コードが予め分っている場合にはそのプロンプトに対し、漢字コードを入力
する。例えば@samp{℃}の漢字コードは、JIS コードでは@samp{216e}、EUCコー
ドでは@samp{a1ee}なので、いずれかの漢字コードを入力すれば@samp{℃}がカレ
ントバッファに挿入される。

漢字コードが不明の文字の入力には2段階メニューを用いた入力が可能である。
プロンプトに対し@key{RET}キーをタイプすると、第1段階のメニューが次のよう
に表示される。

@example
@group
A:　  S:￣  D:〜  F:｝  G:＝  H:¢  Q:◆  W:  E:∩  R:  T:≡  Y:  
@end group
@end example

第1段階のメニューでは、JIS漢字をコードの順に16文字毎に1文字抽出し、ミニ
バッファに一度に12文字づつ表示される。上記の例では、JISコード 
@samp{2121}の全角スペースが@samp{A:　}として、以下@samp{2131}、
@samp{2141}、@samp{2151}@dots{}の文字がそれぞれ@samp{B:￣}、
@samp{C:〜}、@samp{D:｝}@dots{}として表示される。ここで@key{SPC}をタ
イプすると、漢字コードの値を@w{16x12 @equiv{}192}づつ増やし次の候補群
を表示する。@samp{x}により1つ前の候補群に戻ることができる。

メニューのキー@samp{a}, @samp{s}, @samp{d}, @samp{f}, @samp{g},
@samp{h}, @samp{q}, @samp{w}, @samp{e}, @samp{r}, @samp{t}, @samp{y}の
いずれかをタイプすれば@footnote{大文字でも小文字でも可。}、そのキーに対
応する文字から始まる16個の文字が漢字コード順に表示される。これを第2段階
のメニューという。例えば、第1段階のメニューが上記の状態のときに@samp{d}
をタイプすると第2段階のメニューは以下のようになる。

@smallexample
@group
A:〜 S:‖ D:｜ F:… G:‥ H:‘ J:’ K:“ L:” Q:（ W:） E:〔 R:〕 T:［ Y:］ U:｛ 
@end group
@end smallexample

第2段階のメニュー中のキーをでタイプすると、対応する文字がカレントバッファ
に挿入されてメニューによる入力が終了する。第2段階のメニューが表示されて
いるときも@key{SPC}と@samp{x}キーで第2段階のメニューを前進、後退させ
ることができる。また@samp{<}、@samp{>}によりメニューを1文字分だけずら
すことができる。例えば、第2段階のメニューが上記の状態のときに@samp{<}
をタイプすると、メニューは以下のようになる。

@smallexample
@group
A:＼ S:〜 D:‖ F:｜ G:… H:‥ J:‘ K:’ L:“ Q:” W:（ E:） R:〔 T:〕 Y:［ U:］
@end group
@end smallexample

第1段階あるいは第2段階のメニューが表示されているときに@samp{?}をタイプ
すると、そのときのキー@samp{A}に対応する文字(上記の例では、@samp{＼}) 
の文字コードが表示される。第1段階も第2段階もメニューのメニューのキーは、
ユーザーが変更することができる。これについては、@ref{候補の選択に用いる
キー}を参照のこと。

@node 漢字コードを知る方法,  , 漢字コードまたはメニューによる文字入力, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードを知る方法
@kindex @samp{$}
@cindex JISコード
@cindex EUCコード

かな/カナモードで@samp{$}をタイプすれば、ポイントにある漢字コードをミ
ニバッファに表示する。例えば、カーソルを文字@samp{А}の上に置いて 
@samp{$}をタイプすると

@example
『А』  EUC: a7a1 (167, 161), JIS: 2721 ( 39,  33)
@end example

@noindent
がエコーエリアに表示され、この文字がロシア文字であることがわかる。

@node ▼モードの特殊キー, 辞書関連, 漢字コード関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ▼モードの特殊キー

@menu
* 確定動作を行なうキー::        
* 候補の選択に用いるキー::      
* ▼モードでのRET::             
* ▼モードでのBS::              
* 送りあり変換中のC-g::         
@end menu

@node 確定動作を行なうキー, 候補の選択に用いるキー, ▼モードの特殊キー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 確定動作を行なうキー
@vindex skk-kakutei-key
@kindex C-j

明示的な確定動作は@code{skk-kakutei-key}の値により指定されるキーにより
行なわれる。標準設定ではその値は ``\C-j'' となっている。


@node 候補の選択に用いるキー, ▼モードでのRET, 確定動作を行なうキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 候補の選択に用いるキー
@vindex skk-henkan-show-candidates-keys
@vindex skk-input-by-code-menu-keys1
@vindex skk-input-by-code-menu-keys2

変換において、候補が5つ以上あるときは5番目以降の候補は7つずつまとめてエ
コーエリアに下記のように表示される@footnote{@xref{▼モード}.}。

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

この際、候補の選択に用いるキーは、
@code{skk-henkan-show-candidates-keys}に7つのchar typeのキーを持つリス
トを代入して変更できる。ディフォルト値は、下記の通りである。

@lisp
'(?a ?s ?d ?f ?j ?k ?l)
@end lisp

このリストには7つの小文字のchar typeのキーを含まなければならない。
@samp{x}, @key{SPC}及び@kbd{C-g}は、それぞれ候補選択中における前候補
群の表示、次候補群の表示、取り止めのために割り付けられているので、
@code{skk-henkan-show-candidates-keys}の中に含めてはならない。

メニューによる文字入力
@footnote{@xref{漢字コードまたはメニューによる文字入力}.}の際に候補の選
択に用いられるキーは、下記の2変数により変更することができる。

@table @code

@item skk-input-by-code-menu-keys1
第1段階のメニューにおける候補の選択キー。

@item skk-input-by-code-menu-keys2
第2段階のメニューにおける候補の選択キー。

@end table

@code{skk-input-by-code-menu-keys1}のディフォルト値は、

@lisp
'(?a ?s ?d ?f ?g ?h ?q ?w ?e ?r ?t ?y)
@end lisp

@noindent
である。このリストには12個の文字のchar typeのキーを含む必要がある。

また@code{skk-input-by-code-menu-keys2}のディフォルト値は、

@lisp
'(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u)
@end lisp

@noindent
である。このリストには16個の文字のchar typeのキーを含む必要がある。
@code{skk-input-by-code-menu-keys1}と 
@code{skk-input-by-code-menu-keys2}に共通であるが、このリストに小文字が
指定された場合は、候補の選択の際にユーザーにより該当の大文字キーが入力さ
れても候補の選択が可能となるようにSKK内部で処理されるが、このリストに大
文字が指定された場合、ユーザーにより該当の小文字キーが入力されても候補の
選択ができなくなってしまう。いずれのリストにも小文字で指定することをお勧
めする。

@node ▼モードでのRET, ▼モードでのBS, 候補の選択に用いるキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{RET}
@vindex skk-egg-like-newline

標準設定では、

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定
@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
のように、▼モードで@key{RET}を入力すると、確定し、かつ改行を行なうが、
@code{skk-egg-like-newline}の値を@code{non-nil}にすると、確定するのみ
で改行しない。

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定@point{}
------ Buffer: foo ------
@end group
@end example

辞書登録モードにおいて▼モードであるとき、@key{RET}の入力により確定動作
と辞書登録動作が同時に行なわれたが、@code{skk-egg-like-newline}の値が 
@code{non-nil}であるときは、確定はするが改行しないので、結果的に辞書登
録動作のためにもう一度@key{RET}を入力する必要がある。辞書登録モードに
おけるディフォルトの確定、登録の動作については、@ref{辞書登録モード}を参
照のこと。

@node ▼モードでのBS, 送りあり変換中のC-g, ▼モードでのRET, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{BS}
@vindex skk-delete-implies-kakutei
@kindex @key{BS}

標準設定では、▼モードで@key{BS}を押すと、前の一文字を削除し確定する。

@example
@kbd{D e n k i y a @key{SPC}}

@group
------ Buffer: foo ------
▼電気屋
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
電気
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-implies-kakutei}の値を@code{non-nil}にすると、一つ前
の候補を表示する。例えば、

@example
でんき /電気/伝記/
@end example

@noindent
という辞書エントリがあったとすると、下記のようになる。

@example
@kbd{D e n k i @key{SPC}@key{SPC}}

@group
------ Buffer: foo ------
▼伝記
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▼電気
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▽でんき
------ Buffer: foo ------
@end group
@end example

@node 送りあり変換中のC-g,  , ▼モードでのBS, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換中の@kbd{C-g}
@kindex C-g
@vindex skk-delete-okuri-when-quit

送りありの変換中に@kbd{C-g}をタイプすると、▼モードを抜け、その見出し
語と送り仮名をカレントバッファに挿入し、■モードに入る。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
なく
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-okuri-when-quit}の値を@code{non-nil}にすれば 
@kbd{C-g}のタイプにより送り仮名を消す。例えば、下記のようになる。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
▽な
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-okuri-when-quit}の値を@code{non-nil}にすることにより
そのままの状態で送り仮名の再入力が可能となるので、送り仮名の入力間違いを
犯しやすい人には便利であろう。

@node 辞書関連, デコレーション, ▼モードの特殊キー, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 辞書関連

@menu
* 個人辞書中の単語の削除::      
* 個人辞書の保存動作::          
* 変換及び個人辞書に関する統計::  
* 辞書エントリの数えあげ::      
* 辞書バッファの文字コードの設定::  
* 辞書バッファのメジャーモード::  
* 辞書バッファのbuffer-file-name::  
@end menu

@node 個人辞書中の単語の削除, 個人辞書の保存動作, 辞書関連, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書中の単語の削除
@cindex 個人辞書エントリの削除[こしんししよのえんとりのさくしよ]
@cindex 誤登録[ことうろく]

誤まって個人辞書@footnote{@xref{辞書の形式, 個人辞書}.}に登録した単語の
削除は、削除したい単語を変換により求め、その単語が得られた時点で@samp{X}
を入力する。ミニバッファに確認のプロンプトが出るので、それに対し@kbd{y
e s}とタイプしたとき個人辞書の対応するエントリが削除され、カレントバッ
ファに削除のために一旦変換した単語も削除される。

@example
さいきてき /再起的/
@end example

@noindent
というエントリを誤って登録したという仮定で、その誤登録を削除する場合を例
にとって説明する。

@example
@kbd{S a i k i t e k i @key{SPC}}

@group
------ Buffer: foo ------
▼再起的
------ Buffer: foo ------
@end group

@samp{X}

@group
------------------ MiniBuffer ------------------
Really purge ``さいきてき /再起的/''?(yes or no)
------------------ MiniBuffer ------------------
@end group

@kbd{y e s @key{RET}}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group

@end example

@node 個人辞書の保存動作, 変換及び個人辞書に関する統計, 個人辞書中の単語の削除, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書の保存動作
@cindex 個人辞書[こしんししよ]
@cindex 個人辞書のオートセーブ[こしんししよのおーとせーふ]
@findex skk-kill-emacs-without-saving-jisyo
@findex skk-purge-from-jisyo
@findex skk-save-jisyo
@kindex C-x C-c
@vindex skk-backup-jisyo
@vindex skk-compare-jisyo-size-when-saving
@vindex skk-count-private-jisyo-candidates-exactly
@vindex skk-jisyo
@vindex skk-jisyo-save-count
@vindex skk-okuri-ari-min
@vindex skk-okuri-nasi-min

個人辞書の保存動作について述べる。個人辞書の保存を行なうのは、次の3通り
の場合がある。
@enumerate

@item
@kbd{C-x C-c}(または@kbd{M-x save-buffers-kill-emacs}) によりEmacsを終
了させようとした場合。

@item
@kbd{M-x skk-save-jisyo}とタイプするか、メニューバーにより
@samp{Save Jisyo}を選択した場合。

@item
@code{skk-jisyo-save-count}で指定された回数辞書のアップデートを行なった
場合にオートセーブ機能が働くとき。

@end enumerate
保存動作を分解すると、まずEmacsに読み込んだ個人辞書が更新されているかど
うかを調べ、更新されていたら保存動作に入る。Emacsの個人辞書バッファを一
時ファイルに保存して、そのサイズが現存の(セーブ前の)@code{skk-jisyo}よ
り小さくないかどうかをチェックする。一時ファイルのサイズが0である場合は
直ちに保存動作を中止するので、

@lisp
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end lisp

@noindent
でEmacsを終了させ@code{skk-jisyo}, @code{skk-backup-jisyo}をチェック
すべきである(@code{skk-jisyo}が既につぶれており、
@code{skk-backup-jisyo}につぶれる前の個人辞書が残っているかもしれない)。
一時ファイルのサイズが0でなく、かつ@code{skk-jisyo}のそれより小さいと
きはミニバッファにプロンプトを出して保存動作を継続するかどうかユーザーに
確認を求める。

@example
@group

--------------------------- Minibuffer -----------------------------
New ~/.skk-jisyo will be 11bytes smaller.  Save anyway?(yes or no)
--------------------------- Minibuffer -----------------------------

@end group
@end example

@noindent
ここで@kbd{n o @key{RET}}とタイプした場合は、そこで保存動作が中止され
るので@code{skk-jisyo}はセーブする前の状態のままである。@kbd{y e s
@key{RET}}とタイプした場合は@code{skk-backup-jisyo}を削除し、元の 
@code{skk-jisyo}を@code{skk-backup-jisyo}にリネームし、最後に一時ファ
イルに保存した新しい個人辞書を@code{skk-jisyo}にリネームする。

通常の使用の範囲では@kbd{M-x skk-purge-from-jisyo}した場合、あるいは個
人辞書をユーザーが意図的に編集した場合に、個人辞書が小さくなる可能性があ
るぐらいで、他の場合はバグ以外には考えにくい。

個人辞書の保存時のサイズ比較の機能は、主に開発者が新機能の追加したときの
バグで個人辞書を失なわないように自己防衛の目的で開発されたので、SKKが安
定している状態では不要な機能であるかもしれない。
@code{skk-compare-jisyo-size-when-saving}の値を@code{nil}にすると、一
時ファイルが0であるかどうかのみのチェックを行ない、セーブ前の 
@code{skk-jisyo}とのサイズ比較は行なわない。

個人辞書のオートセーブは@code{skk-jisyo-save-count}で指定された回数、
個人辞書のアップデートを行なった場合に行なわれる。個人辞書のアップデート
回数は確定回数でもある。同じ候補について確定した場合でもそれぞれ1回とカ
ウントされる。これは、個人辞書のミニマムポイント@footnote{送りあり変換
では@w{@code{skk-okuri-ari-min}+ 1}の位置、送りなし変換では
@w{@code{skk-okuri-nasi-min}+ 1}の位置がそれぞれミニマムポイントになる。}
に常に最後に変換を行なったエントリを移動させるために@footnote{厳密に言
えば、同じ見出し語、同じ候補について続けて2度以上確定した場合は、該当す
るエントリを移動させる必要はないのだが、現実の処理としては、移動させよう
とするエントリがミニマムポイントにあるかどうかのチェックを省いているので、
結果的には該当するエントリを一度削除してから同じ場所にそれを挿入している
こととなる。従い、アップデート回数としては、同じ見出し語、同じ候補につい
て続けて2度確定した場合は、それぞれ1回(合計2回)として数えている。同じ見
出し語、同じ候補について連続して変換する場合がそれほど頻度としては多くな
いこと、チェックをしようとした場合は、見出し語がミニマムポイントにあるか
どうかのチェックに加えて、移動しようとするエントリの候補群の並びが最後の
変換時のそれと変わらないかどうか---異なる場合は見出し語の位置は同じでも
候補群の順序を変更するために削除する必要がある---をチェックしなければな
らないこと、の2点から、個人辞書中の最後に変換した見出し語のエントリを削
除すべきかどうか、のチェックをしない方が全体的な効率が良いと考えている。}、
エントリ数、候補数が全く増えていなくとも、確定により個人辞書が更新されて
いるからである。@code{skk-jisyo-save-count}のディフォルト値は、50である。
@code{skk-jisyo-save-count}の値を@code{nil}にすることで、オートセーブ
を一切行なわないようにすることができる。

@node 変換及び個人辞書に関する統計, 辞書エントリの数えあげ, 個人辞書の保存動作, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 変換及び個人辞書に関する統計
@cindex skk-keep-record
@cindex skk-record-file
@vindex skk-count-private-jisyo-candidates-exactly

Emacsの終了時にSKKの変換及び個人辞書に関する統計が取られ、
@file{~/.skk-record}に保存される。保存される内容は下記のような形式であ
る。

@example
@group
Sun Jul 28 09:38:59 1996  登録:   4  確定:  285  確定率:  98%  語数:  3042
@end group
@end example

統計の保存のためのファイルは@code{skk-record-file}で指定できる。また、
統計を取るのをやめたければ@code{skk-keep-record}を@code{nil}にする。

なお、上記の「語数」の欄は1行を1語としてカウントしているので1つの見出し
語に対し複数のエントリを持っている場合、2つ目以降の候補を無視しているが 
@code{skk-count-private-jisyo-candidates-exactly}の値を@code{non-nil}
にすることで、その分余計に時間はかかるが、正確に語数をカウントすることが
できる。なお、この場合でも@samp{[}と@samp{]}に囲まれた送り仮名毎のブ
ロック内は数えない。

@node 辞書エントリの数えあげ, 辞書バッファの文字コードの設定, 変換及び個人辞書に関する統計, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書エントリの数えあげ
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@findex skk-count-jisyo-candidates
@kindex M-x skk-count-jisyo-candidates
@vindex skk-large-jisyo

@kbd{M-x skk-count-jisyo-entries}により辞書エントリを数えることができる。

@example
@group

@kbd{M-x skk-count-jisyo-entries}

--------------- MiniBuffer --------------
File: (default: /your/home/.skk-jisyo) ~/
--------------- MiniBuffer --------------
@end group
@group

@kbd{. s k k - j i s y o @key{RET}}

-------------- Echo Area --------------
Counting jisyo candidates... 100% done
-------------- Echo Area --------------
@end group

@group

------ Echo Area ------ 
3530 entries
------ Echo Area ------
@end group
@end example

@samp{[}と@samp{]}に囲まれた送り仮名毎のブロック内は数えない。

メニューバーが使用できる環境では、メニューバーを使ってこのコマンドを起動
することができる。
@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.

@node 辞書バッファの文字コードの設定, 辞書バッファのメジャーモード, 辞書エントリの数えあげ, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの文字コードの設定
@vindex skk-jisyo-code

@code{skk-jisyo-code}の値により辞書ファイルの漢字コードを設定するこ
とができる。@w{``euc''}, @w{``ujis''}, @w{``sjis''}, @w{``jis''}などの
文字列の他@w{@code{*euc-japan*}}, @w{@code{*sjis*}}, @w{@code{*junet*}}
などのシンボルを指定することもできる。

@code{skk-jisyo-code}の値をディフォ値である@code{nil}にしておくと、
SKK側で辞書字コードの設定に関する動作は行なわない@footnote{Emacs側の機
能に依存する。}。

@node 辞書バッファのメジャーモード, 辞書バッファのbuffer-file-name, 辞書バッファの文字コードの設定, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファのメジャーモード
@cindex @file{dabbrev.el}
@cindex @samp{ *SKK-JISYO.L*}
@cindex fundamental-mode
@findex skk-search-jisyo-file
@findex skk-search-kakutei-jisyo-file
@findex skk-search-server
@vindex SKK辞書
@vindex mode-name
@vindex skk-jisyo-mode
@vindex skk-large-jisyo
@cindex 辞書バッファのネーミング規則[ししよはつふあのねーみんくきそく]

各辞書を@code{skk-search-kakutei-jisyo-file}もしくは 
@code{skk-search-jisyo-file}によりEmacsのバッファに辞書を取り込んだとき
(あるいは@code{skk-search-server}により検索していたが、サーバーと接続
できなってバッファに取り込んだとき)は、辞書バッファの名前は、空白
+@samp{*}+辞書ファイル名(ディレクトリ抜き)+@samp{*}という規則に基づき付
けられる。例えば、@code{skk-large-jisyo}に代入されているファイル名が 
@w{@file{/usr/local/libexec/emacs/19.33/etc/SKK-JISYO.L}}であると、これ
に対する辞書バッファ名は、@w{@samp{ *SKK-JISYO.L*}}となる。このバッファ
のメジャーモードの実体は@code{fundamental-mode}であるが、メジャーモー
ド名に@code{skk-jisyo-mode}、@code{mode-name}に``SKK辞書''を代入してい
る。

これは、@file{dabbrev.el}において、カレントバッファと同じモードの他のバッ
ファをサーチしてdabbrevを行なうように設定することができるのだが、仮に辞
書バッファが@code{fundamental-mode}のままであるとすると、
@code{fundamental-mode}においてdabbrevを行なったときに、dabbrevのために
辞書バッファを検索することになるためである。動的な補完を行なうこのパッケー
ジの主旨から言って、辞書バッファを検索することは適当でないと考えるからで
ある。

@code{mode-name}に``SKK辞書''を代入していることについては必然性がないが、
メジャーモードを@code{skk-jisyo-mode}に変更しているのに 
@code{mode-name}が@code{fundamental-mode}のままでは、辞書バッファをの
ぞく好奇心旺盛なユーザーにとって混乱の種になるのではないかと考えたからで
ある。

@node 辞書バッファのbuffer-file-name,  , 辞書バッファのメジャーモード, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの@code{buffer-file-name}
@vindex buffer-file-name
@cindex save-some-buffers
@vindex skk-jisyo

個人辞書の保存は、前述した通り、一旦一時ファイルに保存し、そのサイズを古
い個人辞書のものと比較し、その後古い個人辞書をバックアップ辞書に退避して、
一時ファイルを個人辞書にリネームする、という複雑な一連の動作をしており、
単に@code{buffer-file-name}に依存して読み込んだファイルを保存するもの
ではない。@xref{個人辞書の保存動作}.

一方、@code{buffer-file-name}が@code{non-nil}になっている、特定のファ
イルと紐付きになっているバッファがあって、@kbd{M-x compile}など内部で 
@code{save-some-buffers}をコールしているコマンドを使ったとすると、一々
その未セーブのバッファをセーブするかどうかをユーザーに尋ねる機能がEmacs
には備えられている。仮に個人辞書のバッファが特定のファイルと紐付きになっ
ていると、@code{save-some-buffers}がコールされる度に個人辞書のバッファ
をセーブするかどうかを尋ねられてしまう。

SKKバージョン10では、@code{buffer-file-name}に@code{skk-jisyo}指定の
ファイルを代入していないので、個人辞書のバッファは、
@code{save-some-buffers}の対象でもなくなり、ユーザーがSKK以外のパッケー
ジから個人辞書バッファのセーブを尋ねられることはない。

この変更に従い、辞書バッファについては、特定のファイルとの関係がなくなっ
たので、辞書バッファを編集を行なうユーザーには注意すべき点がある。具体的
に言えば、辞書バッファに読み込まれた個人辞書以外の辞書
(@code{skk-large-jisyo}, @code{skk-aux-large-jisyo},
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo}) を、ユーザー
が辞書バッファに入り込んで編集した後、@kbd{C-x C-c}
(@code{save-buffers-kill-emacs})すると、Emacsからセーブするかどうかの確
認を求められることなく編集した辞書バッファが捨てられる(つまり辞書ファイ
ルは未編集のままの状態である)。どうしてもその編集した辞書バッファを保存
したければ、明示的に@kbd{C-x C-s}(@code{save-buffer}) か、もしくは 
@kbd{C-x C-w}(@code{write-file}) でファイル名指定してやれば保存すること
は可能だが、保存後そのバッファは、保存時に指定したファイルが新たに 
@code{buffer-file-name}に代入されるので、SKKの辞書バッファではなく、そ
のファイルそのものをオープンされている状態となる
(@pxref{辞書バッファのメジャーモード, , 辞書バッファのネーミング規則}。)。
従いその後、その辞書バッファを@code{skk-search-jisyo}で検索すると再び
読み込まれてしまう。再読み込みによる不都合は、メモリ消費以外には特にない。

@node デコレーション, VIP/VIPERとの併用, 辞書関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section デコレーション

@menu
* 仮名文字のローマ字プレフィックスのエコー::  
* 入力モードを示すモードラインの文字列の変更::  
* 入力モードを示すカーソル色に関する設定::  
* ▼モードにおける変換候補のハイライト表示::  
* エラーなどの日本語表示::      
@end menu

@node 仮名文字のローマ字プレフィックスのエコー, 入力モードを示すモードラインの文字列の変更, デコレーション, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 仮名文字のローマ字プレフィックスのエコー
@vindex skk-echo

@code{skk-echo}により仮名文字のローマ字プレフィックス
@footnote{@xref{辞書の形式, ローマ字プレフィックス}.}のエコーの有無を調
整できる。@code{skk-code}が@code{non-nil}であれば、仮名文字のローマ字
プレフィックスが入力時点で一旦カレントバッファに挿入され、続く母音の入力
により、かな文字に変換された時点でカレントバッファから消去される。

@example
@group
@kbd{t}

------ Buffer: foo ------
t
------ Buffer: foo ------

@end group
@group
@kbd{a}

------ Buffer: foo ------
た
------ Buffer: foo ------
@end group
@end example

@code{skk-echo}の値を@code{nil}にすると、仮名文字のローマ字プレフィッ
クスのエコーは行なわれなくなる。上記の例では@samp{t}がカレントバッファ
に挿入されることはなくなり、ローマ字1文字が完成する母音@samp{a}が入力
される直前にいきなり@samp{た}の文字が挿入される。

@node 入力モードを示すモードラインの文字列の変更, 入力モードを示すカーソル色に関する設定, 仮名文字のローマ字プレフィックスのエコー, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すモードラインの文字列の変更

下記の変数の値を変更することにより入力モードを示すモードラインの文字列を
変更することができる。

@vtable @code

@item skk-latin-mode-string
アスキーモードを示す文字列。ディフォルト値は、``--SKK:''。

@item skk-hirakana-mode-string
かなモードを示す文字列。ディフォルト値は、``--かな''。

@item skk-katakana-mode-string
カナモードを示す文字列。ディフォルト値は、``--カナ''。

@item skk-jisx0208-latin-mode-string
全英モードを示す文字列。ディフォルト値は、``--全英''。

@end vtable

@node 入力モードを示すカーソル色に関する設定, ▼モードにおける変換候補のハイライト表示, 入力モードを示すモードラインの文字列の変更, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すカーソル色に関する設定
@vindex minibuffer-setup-hook
@vindex skk-report-set-cursor-error

カラーディスプレイを使用し、カラー表示をサポートしているWindow System下
で対応するEmacsを使用している場合には、入力モードの変更に合わせてカーソ
ル色が変更される@footnote{@samp{-nw}オプションを指定してEmacsを起動した場
合は、この機能が使えない。}。この機能を使用したくない場合は、
@code{skk-use-color-cursor}の値を@code{nil}にする。

@code{skk-use-color-cursor}の値が@code{non-nil}の場合は、入力モードを
示すカーソル色は、下記の変数によって決定されるので、これらの変数の値を変
更することにより、カーソル色を変更することができる。

@vtable @code

@item skk-default-cursor-color
SKKモードがオフであることを示すカーソル色。カーソルのある該当フレームに
おけるディフォルトのカーソル色が代入される。

@item skk-hiragana-cursor-color
かなモードであることを示すカーソル色。ディフォルト値は、reverseVideoが
offのときは``coral4''onのときは``pink''。

@item skk-katakana-cursor-color
カタカナモードであることを示すカーソル色。ディフォルト値は、reverseVideo
がoffのときは``forestgreen''onのときは``green''。

@item skk-jisx0208-latin-cursor-color
全角英字モードを示すカーソル色。ディフォルト値は、``gold''。

@item skk-latin-cursor-color
アスキーモードを示すカーソル色。ディフォルト値は、reverseVideoがoffのと
きは``ivory4''onのときは``gray''。

@end vtable

カーソル色の変更の際、カラーマップ切れが起きた場合にはエラーメッセージを
表示し、ディフォルトのカーソル色を使う。このエラーメッセージの表示を止め
るには、@code{skk-report-set-cursor-error}の値を@code{nil}にする。

@node ▼モードにおける変換候補のハイライト表示, エラーなどの日本語表示, 入力モードを示すカーソル色に関する設定, デコレーション
@comment  node-name,  next,  previous,  up
@subsection ▼モードにおける変換候補のハイライト表示
@cindex @file{canna.el}
@cindex @file{rgb.txt}
@cindex Overlays
@cindex Extent
@cindex Text Properties
@cindex face
@findex hilit-lookup-face-create
@vindex canna:attribute-alist
@vindex skk-henkan-face
@vindex skk-use-face

@c XEmacs の extent について言及する。
@code{skk-use-face}が@code{non-nil}の場合、@code{skk-henkan-face}に
指定されたface属性をもって変換候補をハイライト表示する。このハイライト表
示はEmacsのOverlaysの機能を使っている@footnote{以前のバージョンではText
Propertiesを使用していたが、@file{egg.el}, @file{canna.el},
@file{wnn-egg.el}を参考にしてOverlaysを使用するように変更した。Overlays
は、テキストの一部ではないので、Overlaysのかかったテキストから文字を切り
出してもコピーの対象にならないし、アンドゥ時も無視されるので、変換された
候補の表示を一時的に変更するにはText Propertiesよりも好都合なためであ
る。}。@code{skk-henkan-face}のディフォルト値は、@code{highlight}であ
る。Emacs標準フェイスの@samp{default}, @samp{modeline}, @samp{region},
@samp{secondary-selection}, @samp{highlight}, @samp{underline},
@samp{bold}, @samp{italic}, @samp{bold-italic}@footnote{@samp{default}
以外のface上で変換を行なっている場合は、変換によりfaceを@samp{default}
に変更しても意味があろうが、通常はそのようなケースは稀であるので、
@samp{default}faceを利用することはまずないであろう。}の他、新たにfaceを
作り、利用することも可能。

新たな face を作り指定するには skk-make-face を利用して、

@example
@group
(setq skk-henkan-face (skk-make-face 'DimGray/PeachPuff1))
@end group
@end example

のようにするのが手軽。この例では、foreroundがDimGrayで、background
がPeachPuff1であるfaceを作り@footnote{この配色は私が日常使用しているお
気に入りのものである。少なくとも表現力乏しい私のノートパソコンの液晶では、
過激な配色でなくやわらかい色に見えるため、目の疲れも少ないので重宝してい
るが、他の方のディスプレイ上ではどんな感じに映るのであろうか。ひょっとし
て恐ろしく趣味の悪い色に見えているかと想像すると少し不安である。}、この
faceをもって変換候補の部分に色名を指定している。foregroundの色のみを変更
するためのfaceを作りたい場合は、

@lisp
(skk-make-face 'RosyBrown1)
@end lisp

@noindent
のようにする。foregroundとbackgroundの色指定だけでない凝ったfaceを作る場
合は、@code{skk-make-face}では対応できないので、Emacsの@file{hilit19.el}
の@code{hilit-lookup-face-create}などを利用する。色名については、X
Windowに添付されている@file{rgb.txt}を参照のこと。配色として参考になる
ものは、Mule-2.3標準添付である@file{canna.el}の 
@code{canna:attribute-alist}などがある。

@node エラーなどの日本語表示,  , ▼モードにおける変換候補のハイライト表示, デコレーション
@comment  node-name,  next,  previous,  up
@subsection エラーなどの日本語表示
@vindex skk-japanese-message-and-error

ディフォルトでは、エラー・メッセージ・ミニバッファプロンプトを英語表示す
る。@code{skk-japanese-message-and-error}の値を@code{non-nil}にするこ
とで、これを日本語で表示する。

@node VIP/VIPERとの併用, I-search関連, デコレーション, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section VIP/VIPERとの併用
@cindex VIP
@cindex VIPER
@cindex @file{vip.el}
@cindex @file{viper.el}
@vindex skk-use-viper

@code{skk-use-viper}の値を@code{non-nil}にすることで、VIPERと併
用することができる。@xref{Top, , VIPER, viper}. 

@c XXX VIP 3.7 について言及する。
VIPは、正式に対応しているバージョンは3.5のみである@footnote{Mule-2.3 に
標準添付のもの。ちなみにVIP3.5の作者は、SKKの原作者でもある佐藤雅彦
@w{<masahiko@@kuis.kyoto-u.ac.jp>}である。なおVIP 3.5は、その発展バージョ
ンがVIPERと名を変え現在もメンテナンスされている。Emacs 19, 20には、
VIP/VIPER のいずれもが標準添付されている。}。

@node I-search関連, skk-init-fileのバイトコンパイル, VIP/VIPERとの併用, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section I-search関連
@cindex I-search
@cindex Incremental search
@cindex @file{~/.skk}

@menu
* 起動時の入力モードの指定:: * 間に空白等を含む文字列の検索::
@end menu

@node 起動時の入力モードの指定, 間に空白等を含む文字列の検索, I-search関連, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 起動時の入力モードの指定
@vindex skk-isearch-start-mode
@vindex skk-isearch-use-previous-mode

@code{skk-isearch-start-mode}の値を指定することで、インクリメンタル・サー
チを起動した元のバッファの入力モードにかかわらず、インクリメンタル・サー
チの起動時の入力モードを指定することができる(但し、
@code{skk-isearch-use-previous-mode}の値は@code{nil}にしておく必要が
ある)。

@table @samp

@item ascii
アスキーモード

@item kana
@itemx hirakana
かなモード

@item eiji
全英モード

@end table

一方@code{skk-isearch-use-previous-mode}の値を@code{non-nil}にする
ことで、直前のインクリメンタル・サーチでの入力モードを用いるよう指定する
こともできる。

@node 間に空白等を含む文字列の検索,  , 起動時の入力モードの指定, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 間に空白等を含む文字列の検索
@cindex Incremental regexp search
@kindex M-C-r
@kindex M-C-s
@vindex skk-isearch-whitespace-regexp

@samp{検索}という文字列をインクリメンタル・サーチによりマッチさせたい場
合に、バッファが下記のような状態になっていることがある。

@example
@group
-------- Buffer: foo --------
この行末から始まる文字列を検
索して下さい。
-------- Buffer: foo --------
@end group
@end example

正規表現を用いたインクリメンタル・サーチ@footnote{ディフォルトのキーバ
インドは@kbd{M-C-s}と@kbd{M-C-r}。}を行なうことにより、上記のように文
字列の間に@samp{-}, タブ文字、改行文字、復帰文字、@samp{^L}等が含まれ
ていてもインクリメンタル・サーチによりマッチさせることができる。

変数@code{skk-isearch-whitespace-regexp}の値が、検索の対象となる文
字列の連続した日本語文字の間に挿入され、その結果が正規表現で表現され、検
索の対象となる。@code{skk-isearch-whitespace-regexp}のディフォルト値は

@example
"\\(\\s \\|[ \t\n\r\f]\\)*"
@end example

@noindent
である。@code{skk-isearch-whitespace-regexp}の値を

@example
"\\(\\s \\|[ \t\n\r\f<>|]\\)*"
@end example

@noindent
のようにすることで、文字列が@samp{>>}や@samp{|}等で引用されており、
文字間に引用文字を含む場合であってもマッチするようにすることができる。

@node skk-init-fileのバイトコンパイル, picture-modeとの併用, I-search関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section @code{skk-init-file}のバイトコンパイル
@vindex skk-byte-compile-init-file
@vindex skk-init-file

@code{skk-byte-compile-init-file}の値を@code{non-nil}にすることで、
@code{skk-mode}起動時に@code{skk-init-file}(ディフォルト値は、
@file{~/.skk}。) をチェックして、

@enumerate
@item
@code{skk-init-file}をバイトコンパイルしたファイルがないか、

@item
@code{skk-init-file}とそのバイトコンパイル済ファイルを比較して、前者の
方が新しいとき
@end enumerate

@noindent
に@code{skk-init-file}を自動的にバイトコンパイルする。@code{nil}であ
れば、@code{skk-init-file}とそのバイトコンパイル済みファイルを比較して 
@code{skk-init-file}の方が新しいときは、そのバイトコンパイル済ファイル
を(誤ってロードされることのないように)消す。

なお、@code{skk-byte-compile-init-file}は@code{skk-init-file}のロード
前に参照されるので、この変数の設定の変更を@code{skk-init-file}に書いて
も効果がない。@file{~/.emacs}などを利用すること。

@node picture-modeとの併用, サーバー関連, skk-init-fileのバイトコンパイル, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section @code{picture-mode}との併用
@cindex @key{BS}
@cindex move-to-column
@cindex move-to-column-force
@cindex @file{picture.el}
@cindex picture-mode

SKKモードを@code{picture-mode}において使用した場合は、下記の問題点があ
るが、これについては、@code{picture-mode}の側の問題であるので、現在のと
ころ、SKK側では対処していない。
@enumerate

@item
SKKモードで全角文字を入力した場合に、@key{BS}で全角文字が消せないこと。
現状では、backward 方向にある文字を消したい場合は、その文字にポイントを
合わせ、@kbd{C-c C-d}で一文字づつ消すしか方法はない。

@item
@code{picture-movement-up}や@code{picture-movement-down}により上下に全
角文字を挿入した場合にカラムがずれる場合があること。

@end enumerate

いずれも@code{move-to-column-force}関数の中で使用している 
@code{move-to-column}で全角文字を無視したカラム数が与えられたときにカー
ソル移動ができないことが原因である。

@node サーバー関連,  , picture-modeとの併用, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section サーバー関連

@menu
* skk-server.elのオプション::   
* うまく起動できないときは::    
@end menu

@c @node skkservの起動オプション, skk-server.elのオプション, サーバー関連, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection @file{skkserv}の起動オプション
@c
@c @file{skkserv}の起動時のオプションにより、ディフォルト辞書名の変更、ディ
@c バッグ・モードの指定などができる。オプションの指定方法は下記の通り。
@c
@c @example
@c skkserv [-d] [-p NNNN] [JISHO]
@c @end example
@c
@c また、各オプションの意味はそれぞれ下記の通り。
@c
@c @table @var
@c
@c @item -d
@c ディバッグ・モード。
@c
@c @item -p NNNN
@c 通信用のポート番号として@var{NNNN}を使う。
@c
@c @item JISHO
@c @var{JISHO}を辞書として利用する。
@c
@c @end table
@c
@c オプションなしで起動すると、通常モード(ディバッグ・モードでない)で、サー
@c バのコンパイル時に指定した辞書とポートを利用する。@file{skkserv}は、サー
@c バとなるべき子プロセスを作った後、直ちに終了する。エラーがあっても何のメッ
@c セージも出さない。
@c
@c ディバッグ・モードで走らせると、@file{skkserv}はそのままforegroundで走
@c り、メッセージを出力する。キーボードから割りこみをかけることもできる。
@c
@c @file{skkserv}の起動はスーパーユーザが行う必要はない。
@c

@node skk-server.elのオプション, うまく起動できないときは, サーバー関連, サーバー関連
@comment  node-name,  next,  previous,  up
@subsection @file{skk-server.el}のオプション

@vtable @code

@c @item skk-server-debug
@c @code{non-nil}であれば、辞書サーバープログラムをディバッグモードで起動
@c する。ディバッグ・モードで@file{skkserv}を走らせると、そのまま
@c foregroundで走り、メッセージを出力する。キーボードから割りこみをかけるこ
@c ともできる。

@item skk-servers-list
辞書サーバー毎の情報リスト。複数のマシーンで動いているサーバにアクセスで
きる場合には、以下のように、リストの各要素に順にホスト名、フルパスでのサー
バー名、サーバーに渡す辞書名、サーバーが使用するポート番号を書き、設定を
することもできる。下記に例を示す。
@lisp
@group

(setq skk-servers-list
      '(("host1 "/your/path/to/skkserv" nil nil)
        ("host2 "/your/path/to/skkserv" nil nil)))

@end group
@end lisp

@noindent
この場合最初に指定したサーバにアクセスできなくなると、自動的に順次リスト
にある残りのサーバにアクセスするようになる。なおサーバーに渡す辞書および
サーバーが使用するポート番号で、サーバーをコンパイル時の値を使用する場合
は@code{nil}を指定する。

@item skk-report-server-response
@code{non-nil}であれば、変換時サーバーの送出する文字を受け取るまでに 
@code{accept-process-output}を何回実行したかを報告する。

@item skk-server-remote-shell-program
リモートシェルのプログラム名。ディフォルト値は下記の通り。
@lisp
@group

(or (getenv "REMOTESHELL")
    (and (boundp 'remote-shell-program) remote-shell-program)
    (cond
     ((eq system-type 'berkeley-unix)
      (if (file-exists-p "/usr/ucb/rsh") "/usr/ucb/rsh" "/usr/bin/rsh"))
     ((eq system-type 'usg-unix-v)
      (if (file-exists-p "/usr/ucb/remsh") "/usr/ucb/remsh" "/bin/rsh"))
     ((eq system-type 'hpux) "/usr/bin/remsh")
     ((eq system-type 'EWS-UX/V) "/usr/ucb/remsh")
     ((eq system-type 'pcux) "/usr/bin/rcmd")
     (t "rsh")))

@end group
@end lisp

@end vtable

@node うまく起動できないときは,  , skk-server.elのオプション, サーバー関連
@comment  node-name,  next,  previous,  up
@subsection うまく起動できないときは

@file{skkserv}とうまく接続できないときは、

@example
% ps ax | grep skkserv
@end example

@noindent
などとして@file{skkserv}が走っていることを確かめた上で、Emacsの 
@code{lisp-interaction-mode}で以下のフォームを順次評価する。

@lisp
@r{;; network streamをopen。``foobar''の個所には@file{skkserv}を動かし}
@r{;; ているホスト名を書くこと。}
(open-network-stream "skkservd-debug" (current-buffer) "foobar" "skkserv")
@r{;; 初期設定}
(let ((code (cdr (assoc "euc" skk-coding-system-alist)))
      (proc (get-process "skkservd-debug")))
  (cond ((eq skk-emacs-type 'xemacs)
	 (set-process-input-coding-system proc code)
	 (set-process-output-coding-system proc code))
	((memq skk-emacs-type '(mule4 mule3 mule2))
	 (set-process-coding-system proc code code))))
@r{;; 変換すべき文字列として `かんじ' を送信する。}
(process-send-string "skkservd-debug" "1かんじ ")
@r{;; 成功すると、カレントバッファに、}
@r{;; 1/漢字/幹事/完治/完爾/寛治/感じ/}
@r{;; などとSKK-JISYO.Lに含まれる候補が挿入される。}
@r{;; 先頭の数字 `1' は `skkserv' が候補の検索に成功したことを示す。}
@r{;;serverをdisconnectする。}
(process-send-string "skkservd-debug" "0")
@end lisp

@c @node サーバー起動後の辞書の再読み込み, 限界・改良の余地, うまく起動できないときは, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection サーバー起動後の辞書の再読み込み
@c
@c @file{skkserv}起動後に@file{skkserv}の参照している辞書の内容を変更し
@c たい場合、単純に@file{skkserv}のプロセスをkillしてしまうとその時に同じ 
@c @file{skkserv}を利用してskkを使っているすべてのユーザに悪影響がある。
@c
@c そこで@file{skkserv}を走らせたまま辞書を再読みこみする方法を付加した。
@c なお、辞書のファイル名を変更するときはできない。つまり、コンパイル時また
@c は起動時に指定されたファイル名の位置に、新しい辞書を上書きする必要がある。
@c
@c @enumerate
@c
@c @item
@c 新しい辞書を@file{skkserv}の所定の場所に置く(@file{cp}の各引数は適当
@c な文字列に直す)。
@c
@c @example
@c % cp NEW-JISHO /usr/local/mule/etc/SKK-JISYO.L 
@c @end example
@c
@c @item
@c @file{skkserv}のプロセス番号を求める。
@c
@c @example
@c % ps ax | grep skkserv
@c @end example
@c
@c @item
@c @file{skkserv}に辞書再読み込みを指定するシグナルを送る。
@c
@c @example
@c % kill -INT NNNN
@c @end example
@c
@c @noindent
@c ここで@var{NNNN}は上記で求めた@file{skkserv}のプロセス番号とする。な
@c お、signalを送ることができるのはスーパーユーザのみ(個人で@file{skkserv}
@c を起動した場合は、スーパーユーザまたは起動した人のみ)である。
@c
@c @end enumerate
@c
@c
@c なお、下記の点に注意すること。
@c @itemize @bullet
@c @item
@c 上記手順で1と3の間(辞書ファイルの中身が書きかわったのに、まだ 
@c @file{skkserv}がそのことを知らないとき)では、@file{skkserv}は変な動作
@c をすることがある。特に、辞書のサイズを小さくしたときには死んでしまうかも
@c しれない。
@c
@c @item
@c 動作は、SparcStation-2/SunOS 4.1.1上でのみテストした。signalの取り扱いが
@c 異なるマシン上では動作しない可能性がある。
@c
@c @end itemize
@c
@c @node 限界・改良の余地,  , サーバー起動後の辞書の再読み込み, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection 限界・改良の余地
@c
@c @file{skkserv}がディバッグ・モードでないときに合法的に殺す手段はない。
@c killする。
@c
@c 一つの計算機の上で使用できる同じ番号のTCPソケットは、一つしか存在できな
@c い。従い標準ポート番号を使う@file{skkserv}も一つしか動かない。ディバッ
@c グやテストの際に@file{skkserv}を殺してすぐに起動すると、ポートが使われて
@c いる、という趣旨のエラーが起きる。この場合は、少し待ってから再度起動する。
@c
@c 一つのサーバが受けつけられるクライアントの数の上限は、関数 
@c @code{getdtablesize}により決まる。もし上限を越えた数のクライアントがコ
@c ネクト要求をしてきた時はサーバは異常終了する。
@c
@c 本来のSKK辞書には, 見出し語の長さの上限はないが、@file{skkserv}では 512
@c バイトに限っている(@file{skkserv.h}の@var{BUFSIZE}の値)。なお、変換文
@c 字列の長さに制限はない。
@c
@c @c バイナリサーチパッチを採用しているなら削除する。
@c 辞書検索は、読みの第1文字目による場合分けを行った後は、線型探索を行なっ
@c ている。現在の状況ではこれで十分であるが、場合によってはより高速な探索方
@c 法を検討する必要があるかもしれない。
@c

@node  辞書ユーティリティプログラム, 拡張アイディア, 便利な応用機能とユーザーオプション, Top
@comment  node-name,  next,  previous,  up
@chapter 辞書ユーティリティプログラム

SKK辞書に関するユーティリティプログラムには、Perl, C の各言語により書か
れたものがある。

@menu
* Cによるユーティリティプログラム::  
* Perlによるユーティリティプログラム::  
@end menu

@node Cによるユーティリティプログラム, Perlによるユーティリティプログラム, 辞書ユーティリティプログラム, 辞書ユーティリティプログラム
@comment  node-name,  next,  previous,  up
@section Cによるユーティリティプログラム

@c XXX別ディストリビューション
Cで書かれたユーティリティプログラムはjisyo-toolsと総称され、SKKの
distributionではディレクトリ@file{jisyo-tools}の下にある。

@menu
* プログラム作成方法::          
* skkdic-expr::                 
* skkdic-sort::                 
* skkdic-count::                
@end menu

@node プログラム作成方法, skkdic-expr, Cによるユーティリティプログラム, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection プログラム作成方法

@c XXX configure
@file{Makefile}を見て、必要があれば中の@var{CC}と@var{CFLAGS}の内容
を変更してから@code{make}を実行する。

なお@code{skkdic-expr}では作業用のファイルとして辞書の2倍程度の大きさ
のものを作成する。このファイルが作成されるディレクトリは実行時に指定でき
るが、ディフォルトとして@file{/tmp}を指定してる。もしも明らかに不足す
る場合には、

@example
-DTMPDIR=\".\"
@end example

@noindent
を@var{CFLAGS}に追加すると、@file{/tmp}が溢れるといった災害を防
ぐことができる。

@node skkdic-expr, skkdic-sort, プログラム作成方法, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-expr}
@cindex @file{skkdic-expr}

複数のSKK辞書をマージしたり、他の辞書と同じ内容を引くのに使う。例えば、
次のようにして使う。

@example
% skkdic-expr @var{jisyo1}+@var{jisyo2}-@var{jisyo3}>@var{result}
@end example

@noindent
上記の例では、@var{jisyo1}と@var{jisyo2}にある@var{jisyo1}と重複し
ない候補を加え、その後、@var{jisyo3}と同じ候補があれば削除する。

また、次のオプションが使用できる。引数の辞書の直前に指定する。

@table @var

@item -d
作業用ディレクトリ。

@item -o
出力ファイル。

@end table

その他の使用例をあげる。
@enumerate

@item
複数の辞書を@code{cat}でつないだものを整理する。

@example
% skkdic-expr @var{olddict1}>@var{newdict1}
@end example

@noindent
このように使用すると、重複する候補を削除したり、同じ読みが別々の行に複数
存在していても一行のエントリにまとめる。例えば、

@example
じしょ /辞書/
じしょ /璽書/
じしょ /字書/
@end example

@noindent
のような辞書を

@example
じしょ /辞書/璽書/字書/
@end example

@noindent
と、一行にまとめることができる。候補の配列(候補が出力される際の優先順位)
は上から順になる。
@c この行の意味が良く分りません。-- 中島
@c また、同じ読みの並び順を変更するのにも使える。

@item
個人辞書にある分だけを取り出す。

@example
% skkdic-expr ~/.skk-jisyo - SKK-JISYO.L >@var{private}
@end example

@noindent
この差分を将来のSKK辞書に反映させる方法については@ref{謝辞とお願い}を
参照のこと。

@item
2つの辞書の共通部分を取り出す。

@example
@group
% skkdic-expr @var{jisyo-a}-@var{jisyo-b}>@var{jisyo-tmp}
% skkdic-expr @var{jisyo-a}-@var{jisyo-tmp}>@var{jisyo-common}
@end group
@end example

@end enumerate


@node skkdic-sort, skkdic-count, skkdic-expr, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-sort}
@cindex @file{skkdic-sort}

ソートされていない辞書を通常のSKK辞書の形式にソートし、
@w{@samp{;; okuri-ari entries.}}と@w{@samp{;; okuri-nasi entries.}}を
適切な位置に挿入する。入力は標準入力のみ、出力は標準出力のみが指定できる。
例をあげる。

@example
% skkdic-expr @var{jisyo-a}+@var{jisyo-b}| skkdic-sort >@var{newdict}
@end example

@noindent
一時的に使用するswapを小さくするためにあえて@file{skk-jisyo-expr}とは
別のプログラムとしてある。

@node skkdic-count,  , skkdic-sort, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-count}
@cindex @file{skkdic-count}

SKK辞書の中の候補の数を数える。@samp{[}と@samp{]}で囲まれた送り仮名毎
のブロックも一つの候補として数える。

@node Perlによるユーティリティプログラム,  , Cによるユーティリティプログラム, 辞書ユーティリティプログラム
@comment  node-name,  next,  previous,  up
@section Perlによるユーティリティプログラム
@cindex @file{adddummy}
@cindex @file{codeconv.pl}
@cindex @file{jis2sjis}
@cindex @file{jis2ujis}
@cindex @file{kana2roma}
@cindex @file{kana2roma.pl}
@cindex @file{list2skk}
@cindex @file{pubdic2list}
@cindex @file{removedummy}
@cindex @file{roma2kana}
@cindex @file{roma2kana.pl}
@cindex @file{sjis2jis}
@cindex @file{skk2list}
@cindex @file{skkconv}
@cindex @file{sub}
@cindex @file{ujis2jis}

@c XXX distributionはjisyo-toolsとmergeしてしまおうか...。
Perlで書かれたユーティリティプログラムはskktoolsと総称され、SKKの
distributionではディレクトリ@file{contrib/skktools}の下にある。

skktoolsは、辞書をマージしたり、pubdic辞書をSKK辞書の形式に変換したりす
るためのツール群である。SKK辞書は読みに対応する複数の漢字が@samp{/}で
区切られた構造をしているが、このツールでは読みと漢字が1対1に対応した形式
(これを@b{「リスト形式」}と呼ぶ)のファイルを中間形式として取り扱う。

skktoolsには以下のプログラムがある。

@table @file

@item skk2list
SKK辞書をリスト形式に変換する。

@item pubdic2list
pubdic辞書の名詞エントリをリスト形式に変換する。

@item list2skk
リスト形式をSKK辞書に変換する。

@item adddummy
SKK辞書ソートのためにダミー文字を加える。

@item removedummy
加えたダミー辞書を取り除く。

@item sub
二つのリスト形式の辞書の差分を計算する。

@item skkconv
漢字検索コマンド。

@end table

例えば、既存のSKK辞書とpubdic辞書をマージして新しいSKK辞書を作成するには
次のように行なう。

@example
@group
% (skk2list skk-jisyo ; pubdic2list kihon.u) \@r{; リスト形式を連結}
      | adddummy \@r{; ダミー文字追加}
      | sort -u \@r{; ソート}
      | removedummy \@r{; ダミー文字削除}
      | list2skk \@r{; SKK辞書に変換}
      > skk-jisyo.new
@end group
@end example

これらのツールではEUCの辞書のみ取り扱い可能である。それ以外の文字コード
の辞書を使うときは後述の@file{jis2ujis}などのコマンドを加える必要がある。

二つのリスト形式の辞書の差分を計算するには、

@example
% sub 旧リスト 新リスト
@end example

@noindent
とする。比較する二つのファイルはあらかじめソートされていなければならない。

@file{skkconv}はSKKサーバを使用してコマンドラインでかな漢字変換するため
のコマンドである。例えば@samp{かんじ}という読みをもつ漢字を以下のように
検索できる。

@example
@group
% skkconv kanji
漢字
幹事
感じ
......
%
@end group
@end example

この他に以下のPerlライブラリとコマンドがある。

@table @file

@item codeconv.pl
JIS, EUC, SJIS相互変換ライブラリ。

@item roma2kana.pl
ローマ字@expansion{}平仮名変換ライブラリ。

@item kana2roma.pl
平仮名@expansion{}ローマ字変換ライブラリ。

@item jis2sjis
JIS @expansion{}SJIS変換コマンド。

@item sjis2jis
SJIS @expansion{}JIS変換コマンド。

@item jis2ujis
JIS @expansion{}EUC変換コマンド。

@item ujis2jis
EUC @expansion{}JIS変換コマンド。

@item roma2kana
ローマ字@expansion{}かな(EUC)変換コマンド。

@item kana2roma
かな(EUC)@expansion{}ローマ字変換コマンド。

@end table

@node 拡張アイディア, SKKメーリングリスト, 辞書ユーティリティプログラム, Top
@comment  node-name,  next,  previous,  up
@chapter 拡張アイディア

将来のバージョンに託された拡張アイディアを、実現可能かどうかは別にして、
順不同で述べる。これ以外にも要望、拡張の具体的アイディアがあれば、
開発者用メーリングリストに投稿するなどの方法で、開発者までご連絡いただき
たい。@xref{開発者用メーリングリスト}.

@itemize @bullet

@item
辞書の個々の見出し語、候補に属性を持たせて、例えば、下記のような機能をイ
ンプリメントする。

@enumerate
@item
その属性の内容により、変換の際に候補の絞り込み条件を指定できるようにする。
また、絞り込み条件はユーザーの任意に変更できるようにする。一例をあげれば、
サ変動詞になり得る名詞に適当な属性を持たせ、@samp{〜する}という送り仮名
がタイプされた場合には、そのサ変動詞属性を持った名詞のみを候補として出力
する、など活用の幅は非常に広い。サ変動詞の問題については、
@ref{辞書登録モード}も参照のこと。

@item
候補に最終の変換時刻などを属性として持たせ、辞書のメンテナンスに利用する
(一定期間アクセスのない候補を個人辞書から削除するなど)。

@item
候補に関する意味を属性として持たせ、意味を調べるような拡張変換を行なえる
ようにする。

@end enumerate

@c XXX 今まで実験してきたことを記述する。
@noindent
言うは易しだが、色々な未解決の問題がある。多数の見出し語や候補に属性を持
たせて、通常の変換効率をできる限り落さないで、かつ効率良く属性のメンテナ
ンスを行なう方法を模索することがまず大変。Emacsのバッファに読み込む辞書
とサーバー経由でアクセスしている辞書とがあることも検討事項。Emacs側の機
能で対応した場合にサーバー経由の辞書属性をどうやって得るか、またはその逆
が課題である。コーディング抜きであってもアイディアをいただけたら幸いであ
る。

@c こりゃ無理か？
@c @item
@c @kbd{C-x C-j}, @kbd{C-x j}など、SKKモードの起動に使用されるキーに元々割
@c り付けられているEmacsのオリジナルのコマンドの自動退避。意外と難しい？ 
@c @xref{.emacsの設定}.

@item
CannaやWnnのサーバーと接続して検索が可能になるようにする@footnote{最新のEggでは、
Emacs Lispベースでサーバーと接続することが試みられているそうだ。}。

@item
いかなるユーザーオプション変数をバッファローカル化しても動作するようにす
ること。辞書バッファで参照されるユーザーオプションを、変換を行なっていた
バッファの指定値から受け渡しして辞書バッファで参照するなどの配慮が必要か。
@xref{送り仮名の厳密なマッチ}.

@item
送り仮名の厳密なマッチなしの送り仮名の自動処理を行なうオプションを作るこ
と。現状の送り仮名の自動処理では、送り仮名のプレフィックスがマッチするだ
けでは候補として出力せず、更に送り仮名全体が厳密にマッチするかどうかを
チェックしている。これは候補の絞り込みのためには有効に作用するが、個人辞
書の内容が貧弱な場合は、逆にこれがあだとなってすぐに辞書登録モードに入っ
てしまう。オプション設定することにより、いずれの場合にも対応できるように
する。@xref{送り仮名の自動処理}.@xref{送り仮名の厳密なマッチ}.

@c @item
@c @code{query-replace}などのコマンドで、SKKの入力モードを認識するようなプ
@c ロンプトを出す。こりゃ無理か？

@item
部首変換プログラムと辞書を作ること。

@item
辞書毎にコーディングシステムを別々に設定できるようにすること。

@end itemize

@node SKKメーリングリスト, SKKの入手方法, 拡張アイディア, Top
@comment  node-name,  next,  previous,  up
@chapter SKKメーリングリスト

@menu
* ユーザーメーリングリスト::    
* 開発者用メーリングリスト::    
@end menu

@node ユーザーメーリングリスト, 開発者用メーリングリスト, SKKメーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section ユーザーメーリングリスト
@cindex メーリングリスト[めーりんくりすと]

SKKに関する意見交換の場としてSKKメーリングリストが開設されている。これま
でメーリングリストで話題になったこととしては、SKKの虫の報告/修正、
質問/回答、SKK改良のための提案等がある。また、最新のSKKもメイリングリス
トを通して配布し、参加者の協力を得て、テスト、改良を重ねている。

@table @asis

@item メーリングリストへ参加したいとき。
@samp{skk-join@@kuis.kyoto-u.ac.jp}へメールを送れば、自動的に発信者のメー
ルアドレス(@samp{From:}のアドレス)が登録される。

@item メーリングリストへの記事の投稿を行なうとき。
@samp{skk@@kuis.kyoto-u.ac.jp}へ送れば自動的に全ての登録者に送付される。

@item メーリングリストに登録したアドレスを変更したいとき。
新しいメールアドレスから@samp{skk-change@@kuis.kyoto-u.ac.jp}宛に、本
文の1行目に下記の書式で旧アドレスを書いたメールを送付する。
@example
@samp{Old:@var{your-old-address}}
@end example

@item メーリングリストから抜けたいとき。
@samp{skk-leave@@kuis.kyoto-u.ac.jp}へメールを送る。

@end table

@samp{skk-source@@kuis.kyoto-u.ac.jp}宛にメールを送付することで、過去の
SKKメーリングリストへの投稿記事を入手することができる。入手したい記事の
@samp{Mailinglist-ID:}に従い、下記の要領で@samp{Subject:}を指定し、メー
ルを送付することで、指定された内容のメールが返送される。

@table @asis

@item @samp{Mailinglist-ID:}が134の記事を入手する場合。
@samp{Subject: 134}

@item @samp{Mailinglist-ID:}が100番から199番の記事を全部入手する場合。
@samp{Subject: ml-contents-01}

@end table

@noindent
ただし、0〜99番の場合は@samp{ml-contents-00}と指定する。なお、
Mailinglist-ID:が欠番の部分もある。

@node 開発者用メーリングリスト,  , ユーザーメーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section 開発者用メーリングリスト
@cindex SKKの開発[SKKのかいはつ]
@cindex メーリングリスト[めーりんくりすと]

SKKの開発に関する情報交換、及びテスト版の配布などを行う場としてSKK開発者
用メーリングリストが開設されている。

@table @asis

@item メーリングリストへ参加したいとき。
@samp{skk-develop-join@@kuis.kyoto-u.ac.jp}へメールを送れば、自動的に発
信者のメールアドレスが登録される。

@item メーリングリストへの記事の投稿を行なうとき。
@samp{skk-develop@@kuis.kyoto-u.ac.jp}へ送れば自動的に全ての登録者に送
付される。

@item メーリングリストに登録したアドレスを変更したいとき。
新しいメールアドレスから@samp{skk-develop-change@@kuis.kyoto-u.ac.jp}宛に、本
文の1行目に下記の書式で旧アドレスを書いたメールを送付する。
@example
@samp{Old:@var{your-old-address}}
@end example

@item メーリングリストから抜けたいとき。
@samp{skk-develop-leave@@kuis.kyoto-u.ac.jp}へメールを送る。

@end table

@node SKKの入手方法, SKK関連ソフトウェア, SKKメーリングリスト, Top
@comment  node-name,  next,  previous,  up
@chapter SKKの入手方法

@menu
* メールによる入手方法::        
* Anonymous Ftpによる入手方法::  
* WWWを利用して入手する方法::   
* その他の入手方法::            
@end menu

@node メールによる入手方法, Anonymous Ftpによる入手方法, SKKの入手方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section メールによる入手方法
@cindex SKKの入手方法[SKKのにゆうしゆほうほう]

@samp{skk-source@@kuis.kyoto-u.ac.jp}宛にメールを送付することで、SKKの
ソースをメールを入手することができる。下記の要領で@samp{Subject:}を指
定し、メールを送付することで、指定された内容のメールが返送される。

@table @asis

@item @file{skk.el}が欲しい場合。
@samp{Subject: skk.el}

@item 入手可能なファイルのインデクスが欲しい場合。
@samp{Subject: index}@file{index}にはファイルサイズと最終更新日が入っ
ている。

@item ファイルのバージョン等を知りたい場合。
@samp{Subject: VERSIONS}

@item SKKの最新版全体を入手したい場合。
@samp{Subject: all}こうするとSKKのパッケージがいくつかのメールに分割さ
れて送られてくる。

@item 一度に多数のメールを受け取ることができない場合
@enumerate
@item
@samp{Subject: all-1}により、まずpart1を入手し、全体の個数を確認する。

@item
次に@samp{Subject: all-2-10}のようにして受信可能な範囲で全体の一部(上
の場合はpart2からpart10)を入手する。

@item
メールの取りこぼしがあったときは、例えば、@samp{Subject: all-22,31}とす
るとpart22とpart31が入手できる。

@end enumerate
@end table

@node Anonymous Ftpによる入手方法, WWWを利用して入手する方法, メールによる入手方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section Anonymous Ftpによる入手方法
@cindex anonymous ftp
@cindex SKKの入手方法[SKKのにゆうしゆほうほう]

下記よりanonymous ftpによりSKKを入手することができる。

@c XXX center 配置
@samp{ftp://skk.kuis.kyoto-u.ac.jp/pub/skk}

@node WWWを利用して入手する方法, その他の入手方法, Anonymous Ftpによる入手方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section WWWを利用して入手する方法
@cindex Home Page
@cindex WWW
@cindex ホームページ[ほーむへーし]
@cindex SKKの入手方法[SKKのにゆうしゆほうほう]

SKKのホームページを以下の場所に開設している。

@table @asis

@item 日本語版URL
@samp{http://skk.kuis.kyoto-u.ac.jp/skk/index.html}
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item 英語版URL
@samp{http://skk.kuis.kyoto-u.ac.jp/skk/index-e.html}

@end table

WWWブラウザを利用して、ホームページにアクセスすれば、ホームページからの
リンクをたどることによって、ftpサーバ@samp{skk.kuis.kyoto-u.ac.jp}にア
クセスすることができる。

@node その他の入手方法,  , WWWを利用して入手する方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section その他の入手方法
@cindex JUNET
@cindex SKKの入手方法[SKKのにゆうしゆほうほう]
@cindex fj.sources

SKKは1988年4月に第1版をJUNETに投稿して以来、毎年4月にJUNETのニュースグルー
プfj.sourcesに新しいバージョンを投稿している。この方式もひきつづき続けて
いきたいと考えている。

@node SKK関連ソフトウェア, 謝辞とお願い, SKKの入手方法, Top
@comment  node-name,  next,  previous,  up
@chapter SKK関連ソフトウェア
@cindex @file{kakasi}
@c @cindex @file{pskkserv}
@cindex @file{skkfep}
@cindex @file{skkinput}

@menu
* dbskkd-cdb ::                 
* skkfep内蔵jvim::              
* KAKASI::                      逆引プログラム
* skkfep::                      SKKクローンFEP
* SKK on Jed::                  Jedで動くSKK
* skkinput::                    X上のSKK入力プログラム
* SKKIME::                      skkinput for Microsoft Windows
* SKK95::                       Windowsで動くSKK like IME
@end menu

@node dbskkd-cdb , skkfep内蔵jvim, SKK関連ソフトウェア, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section dbskkd-cdb 
@cindex dbskkd-cdb 
@cindex cdb

このセクションは、dbskkd-cdbの開発者である力武健次氏により書かれた。

@table @asis

@item 正式名称
dbskkd-cdb

@item どのようなソフトウェアか
SKK用のシステム辞書サーバ。

@item 使用するために要求される環境
Linux, FreeBSD, Solaris 2.6上での動作を確認している。現状では使用するSKK
システム辞書と比べ、cdb形式の辞書のサイズは2倍弱になる。セキュリティ向上
のため、inetdからtcp_wrapperなどを経由して起動することを前提とする。
Daniel J. Bernstein氏の開発した同様のソフトウェアucspi-tcpの使用を推奨す
る。高速化のため、Daniel J. Bernstein氏の開発した固定データベース用ライ
ブラリcdbを使っているのでcdbのインストールが必要。

@item 最新バージョン、release の日付
1.00, 1999年6月16日

@item 開発者
力武 健次 @w{<kenji.rikitake@@acm.org>}

@item 配布条件
GPLに準拠。

@item 入手方法
一次配布先は@w{@samp{http://www.k2r.org/kenji/software/jp-dbskkd.html}}
から参照できる。

@item bug report,質問のためのアドレス
@w{@samp{kenji-dbskkd-cdb@@k2r.org}}

@item その他
さまざまなUNIX系OSの上での動作レポートを希望しています。
@end table

@node skkfep内蔵jvim, KAKASI, dbskkd-cdb , SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep内蔵jvim
@cindex skkfep
@cindex jvim

このセクションは、skkfep内蔵jvimの開発者である木原英人氏により書かれた。
@table @asis

@item 正式名称
skkfep内蔵jvim

@item どのようなソフトウェアか
jvim(viクローンのエディタvimを日本語化したもの)にskkfepを組み込んだもの
です。vi系のエディタでSKK風の日本語入力ができます。

@item 使用するために要求される環境
UNIX, Windows 95/98/NT, DOS

@item 最新バージョン、release の日付
jvim, skkfep, ariそれぞれに対するパッチとして提供しています。
@w{jvim3.0-j1.7-skk1.2.8.patch} 1999/8/30,
@w{skkfep0.86c-kh1.2.6.patch}, 1999/9/28,
@w{ari1.00a-kh1.2.1.patch} 1999/1/29

@item 開発者
木原 英人

@item 配布条件
skkfep, jvim, ariそれぞれに対するパッチとして提供しているので、それぞれ
の配布条件に従います。

@item 入手方法
@w{@samp{http://hiroshima.cool.ne.jp/deton/jvim-skk/}}

@item bug report,質問のためのアドレス
@w{@samp{deton@@m1.interq.or.jp}}

@end table

@node KAKASI, skkfep, skkfep内蔵jvim, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section KAKASI
@cindex Kanji Kana Simple Inverter

KAKASIとは、高橋裕信氏@w{<takahasi@@tiny.or.jp>}による「漢字かなまじり文
をひらがな文やローマ字文に変換することを目的として作成したプログラムと辞
書の総称」である。KAKASIは、Kanji Kana Simple Inverterにちなんで、また
SKKの逆言葉として名付けられた。KAKASI は、SKKのcontribution softwareに含
まれている。

@node skkfep, SKK on Jed, KAKASI, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep
@cindex @file{skkfep}

skkfepは、伊藤彰則、渡辺雅俊、金子裕の各氏による、SKKと似た入力方式の漢
字入力フロントエンドプロセッサである。

現在サポートされているOSは、下記の通り。
@display
SunOS 4.x, AIX3.x, Linux, 386BSD, AIX/ESA, DOMAIN-IX SR9.x, HP-UX 8.x,
SEIUX 3.x, EWS-UX/V Rel4.0, NEWS-OS 4.x, NEWS-OS 3.3
@end display

@c @node pskkserv, SKK on Jed, skkfep, SKK関連ソフトウェア
@c @comment  node-name,  next,  previous,  up
@c @section pskkserv
@c @cindex DBM
@c @cindex Perl
@c @cindex @file{makedbmdic}
@c @cindex @file{pskkserv}
@c @vindex exec-directory
@c
@c pskkservは佐藤正章氏@w{<msatoh@@mrit.mei.co.jp>}による@file{skkserv}
@c 代替ソフトである。Perlスクリプトとしてインプリメントされており、サーバー
@c プログラムである@file{pskkserv}と、辞書のDBM化の際使用する 
@c @file{makedbmdic}がある。
@c
@c @file{pskkserv}は、SKK辞書をDBM化し、Perlの連想配列を用いて検索を行なう。
@c Perlの連想配列のインデクスキーは、内部的にハッシュテーブルに登録されてお
@c り、連想配列に登録されているエントリの個数に影響を受けることなく、一定時
@c 間で高速な検索を行なうことができる。DBM関連の関数が使えるPerlであれば、
@c バージョン4でも5でも動作可能である(Perl4専用プログラムとPerl5専用プログ
@c ラムとに分れている)。
@c
@c @file{pskkserv}を利用するには、まず@file{makedbmdic}によりSKK辞書をDBM
@c 化する必要がある。Berkeley DB形式の場合は、@file{makedbmdic}に@samp{-B}
@c オプションを、GDBMの場合は@samp{-G}オプションを渡す。
@c
@c @example
@c @cartouche
@c % makedbmdic -G SKK-JISYO.L
@c
@c makedbmdic by msatoh@@mrit.mei.co.jp
@c Make dbm format dic from SKK dic.
@c The numbers mean how many lines have processed.
@c A dot mean 20 lines, as you see.
@c
@c ..................................................1000[ 0.97%]
@c ..................................................2000[ 1.95%]
@c ..................................................3000[ 2.92%]
@c @dots{}
@c ..................................................101000[98.34%]
@c ..................................................102000[99.32%]
@c ................................... done
@c @end cartouche
@c @end example
@c
@c @noindent
@c @file{makedbmdic}により@file{SKK-JISYO.L}を処理すると、Berkeley DB形
@c 式の場合は、@file{SKK-JISYO.L.db}、GDBMの場合は@file{SKK-JISYO.L.gdbm}
@c というDBM形式の辞書が生成される@footnote{拡張子が違うので要注意。}。この
@c 辞書は、元の@file{SKK-JISYO.L}の4倍弱のファイルサイズになる。
@c
@c 次に@file{pskkserv}をEmacsの@code{exec-directory}などに置き、下記の
@c ようなシェルスクリプト@footnote{もちろん@file{pskkserv}のパスはご自分
@c のマシンに合ったものをご指定いただきたい。}を@file{rc.local}などに追加
@c して再起動する。
@c
@c @example
@c @group
@c echo Starting up pskkserv...
@c if [ -x /your/path/to/pskkserv ]; then
@c         /your/path/to/pskkserv -G /your/path/to/SKK-JISYO.L.gdbm &
@c fi
@c @end group
@c @end example
@c
@c また、下記のようなフォームを@file{~/.emacs}などに設定する。
@c
@c @lisp
@c (setq skk-server-prog "/your/path/to/pskkserv")
@c @end lisp
@c
@c @noindent
@c ディレクトリが、@code{exec-directory}と同一ならば、下記のように指定する
@c こともできる。
@c @lisp
@c (setq skk-server-prog (concat exec-directory "pskkserv"))
@c @end lisp
@c
@c @noindent
@c @file{pskkserv}を使用する場合でも、設定は@file{skkserv}を使用するとき
@c と変りない。@xref{共通の設定}.
@c @xref{スーパーユーザの権限を持たない人の場合}.

@node SKK on Jed, skkinput, skkfep, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK on Jed
@cindex Jed
@cindex S-Lang

このセクションは、SKK on Jedの開発者である豊福親信氏により書かれた。

@table @asis

@item 正式名称
SKK on Jed

@item どのようなソフトウェアか
Jed(Emacs系の軽いエディタ。C言語風の拡張言語S-Langを持つ)に移植された
SKKです。

@item 使用するために要求される環境
日本語版Jedが動いていればその上で動きます。現在、多くのUNIX、MSDOS、
Win95/NT、OS2上で日本語版Jedは動いています。

@item 最新バージョン、release の日付
version 0.1.1(1996年12月15日)

@item 開発者
豊福 親信

@item 配布条件
SKKと同じです。

@item 入手方法

@table @asis
@item メールによる入手方法
@samp{unbound@@papaya.juice.or.jp}にメールで連絡して下さい。

@item WWWを利用して入手する方法
WWWクライアントを利用して
@w{@samp{http://www.juice.or.jp/~toyofuku/jed.html}}から入手できます。
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@end table

@item bug report,質問のためのアドレス
@w{@samp{unbound@@papaya.juice.or.jp}}

@item その他
まだいくつか未実装機能がありますがSKKの全機能実装を目指しています。
@end table

@node skkinput, SKKIME, SKK on Jed, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkinput
@cindex @file{skkinput}

このセクションは、skkinputの開発者である阪本崇氏により書かれた。

@table @asis

@item 正式名称
skkinput

@item どのようなソフトウェアか
日本語テキスト入力を要求するX11のアプリケーションのための入力サーバ。現
在はKinput Protocolにしか対応していませんが、将来的にはXIMやKinput2
Protocolに対応させる予定です。

@item 使用するために要求される環境
UNIX + X11R5またはX11R6(R6.1)

@item 最新バージョン ,release の日付
2.03, 

@item 開発者
阪本 崇(@w{@samp{sakamoto@@yajima.kuis.kyoto-u.ac.jp}}, @*
@w{@samp{PXG01715@@niftyserve.or.jp}})

@item 配布条件
ありません。

@item 入手方法
@smallexample
@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkinput.htm}}
@end smallexample
@noindent
から入手できます。
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item bug report、質問のためのアドレス
@w{sakamoto@@yajima.kuis.kyoto-u.ac.jp}もしくは
@w{PXG01715@@niftyserve.or.jp}まで御願い致します。

@item その他
SKK 8.6にはかなり近付けたと思うのですが、まだまだ異なる部分が残っていま
す。特に操作体系で異なると感じられた方は私までレポートを御願い致します。
@end table

@node SKKIME, SKK95, skkinput, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKKIME
@cindex SKKIME

@table @asis

@item  開発者
skkinput と同じく 阪本崇氏

@item 最新バージョン
SKKIME 1.0

@item 入手先
@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkime.htm}}

@end table

@node SKK95,  , SKKIME, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK95
@cindex SKK95

@c @table @asis
@c @item 正式名称
@c @item どのようなソフトウェアか
@c @item 使用するために要求される環境
@c @item 最新バージョン、release の日付
@c @item 開発者
@c @item 配布条件
@c @item 入手方法
@c @item bug report,質問のためのアドレス
@c @item その他
@c @end table

このセクションは、京大マイコンクラブ川崎進一郎氏によって書かれた。

@table @asis

@item 正式名称
SKK95

@item どのようなソフトウェアか
Windows95, WindowsNT, Windows98 上で SKK ライクなかな漢字入力を実現する
IME。

@item 使用するために要求される環境
上記のOS(もちろん日本語版)。

@item 最新バージョン、release の日付
最新バージョンα13。1999年6月9日。

@item 開発者
京大マイコンクラブ

@item 配布条件
SKK95はフリーウェアです。商業目的以外の目的のためならば自由にコピーして
いただいて構いません。SKK95を使用したことによるいかなる被害に対しても、
SKK95 の作者は責任を負いません。

@item 入手方法
下記のウェッブページから入手して下さい。
@w{@samp{http://www.kuis.kyoto-u.ac.jp/~kmc/proj/skk95/}}

@item bug report,質問のためのアドレス
@w{@samp{skk95-bugs@@kmc.kyoto-u.ac.jp}}

@item その他
1999年9月現在、SKK95はαバージョンであり、動作が安定していないところもあ
ります。WindowsNTでは比較的安定して動作するようです。

@end table

@node 謝辞とお願い, 事項索引, SKK関連ソフトウェア, Top
@comment  node-name,  next,  previous,  up
@chapter 謝辞とお願い

@menu
* 謝辞::                        
* お願い::                      
* あとがき::                    
@end menu

@node 謝辞, お願い, 謝辞とお願い, 謝辞とお願い
@comment  node-name,  next,  previous,  up
@section 謝辞

SKKの設計方針はTAO/ELIS上の日本語入力システムKanzenの影響を受けています。
Kanzenのデモを行ってくださり、またKanzenを使う機会を与えてくださったNTT
の竹内郁雄さんに感謝します。

第1版の辞書作成のための読みの入力を行ってくださった東北大学電気通信研究
所佐藤研究室の 安藤大君、猪岡美紀さん、奥川淳一君、佐々木昭彦君、佐藤克
志君、山岸信寛君に感謝します。

SKK辞書第2, 3, 4, 5, 6, 7, 8版作成のためのデータを提供してくださった方々
に感謝します。

SKK辞書第6, 7版作成にあたり協力してくださった高橋裕信氏に感謝します。

その他、SKK改良のためにプログラム等を提供してくださった大勢の方々に感謝
します。

@node お願い, あとがき, 謝辞, 謝辞とお願い
@comment  node-name,  next,  previous,  up
@section お願い

SKK辞書は多くのユーザの方々から提供された辞書によりコピーフリーの辞書と
しては最大規模の辞書になっています。今後もこの方式によりSKK辞書をより充
実したものにしていきたいと思います。毎年1月頃を目途にアナウンスしますが、
SKK辞書の充実にご協力いただける方は、随時以下のアドレスまで個人辞書と 
@file{SKK-JISYO.L}との差分をお送りください。お送りいただいた辞書を整理
して次年度の辞書に含めさせていただきます。差分ファイルの作成方法について
は@ref{skkdic-expr}をご参照下さい。

また, @file{SKK-JISYO.L}の誤りを発見された方は多少にかかわらず、下記の
アドレスまでお知らせください。

@example
@samp{skk-dic@@maid.ne.jp}
@samp{skk-jisyo@@kuis.kyoto-u.ac.jp}
@end example

@node あとがき,  , お願い, 謝辞とお願い
@comment  node-name,  next,  previous,  up
@section あとがき

本マニュアルは、佐藤と亀山がLatexinfoを使用してSKKバージョン8.6について
書いたものを、中島がTexinfo形式で加筆・修正し、酒井清隆、原内聡が校正し
たものである。加筆や修正の大部分は、SKKの拡張機能に伴なうものである。

@node 事項索引, 変数索引, 謝辞とお願い, Top
@comment      node-name, next,       previous, up
@unnumbered 事項索引

@printindex cp

@node 変数索引, 関数索引, 事項索引, Top
@comment    node-name,         next,       previous, up
@unnumbered 変数索引

@printindex vr

@node 関数索引, キー索引, 変数索引, Top
@comment      node-name, next,       previous, up
@unnumbered 関数索引

@printindex fn

@node キー索引,  , 関数索引, Top
@comment      node-name, next,       previous, up
@unnumbered キー索引

@printindex ky

@summarycontents
@contents
@bye

@c Local Variables:
@c End:
