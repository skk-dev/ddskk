\input texinfo @c -*-texinfo-*- coding: iso-2022-jp -*-
@setfilename skk.info
@settitle The SKK Manual
@c 
@c  Author: Masahiko Sato <masahiko@kuis.kyoto-u.ac.jp>
@c          Yukiyoshi Kameyama <kameyama@@kuis.kyoto-u.ac.jp>
@c          Mikio Nakajima <minakaji@osaka.email.ne.jp>
@c  Maintainer: Mikio Nakajima <minakaji@osaka.email.ne.jp>
@c  Version: $Id: skk.texi,v 1.29 2000/09/27 14:02:00 czkmt Exp $
@c  Keywords: japanese
@c  Last Modified: $Date: 2000/09/27 14:02:00 $
@c
@set EDITION 1.4
@set SKK-VERSION 10.61
@set UPDATED $Date: 2000/09/27 14:02:00 $
@c @set UPDATED-MONTH Oct 1998

@direntry
* SKK: (skk).         Simple Kana to Kanji conversion program
@end direntry

@c Texinfo に追加できたら良いなぁと思う点を述べます。私、単なる LaTeX ユー
@c ザーで、Plain TeX マクロの組み方なんて全然知りませんので、ユーザーの立場
@c でやりたいことを卒直に、また無責任に述べるに留めます。あしからず。実現で
@c きる方法をご存知の方がいらっしゃいましたら、是非教えて下さい。
@c
@c (1)日本語の用語についてゴシック体でプリントアウトし、info では "「" 
@c    と "」" を自動的に付けるような@jdfn{}が欲しい。本書では、日本語
@c    の用語定義をとりあえず`「',`」' で囲み、@b コマンドでゴシック体を
@c    出力するようにしている。
@c
@c (2)アスキー文字と全角文字を連接して書いたとしても pTeX がその間に適切
@c    に空白を挿入して印刷してくれる。一方 info は連接したままで空白は挿
@c    入されないので少し見にくい気がする。info ではアスキー文字と全角文
@c    字との間に半角スペースを挿入してはどうか？
@c
@c (3)LaTeX の表を書くコマンドを実装して欲しい (なら Latexinfo を使えと
@c    は言わないでね。互換性が大きく損なわれるから嫌なんです)。

@synindex pg cp
@footnotestyle end
@iftex
@afourpaper
@end iftex
@ifinfo
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@title The SKK Manual
@subtitle Edition @value{EDITION}for SKK Version @value{SKK-VERSION}
@c @subtitle @value{UPDATED-MONTH}
@subtitle @value{UPDATED}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{}1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999
@w{Masahiko Sato}(佐藤雅彦), @*
@w{Yukiyoshi Kameyama}(亀山幸義) and @w{Mikio Nakajima}(中島幹夫).
Revised by @w{Kiyotaka Sakai}(酒井清隆) and @w{Satoshi Harauchi}(原内聡).

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.

@end titlepage
@page
@ifinfo
@node Top, はじめに, (dir), (dir)
@top SKK

(最終更新日: @value{UPDATED})

これは @cite{SKK マニュアル} 第 @value{EDITION} 版です。
SKK のバージョン @value{SKK-VERSION} に対応しています。


@menu
* はじめに::
* はじめの設定::
* 基本的な使用方法::            
* 便利な応用機能とユーザーオプション::
* 辞書ユーティリティプログラム::
* 拡張アイディア::
* SKKメーリングリスト::
* SKKの入手方法::
* SKK関連ソフトウェア::
* 最新情報など::
* 事項索引::
* 変数索引::
* 関数索引::
* キー索引::
@end menu
@end ifinfo

@node はじめに, はじめの設定, Top, Top
@comment  node-name,  next,  previous,  up
@chapter はじめに

SKK version 10 は高速で効率的な日本語入力環境を提供するシステムです。
GNU General Public License に従ったフリー・ソフトウェアとして配布されます。

SKK 10 が動作を保証する Emacsen のバージョンは下記の通りです。

@itemize @minus
@item Emacs 19.28 以降をベースとした Mule 2.3 (Mule for Windows 1.21,
1.22 を含む)
@item Emacs 20.2 以降 (Meadow 1.00 以降 を含む)
@item Mule 機能付きでコンパイルされた XEmacs 20.4 以降
@end itemize

SKK は、Simple Kana to Kanji conversion program にちなんで名付けられました。

主な特徴は、次の通りです。

@itemize @bullet
@item ローマ字入力による、文法的知識を用いない高速変換可能な日本語入力/変換。
@item 辞書に登録されていない単語の登録が簡単。
@item 個人辞書への単語の登録による変換の高ヒット。
@item マイナーモードとして実装されているので、メジャーモードにほとんど影
響を与えない。つまり、Emacs との親和性が高い。
@item SKK 本体(Emacs Lisp) と辞書のみで動作(サーバーは必須ではない)。辞
書サーバーがダウンしていても使用できる。
@item 辞書サーバーを使うことで、Emacs の SKK 使用メモリを削減可能。
@item ディスク容量に応じて選べる辞書。
@item SKK と同様の操作で行える日本語インクリメンタルサーチ。
@item Emacs Lisp で書かれたプログラムを変換候補にできる。
@item 個人の設定により、ローマ字入力の代わりに T-Code、TUT-code による入
力も可能。
@end itemize

@node はじめの設定, 基本的な使用方法, はじめに, Top
@comment  node-name,  next,  previous,  up
@chapter はじめの設定

SKK を使い始める前に、あなたの @file{~/.emacs} に設定を書かなければなり
ません。ここではその方法を説明します。

@menu
* 最も基本的な設定::
* インクリメント検索の設定::
* 古い設定のチェック::
* 辞書サーバを使いたいときの設定::
@end menu

@node 最も基本的な設定, インクリメント検索の設定, はじめの設定, はじめの設定
@comment  node-name,  next,  previous,  up
@section 最も基本的な設定
@cindex @file{skk-obsolete.el}

以下のように @file{.emacs} に書きます。
@footnote{いくつかのキー定義は Emacs 標準のコマンドと重なるので、問題が
ある場合は設定を変更してください。将来、この点について改良される予定です
が、興味があったら

@xref{拡張アイディア}.

を参照してください。}

@lisp
@group
(require 'skk-autoloads)
(global-set-key "\C-x\C-j" 'skk-mode)
(global-set-key "\C-xj" 'skk-auto-fill-mode)
(global-set-key "\C-xt" 'skk-tutorial)
@end group
@end lisp

サーバーを使わない場合は、更に辞書ファイルを指定する必要があります。

@lisp
(setq skk-large-jisyo "/your/path/to/SKK-JISYO.L")
@end lisp

@code{skk-large-jisyo} はEmacsのバッファに取り込んで使用するので、これに
よりメモリが圧迫されすぎる場合は、上記の @file{SKK-JISYO.L} を
 @file{SKK-JISYO.S} や @file{SKK-JISYO.M} に変更します。

@node インクリメント検索の設定, 古い設定のチェック, 最も基本的な設定, はじめの設定
@comment  node-name,  next,  previous,  up
@section インクリメント検索の設定

以下のように @file{.emacs} に書きます。

@lisp
@group
(add-hook 'isearch-mode-hook
          (function (lambda ()
                      (and (boundp 'skk-mode) skk-mode
                           (skk-isearch-mode-setup)))))

(add-hook 'isearch-mode-end-hook
	  (function
	   (lambda ()
	     (and (boundp 'skk-mode) skk-mode (skk-isearch-mode-cleanup))
	     (and (boundp 'skk-mode-invoked) skk-mode-invoked
		  (skk-set-cursor-properly)))))
@end group
@end lisp

上記の設定では、SKKが起動されているときのみ、付属のインクリメンタルサー
チを使用します。常に付属のインクリメンタルサーチを使用したかったら上記の 
 @code{isearch-mode-hook}、 @code{isearch-mode-end-hook} の設定を下記の
設定に変更します。

@lisp
@group
(add-hook 'isearch-mode-hook 'skk-isearch-mode-setup)
(add-hook 'isearch-mode-end-hook 'skk-isearch-mode-cleanup)
@end group
@end lisp

@node 古い設定のチェック, 辞書サーバを使いたいときの設定, インクリメント検索の設定, はじめの設定
@comment  node-name,  next,  previous,  up
@subsection 古い設定のチェック

@ftable @code

@item skk-obsolete-check-all-files

このコマンドは、各個人の設定ファイルの古い設定を調べて、可能な限り新しい
設定に書換えます。 SKK 9 と比較して、変数名、関数名が大幅に変更されたので、

@example
@file{skk-obsolete.el}
@end example

をロードし、

@example
@kbd{M-x skk-obsolete-check-all-files} 
@end example

を実行することを強くお勧めします。

@end ftable

@node 辞書サーバを使いたいときの設定, , 古い設定のチェック, はじめの設定
@comment  node-name,  next,  previous,  up
@section 辞書サーバを使いたいときの設定
@cindex @var{SKKSERVER}
@cindex @var{SKKSERV}
@cindex @var{SKK_JISYO}

辞書サーバを使いたいときは、@file{.emacs}や@file{.skk} で以下のように設
定します。
@footnote{辞書サーパを使ってみたい場合は

@xref{dbskkd-cdb}.

を参照してください。}

@smalllisp
@group
(setq skk-server-host "hogehoge")
(setq skk-server-prog "/your/path/to/skkserv")
(setq skk-server-jisyo "/your/path/to/SKK-JISYO.L")
@end group
@end smalllisp

@vtable @code
@item skk-server-host
辞書サーバーを走らせるホスト名、または IP アドレス。
@item skk-server-prog
辞書サーバープログラム(フルパスで指定する)。
@item skk-server-jisyo
サーバーに渡す辞書(フルパスで指定する)。
@end vtable

@noindent
この設定は、環境変数を利用して下記のようにすることもできます。

@table @asis
@item Bシェルの場合 (sh, bash, ksh, zsh など)

@example
@group
export SKKSERVER=hogehoge
export SKKSERV=/your/path/to/skkserv
export SKK_JISYO=/your/path/to/SKK-JISYO.L
@end group
@end example

@item Cシェルの場合 (csh, tcsh など)

@example
@group
setenv SKKSERVER hogehoge
setenv SKKSERV /your/path/to/skkserv
setenv SKK_JISYO /your/path/to/SKK-JISYO.L
@end group
@end example
@end table

@node 基本的な使用方法, 便利な応用機能とユーザーオプション, はじめの設定, Top
@comment  node-name,  next,  previous,  up
@chapter 基本的な使用方法

本章では、SKKの基本的な使用方法を説明します。これを読めば、とりあえず
SKK を使ってみるには充分です。

SKK を使った入力方法に慣れるには、付属の@xref{チュートリアル}プログラムが最
適なので、お試しください。

なお、次章の「便利な応用機能とユーザーオプション」は、興味のある個所のみ
をピックアップしてお読みになるのがいいでしょう。

@menu
* 起動と終了::                  
* モード::                      入力モードと変換モード。
* インクリメンタル・サーチ::    
* チュートリアル::    
@end menu

@node 起動と終了, モード, 基本的な使用方法, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section 起動と終了
@cindex オートフィル[おーとふいる]
@cindex 個人辞書[こしんししよ]
@cindex Auto Fill
@kindex C-x C-j
@kindex C-x j

SKK モードに入るには @kbd{C-x C-j}、もしくは @kbd{C-x j} とタイプします。
マイナーモードの表示には、下記のように @w{@samp{かな}} が追加されます。
@footnote{
@lisp
@group
(setq skk-status-indicator 'left) 
@end group
@end lisp
と指定しているときはモードラインの左端に追加されます。}。

@example
MULE/7bit----- Buffer-name (Major-mode かな)---
@end example

また、カーソルの色が変化します
@footnote{カラーディスプレイを使用し、カラー表示をサポートしている
Window System 下で対応する Emacs を使用している場合。}。

@kbd{C-x C-j}、もしくは @kbd{C-x j} を再度タイプすることで、SKK モードに
入る前のモードに戻り、カーソル色も元に戻ります。
@footnote{但し、@b{「アスキーモード」}を利用すれば SKK モードから抜ける
必要はほとんどありません。

@xref{入力モード, ,アスキーモード}.}

@menu
* SKKオートフィルモード::
* 辞書の保存::
@end menu

@node SKKオートフィルモード, 辞書の保存, 起動と終了, 起動と終了
@comment  node-name,  next,  previous,  up
@subsection SKKオートフィルモード
@kindex C-u -1 C-x j
@kindex C-u C-x j
@kindex C-x j
@kindex M-- C-x j
@kindex M-1 C-x j

@kbd{C-x j} とタイプすれば、SKK モードに入ると同時にオートフィルモード
@footnote{@xref{Auto Fill, , Auto Fill, emacs, GNU Emacs Manual}.}
をオンにします。

既にオートフィルモードがオンになっているバッファで @kbd{C-x j}をタイプす
ると、オートフィルモードは逆にオフになるので注意してください。

バッファの状態にかかわらず強制的にオートフィルモード付で SKK モードに入
りたい場合は、@kbd{M-1 C-x j} や @kbd{C-u C-x j} などとタイプし、このコ
マンドに正の引数を渡しぇす
@footnote{「引数」については、

@ref{Numeric Arguments, , Arguments, emacs, GNU Emacs Manual}.

を参照のこと。}。

オートフィルモードをオフにし、かつ SKK モードも終了したい場合には
@w{@kbd{M-- C-x j}} や @w{@kbd{C-u -1 C-x j}} などとタイプし、このコマン
ドに負の引数を渡します。

@node 辞書の保存,  , SKKオートフィルモード, 起動と終了
@comment  node-name,  next,  previous,  up
@subsection 辞書の保存
@kindex C-x C-c

@kbd{C-x C-c} で Emacs を終了しようとすると @code{skk-jisyo} に個人辞書の
内容を自動的に保存します。@xref{辞書の形式, , 個人辞書}.
@code{skk-backup-jisyo}に保存を行なう前の辞書が退避されます。

@ftable @code
@item  skk-kill-emacs-without-saving-jisyo

個人辞書を保存せず Emacs を終了させたい場合には、

@example
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end example

@noindent
とタイプします。
@end ftable

個人辞書の保存動作について更に詳しくは、

@ref{個人辞書の保存動作}

を参照してください。

@node モード, インクリメンタル・サーチ, 起動と終了, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section モード
@cindex マイナーモード[まいなあもーと]
@cindex メジャーモード[めしゃーもーと]
@cindex SKKモード

SKK モードは、文字種類による 4 種類の@b{「入力モード」}と、辞書を用いた
変換の状態により 3 つの@b{「変換モード」}を持ちます。本章では、入力モー
ドと変換モードについて説明します。
@xref{Minor Modes, , マイナーモード, emacs, GNU Emacs Manual}.


@menu
* 入力モード::                  文字種別毎のモード
* 変換モード::                  辞書を用いた変換の状態毎のモード
@end menu

@node 入力モード, 変換モード, モード, モード
@comment  node-name,  next,  previous,  up
@subsection 入力モード
@cindex かなモード[かなもーと]
@cindex アスキーモード[あすきーもーと]
@cindex カナモード[かなもーと]
@cindex 全英モード[せんえいもーと]

入力モードは、文字種別により

「かなモード」
「カナモード」
「全英モード」
「アスキーモード」

の4種類に分類されます。

@menu
* 入力モードの説明::
* 入力モードを切り替えるキー::
@end menu

@node 入力モードの説明, 入力モードを切り替えるキー, 入力モード, 入力モード
@comment  node-name,  next,  previous,  up
@subsubsection 入力モードの説明

@table @b

@item 「かなモード」

@itemize @asis
@item ASCII の小文字をひらがなに変換するモード。
@item マイナーモードの表示: @w{@samp{かな}}
@item カーソル色: 赤系
@end itemize

@item 「カナモード」

@itemize @asis
@item ASCII 小文字をカタカナに変換するモード。
@item マイナーモードの表示: @w{@samp{カナ}}
@item カーソル色: 緑系
@end itemize

@item 「全英モード」

@itemize @asis
@item ASCII 小文字、大文字を全角アルファベットに変換するモード。
@item マイナーモードの表示: @w{@samp{全英}}
@item カーソル色: 黄系
@end itemize

@item 「アスキーモード」

@itemize @asis
@item 文字変換を行なわないモード。入力されたキーは @kbd{C-j} を除いて通
常のEmacsのコマンドとして解釈される。
@item マイナーモードの表示: @w{@samp{SKK}} 
@item カーソル色: 背景によりアイボリーかグレイ。
@end itemize
@end table

入力モードに伴なうカーソル色の変更方法については、
@w{@ref{入力モードを示すカーソル色に関する設定}}を参照してください。

@node 入力モードを切り替えるキー,  , 入力モードの説明, 入力モード
@comment  node-name,  next,  previous,  up
@subsubsection 入力モードを切り替えるキー

@table @kbd

@item q
「かなモード」、「カナモード」間をトグルする。

@item l
「かなモード」または「カナモード」から「アスキーモード」へ。

@item L
「かなモード」または「カナモード」から「全英モード」へ。

@item C-j
「アスキーモード」または「全英モード」から「かなモード」へ。

@end table

実際にはカナモードや全英モードで長時間入力を続けることはほとんどないの
で、かなモードのままでカナ文字や全英文字を入力する便法が用意されています。
@xref{入力モードの一時変更}.

@node 変換モード, , 入力モード, モード
@comment  node-name,  next,  previous,  up
@subsection 変換モード

変換モードは、次の 3 種類のいずれかです。

@table @b

@item 「■モード(確定入力モード)」

あるキー入力に対応する文字列を、辞書を用いた文字変換を行なわずに直接バッ
ファへ入力するモード。入力モードに応じてローマ字からひらがな、ローマ字か
らカタカナ、あるいはアスキー文字から全角アルファベットへの文字変換を行な
う。

@item 「▽モード」

辞書変換の対象となる文字列、「見出し語」を入力するモード。

@item 「▼モード」

見出し語について、辞書変換を行うモード。

@end table
また、▽モードの変種として@dfn{SKK abbrev mode}があり、▼モードのサブモー
ドとして、@b{「辞書登録モード」}があります。

@menu
* ■モード::                    辞書変換を行なわない確定入力のモード。
* ▽モード::                    辞書変換のため見出し語の入力を行なうモード。
* ▼モード::                    辞書変換を行なうモード。
* 辞書登録モード::              個人辞書への単語登録を行なうモード。
@end menu

@node ■モード, ▽モード, 変換モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ■モード
@cindex 確定入力[かくていにゆうりよく]
@cindex ローマ字入力[ろーましにゆうりよく]

確定入力モードを@b{「■モード」}と呼びます。■モードでは、あるキー入力に
対応した特定の文字列への変換を行なうだけで、辞書変換は行いません。ASCII
文字列から、入力モードに応じて、ひらがな、カタカナ、あるいは全角アルファ
ベットへの文字変換を行ないます。変換を行なうカレントバッファにこのモード
特有のマークは表示されません。

かなモード、カナモードで、かつ ■モードである場合、ディフォルトの入力方法
はいわゆるローマ字入力です。訓令式、ヘボン式のどちらによっても入力するこ
とができます。主な注意点を以下に説明します。

@itemize @bullet

@item
@samp{ん}は @kbd{n n} または @kbd{n '} で入力する。直後に @samp{n}、
@samp{y} 以外の子音が続くときは @samp{n} だけで入力できる。

@item
促音は、@kbd{c h o t t o} @result{} @samp{ちょっと}、@kbd{m o p p a r a}
@result{} @samp{もっぱら}のように次の子音を重ねて入力する。

@item
促音や拗音(ひらがなの小文字)を単独で入力するときは、@kbd{x a} @result{}
@samp{ぁ}、@kbd{x y a} @result{} @samp{ゃ}などのように @samp{x} を用いる。

@item
長音には、@samp{-}を用いる。@samp{-}@result{}@samp{ー}。
@end itemize

@node ▽モード, ▼モード, ■モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ▽モード
@cindex 辞書変換対象の文字列の決定[ししょへんかんたいしようのもしれつのけつてい]
@cindex ▽マークの付け忘れ[▽まーくのつけわすれ]
@cindex 数字から始まる見出し語の入力[すうしからはしまるみたしこのにゆうりよく]
@kindex @samp{Q}
@kindex C-g
@kindex C-j

@b{「▽モード」}では、辞書変換の対象となる文字列を入力します。かなモード、
もしくはカナモード@footnote{@xref{入力モード, , かなモード、カナモード}.}
で、かつ、■モードであるときに、キー入力を大文字で開始することで、▽モー
ドに入ります。例えば、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
のようにタイプすることで、▽モードに入り、続けて辞書変換の対象となる文字
列、「見出し語」を入力してゆくことができます。@samp{▽}マークは、▽モード
であるという表示ですが、見出し語開始点を示す表示でもあります。

@menu
* 後から▽モードに入る方法::
* ▽モードを抜ける方法::
@end menu

@node 後から▽モードに入る方法, ▽モードを抜ける方法, ▽モード, ▽モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 後から▽モードに入る方法

@samp{K} の文字を大文字で入力し忘れた場合は、辞書変換の対象としたい文字
列の先頭までポイント
@footnote{@xref{Point, ,ポイント, emacs, GNU Emacs Manual}.}を戻し 
@samp{Q}をタイプすることで▽モードに入ることができます。例えば、下記のよ
うに操作します (@point{} の地点にカーソルがあります)。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{C-u 3 C-b}, @kbd{Q}

@group
------ Buffer: foo ------
▽@point{}かんじ
------ Buffer: foo ------
@end group

@kbd{C-e}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

@samp{7がつ24にち} のように大文字から始めることができない文字列についても、
▽モードにしたい場合は @samp{Q} をタイプし、▽モードにしてから @samp{7が
つ24にち} の文字列を入力します。なお、▽モードでは、文字列の間に空白を含
めることはできません
@footnote{これは、辞書の見出し語に空白を含めることができない制限からきて
います。}。

@node ▽モードを抜ける方法, , 後から▽モードに入る方法, ▽モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec ▽モードを抜ける方法

誤って▽モードに入ってしまったときは @kbd{C-j} とタイプし、■モードに戻
るか @kbd{C-g} とタイプし▽モードで辞書変換と対象となっている文字列を消
去するかの 2 通りの処理の方法があります。具体例を下記に示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
かんじ
------ Buffer: foo ------
@end group
@end example

@noindent
あるいは、

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group
@end example

@node ▼モード, 辞書登録モード, ▽モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection ▼モード
@cindex Overlays
@cindex ハイライト[はいらいと]
@cindex 暗黙の確定[あんもくのかくてい]
@cindex 変換開始[へんかんかいし]

@b{「▼モード」} では、▽モードで入力した見出し語を、辞書に従い変換する作
業を行ないます。▽モードで見出し語を入力した後 @key{SPC} をタイプするこ
とで▼モードに入ります。@samp{▽} マークから @key{SPC} をタイプしたとき
のポイントまでの文字列が見出し語として確定され、 @samp{▽} マークは
@samp{▼} マークで置き換えられ、この文字列が辞書の中で検索されます。

@menu
* 送り仮名が無い場合::
* 次候補・前候補::
* 送り仮名が有る場合::
@end menu

@node 送り仮名が無い場合, 次候補・前候補, ▼モード, ▼モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が無い場合

仮に、辞書に

@example
かんじ /漢字/幹事/
@end example

@noindent
というエントリ
@footnote{本マニュアルでは、見出し語と候補群を合わせた一行を「エントリ」
と呼びます。詳細は、@ref{辞書の形式}を参照してください。}を含むとして、
例を示します。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼漢字@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
この例では、▽モードにおける @samp{▽} マークからポイントまでの間の文字列
@samp{かんじ} を辞書変換の対象文字列として確定し、それについて辞書内での
検索を行なっています。実際の変換動作では、候補部分がハイライト表示されます
@footnote{ハイライト表示はFSF EmacsのOverlays、XEmacs のextentの機能を使
用しています。}。

@samp{漢字} が求める語である場合は @kbd{C-j} をタイプすれば、この変換が
確定します。ハイライト表示も @samp{▼} マークも消えます。

また @kbd{C-j} をタイプせずに、新たな確定入力を続けて行なうか、または新
たな変換を開始すると、直前の変換は自動的に確定されます。これを @b{「暗黙
の確定」} と呼んでいます。副作用として確定を伴なうキーは、印字可能な文字
全てと @key{RET} です。ただし、

@ref{暗黙の確定のタイミング}

をご覧ください。

@node 次候補・前候補, 送り仮名が有る場合, 送り仮名が無い場合, ▼モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 次候補・前候補

求めるものがすぐに出なければ、更に続けて @key{SPC} をタイプすることで、
次候補を検索します。

@example
@group
------ Buffer: foo ------
▼漢字
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼幹事
------ Buffer: foo ------
@end group
@end example

候補が 5 つ以上あるときは 5 番目以降の候補は 7 つずつまとめてエコーエリ
アに表示されます。例えば、辞書が

@example
@group
きょ /距/巨/居/裾/嘘/拒/拠/虚/挙/許/渠/据/去/
@end group
@end example

@noindent
というエントリを含むときに @kbd{K y o} の後に @key{SPC} を 5 回続けて打
てば、

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

@noindent
がエコーエリア
@footnote{エコーエリアとミニバッファは視覚的には同一の場所にありますが、エコー
エリアが単にユーザーへのメッセージを表示するのみであるのに対し、ミニバッ
ファは独立のバッファとして機能する点が違います。}に表示されます。ここで仮に
@samp{許} を選択したければ、 @samp{k} を入力します。

@samp{A}, @samp{S}, @samp{D}, @samp{F}, @samp{J}, @samp{K}, @samp{L} の
各文字は、押し易さを考慮してキーボードのホームポジションから横方向に一直
線に配置されているキーが選ばれています。また、候補の選択のために押すキー
は、大文字、小文字のいずれでも構いません。候補の選択に用いるキーの変更に
ついては、

@ref{候補の選択に用いるキー}

を参照してください。

@key{SPC} を連打してしまい、誤って求める候補を通過してしまったときは 
@samp{x} により前候補/前候補群に戻ることができます
@footnote{@samp{x} は小文字で入力する必要があります}。

候補を次々と探しても求めるものがなければ、自動的に辞書登録モードになります
(辞書登録モードは▼モードのサブモードです) 。これについては
@ref{辞書登録モード}にて説明します。

@node 送り仮名が有る場合, 辞書登録モード, 次候補・前候補, ▼モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が有る場合

次に送り仮名のある単語について説明します。

@samp{動く} を変換により求めたいときは @kbd{U g o K u} のように、まず ▽
モード に入るために @samp{U} を大文字で入力し、次に送り仮名の開始を SKK 
に教えるために @samp{K} を大文字で入力します。送り仮名の @samp{K} をタイ
プした時点で @key{SPC} をタイプすることなく、▼モード に入り辞書変換が行
なわれます。

送り仮名の入力時、ローマ字プレフィックスが挿入された瞬間に、プレフィック
スの直前に @samp{*} を一瞬挿入し、送り仮名の開始時点を明示します。プレフィッ
クスに続くキー入力で、かな文字が完成した時点で@samp{*}は消えます。

キー入力を分解して追いながらもう少し詳しく説明します。

@example
@kbd{U g o}

@group
------ Buffer: foo ------
▽うご
------ Buffer: foo ------
@end group

@kbd{K}

@group
------ Buffer: foo ------
▽うご*k
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
▼動く
------ Buffer: foo ------
@end group
@end example

SKK ではこのように、送り仮名の開始地点をユーザーが明示的に入力するので、
システム側で送り仮名を分解する必要がありません。これにより、高速でヒット
効率が高い変換が可能になります。
@xref{送り仮名の自動処理, , 送り仮名の自動処理}.

但しサ変動詞の変換では、サ変動詞の語幹となる名詞を @b{「送りなし変換」}
@footnote{詳細は、@ref{辞書の形式, , 送りなし変換}を参照してください。}
として変換し、その後 @samp{する} を■モードで入力した方が効率が良くなり
ます。 @xref{辞書登録モード, , サ変動詞の入力}.

@node 辞書登録モード,  , ▼モード, 変換モード
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録モード
@cindex 暗黙の確定[あんもくのかくてい]
@cindex 改行文字を含む文字列の辞書登録[かいきようもしをふくむもしれつのししよとうろく]
@cindex 再帰的辞書登録[さいきてきししよとうろく]
@cindex 辞書登録[ししよとうろく]

SKKには独立の辞書登録モードはありません。その代わり、辞書にない単語につ
いての変換を行なった場合に、自動的に辞書登録モードに入ります。例えば辞書
に

@example
へんかんちゅう /変換中/
@end example

@noindent
のエントリがない場合に、@samp{変換中} を入力しようとして、@w{@kbd{H e n
k a n ty u u @key{SPC}}} とタイプすると、下記のように、カレントバッファ
は ▼モード のまま @samp{へんかんちゅう} に対して変換ができない状態で休
止し、同時にミニバッファに @samp{へんかんちゅう} というプロンプトが表示
されます。

@example
@group
------ Buffer: foo ------
▼へんかんちゅう
------ Buffer: foo ------

------ Minibuffer -------
へんかんちゅう@point{}
------ Minibuffer -------
@end group
@end example

@menu
* 送り仮名が無い場合の辞書登録::
* 送り仮名が有る場合の辞書登録::
* サ変動詞の辞書登録に関する注意::
* 再帰的辞書登録::
* 改行文字を含む辞書登録::
@end menu

@node 送り仮名が無い場合の辞書登録, 送り仮名が有る場合の辞書登録, 辞書登録モード, 辞書登録モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が無い場合の辞書登録

@noindent
辞書登録モードでは、入力はミニバッファに対して行われます。仮に辞書に

@example
@group
へんかん /変換/
ちゅう /中/
@end group
@end example

@noindent
のようなエントリがあるとして、ミニバッファで@samp{変換中}の文字列を
@samp{変換}と@samp{中}とに分けて作ります。

@example
@group
@kbd{H e n k a n @key{SPC}T y u u @key{SPC}}

------ Minibuffer -------
へんかんちゅう 変換▼中
------ Minibuffer -------
@end group
@end example

@noindent
ここで @key{RET} をタイプすれば @samp{変換中} が個人辞書に登録され、辞書
登録モードは終了します
@footnote{ここでも暗黙の確定が行なわれるので @kbd{C-j} をタイプする必要
はありません。ただし、@ref{▼モードでのRET }を参照してください。}。同時
に、変換を行なっているカレントバッファには、@samp{変換中} が挿入され確定さ
れます。 @xref{辞書の形式, , 個人辞書}.

辞書登録モードを抜けたいときは @kbd{C-g} をタイプするか、または何も登録
せず @key{RET} をタイプすると▽モードに戻ります。

@node 送り仮名が有る場合の辞書登録, サ変動詞の辞書登録に関する注意, 送り仮名が無い場合の辞書登録, 辞書登録モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 送り仮名が有る場合の辞書登録

送り仮名のある単語の登録では、ミニバッファで作る候補に送り仮名そのものを
登録しないように注意しなければいけません。仮に辞書に

@example
うごk /動/
@end example

@noindent
というエントリがないとして、例を挙げて説明します。

@example
@group
@kbd{U g o K u}

@end group
@group
------ Buffer: foo ------
▼うごく
------ Buffer: foo ------

------ Minibuffer -------
うご*く@point{}
------ Minibuffer -------
@end group
@end example

@noindent
ミニバッファで辞書登録すべき文字列は、@samp{動} だけで、送り仮名の
@samp{く} は含めてはいけません。 @samp{動く} を登録してしまうと、次に
@kbd{U g o K u} とタイプしたときに出力される候補が @samp{動くく} になっ
てしまいます。

@example
@group
@kbd{D o u @key{SPC}}

@end group
@group
------ Minibuffer -------
うご*く 動@point{}
------ Minibuffer -------

@end group
@key{RET}
@group

------ Buffer: foo ------
動く
------ Buffer: foo ------
@end group
@end example

@node サ変動詞の辞書登録に関する注意, 再帰的辞書登録, 送り仮名が有る場合の辞書登録, 辞書登録モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec サ変動詞の辞書登録に関する注意,

サ変動詞 (名詞の後に @samp{する} を付けた形で構成される動詞) については、
@samp{する} を送り仮名とした送りあり変換
@footnote{送り仮名を伴なう変換。詳しくは、@ref{辞書の形式, 送りあり変換}を
参照してください。}をしないで、@samp{運動} と @samp{する} と分けて入力し
た方が効率が良くなります
@footnote{名詞とそのサ変動詞とを別々に辞書に持つと空間的な効率が悪いので、
基本的に、辞書がサ変動詞を送りありとして意識した作りとしていません。その
ため、@samp{する} を送り仮名とした送りあり変換では、辞書に候補がなく辞書
登録モードに入ってしまう可能性が高いので、名詞として分解して入力すること
をお勧めします。一方で、このように名詞に分解して入力することで、サ変動詞
になり得ない名詞が候補として出てくることもあるので (例えば @samp{孝行す
る} という変換を行ないたい場合に @samp{高校} が出てくるなど)、候補の絞り
込みという点では必ずしも効率が良くありません。将来のバージョンにおいてこ
の点を改善する方向で検討しています。詳しくは、@ref{拡張アイディア} を参
照してください。}。

例えば @samp{運動する} は @kbd{U n d o u @key{SPC} s u r u} とタイプする
ことにより入力できます。名詞から作られる形容詞等も同様です。

@node 再帰的辞書登録, 改行文字を含む辞書登録, サ変動詞の辞書登録に関する注意, 辞書登録モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 再帰的辞書登録

ミニバッファを再帰的に使い辞書登録を再帰的に行なうことができます。

仮に辞書に

@example
@group
さいきてき /再帰的/
さいき /再帰/
@end group
@end example

@noindent
のようなエントリがなく、かつ

@example
@group
さい /再/
き /帰/
てき /的/
@end group
@end example

@noindent
のようなエントリがあるとします。

ここで @kbd{S a i k i t e k i @key{SPC}} とタイプすると、文字列 @samp{さ
いきてき} に対する候補を見つけられないので、ミニバッファに @samp{さいき
てき} というプロンプトを表示して辞書登録モードに入ります。

@samp{さいきてき} に対する辞書エントリを作るため @kbd{S a i k i @key{SPC}}
とタイプすると、更にこの候補も見つけられないので、ミニバッファに
@samp{さいき} というプロンプトを表示して、再帰的に @samp{さいき} の辞書
登録モードに入るます。

@kbd{S a i @key{SPC}K i @key{SPC}}とタイプすると、ミニバッファは、

@example
------ Minibuffer -------
さいき 再▼帰
------ Minibuffer -------
@end example

@noindent
となります。ここで @key{RET} をタイプすると、個人辞書には

@example
さいき /再帰/
@end example

@noindent
というエントリが登録され、ミニバッファは @samp{さいきてき} の辞書登録モー
ドに戻り、プロンプトは @samp{さいきてき} となります。

今度は @samp{再帰} が変換可能なので @kbd{S a i k i @key{SPC}T e k i
@key{SPC}} とタイプすると、

@example
------ Minibuffer -------
さいきてき 再帰▼的
------ Minibuffer -------
@end example

@noindent
となります。ここで @key{RET} をタイプすることで、@samp{さいきてき} の辞
書登録モードから抜け、個人辞書に

@example
さいきてき /再帰的/
@end example

@noindent
というエントリが登録されます。カレントバッファのポイントには、@samp{再帰
的}が挿入されます。

@node 改行文字を含む辞書登録,  , 再帰的辞書登録, 辞書登録モード
@comment  node-name,  next,  previous,  up
@unnumberedsubsec 改行文字を含む辞書登録

改行文字を含む文字列を辞書に登録するには、辞書登録モードで改行文字を 
@kbd{C-q C-j} により入力します。例えば、

@example
@group
〒980
仙台市青葉区片平2-1-1
東北大学電気通信研究所
@end group
@end example

@noindent
を辞書に登録するには、辞書登録モードで、

@example
@group
@samp{〒980},
@kbd{C-q C-j},
@samp{仙台市青葉区片平2-1-1},
@kbd{C-q C-j},
@samp{東北大学電気通信研究所},
@key{RET}
@end group
@end example

@noindent
と入力します。

@node インクリメンタル・サーチ, チュートリアル, モード, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section インクリメンタル・サーチ
@cindex I-search
@cindex Incremental search
@kindex C-r
@kindex C-s
@kindex M-C-s
@kindex M-C-r

SKKでは、専用のインクリメンタル・サーチプログラムを Emacs 添付の
isearch.el のラッパーとして実装しているため、日本語の文字列についてのイ
ンクリメンタル・サーチをアスキー文字と同様の操作で行なうことができます。

@menu
* skk-isearchの操作性::
* skk-isearchと入力モード::
@end menu

@node skk-isearchの操作性, skk-isearchと入力モード, インクリメンタル・サーチ, インクリメンタル・サーチ
@comment  node-name,  next,  previous,  up
@subsection skk-isearchの操作性

大部分の動作は、オリジナルのインクリメンタル・サーチのもののままですから、
オリジナルのインクリメンタル・サーチのコマンド
@footnote{@kbd{M-y} の @code{isearch-yank-kill} や @kbd{M-p} の 
@code{isearch-ring-retreat}, @kbd{M-n} の @code{isearch-ring-advance} など}やユーザー変数でのカスタマイズ
@footnote{@code{search-highlight} など}もそのまま利用できます。

オリジナルのインクリメンタル・サーチについては、

@ref{Incremental Search, ,Incremental Search, emacs, GNU Emacs Manual}.

を参照してください。

インクリメンタル・サーチ中の入力方法は、通常のバッファにおける各入力モー
ド、変換モードでの入力方法と同一です。

@kbd{C-s} や @kbd{C-r}、あるいは @kbd{M-C-s} や @kbd{M-C-r} でインクリメ
ンタル・サーチを起動すると、インクリメンタル・サーチを起動したバッファの
入力モードと同一の入力モードで、キーとなる文字の入力が可能となります。

@node skk-isearchと入力モード,  , skk-isearchの操作性, インクリメンタル・サーチ
@comment  node-name,  next,  previous,  up
@subsection skk-isearchと入力モード

入力モードに合わせて、インクリメンタル・サーチのプロンプトが表示されます。
プロンプトの種類は、以下の5つです。

@table @asis

@item I-search: [aa]
アスキーモード

@item I-search: [か]
かなモード

@item I-search: [カ]
カナモード

@item I-search: [英]
全英モード

@item I-search: [--]
インクリメンタル・サーチモードで @kbd{C-x C-j} などをタイプしてSKKを終了
した場合は、このプロンプトが表示される。

@end table

@node チュートリアル,  , インクリメンタル・サーチ, 基本的な使用方法
@comment  node-name,  next,  previous,  up
@section チュートリアル
@cindex チュートリアル
@vindex skk-tut-file
@findex skk-tutorial
@kindex M-x skk-tutorial

SKK には、チュートリアルが附属しています。チュートリアルでは、 SKK の基本的
な操作方法を学習できます。@kbd{M-x skk-tutorial} で実行します。チュートリア
ルは、日本語(@samp{Japanese})と英語(@samp{English})が用意されています。英語
を選択する場合は、@kbd{C-u M-x skk-tutorial [RET] English [RET]} を実行しま
す。

チュートリアルファイルが、標準の場所にない場合は、 @file{.emacs} で

@lisp
  (setq skk-tut-file "a:/user/local/share/skk/SKK.tut")
@end lisp

と書くことにより、指定したチュートリアルファイルを使用させることが
できます。


@node 便利な応用機能とユーザーオプション, 辞書ユーティリティプログラム, 基本的な使用方法, Top
@comment  node-name,  next,  previous,  up
@chapter 便利な応用機能とユーザーオプション

@menu
* 予備知識::                    応用機能を使いこなすために。
* 入力モードの一時変更::        使用頻度の高くない入力モードを少しの間だけ利用する。
* ■モードにおける文字入力::    かな/カナ/全英モードにおける文字入力の設定とカスタマイズ。
* ポイントを戻して▽モードへ::  
* 確定変換とそのアンドゥ::      ユーザー側で確定することなしに確定させる変換方法とそのアンドゥ。
* 確定アンドゥ::                候補の選択ミスをアンドゥ。
* 見出し語関連::                変換のキーとなる語の処理について。
* 送り仮名関連::                送り仮名の処理について。
* 自動変換開始::                @key{SPC}を押さずに変換開始。
* 特殊変換::                    ちょっと変った便利な変換方法。
* 接頭辞・接尾辞::              接頭辞・接尾辞を指定して候補の絞り込み。
* 暗黙の確定のタイミング::      変換後の次入力ですぐに確定するかしばらく放っておくか。
* リージョン一括変換::          スパッとリージョン一括変換。
* 漢字コード関連::              漢字コードにまつわる機能。
* ▼モードの特殊キー::          キーの動作、あるいはキーバインド変更。
* 辞書関連::                    辞書にまつわる機能。
* デコレーション::              様々な表示の設定と変更。
* VIP/VIPERとの併用::           
* I-search関連::                インクリメンタル・サーチにまつわる機能。
* skk-init-fileのバイトコンパイル::  イニシャルファイルの自動バイトコンパイル。
* picture-modeとの併用::        picture-modeとの併用の際の問題点。
* サーバー関連::                
@end menu

@node 予備知識, 入力モードの一時変更, 便利な応用機能とユーザーオプション, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 予備知識

以下のセクションで応用機能とユーザーオプションについて述べるが、その前に 
SKKのファイル構成やユーザーオプションの設定についての一般的注意を述べる。
また、辞書の形式や設定方法についても詳述しておく。辞書の形式や設定方法を
理解することで、様々な応用機能がどう動くのかを理解する助けとなる。

@menu
* ファイル構成::                
* ユーザーオプションの設定方法::  
* 辞書の形式::                  辞書の形式と構成。
* 辞書に関する設定::            検索対象と検索順序の設定。
@end menu

@node ファイル構成, ユーザーオプションの設定方法, 予備知識, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ファイル構成
@cindex @file{queue-m.el}
@cindex @file{skk-auto.el}
@cindex @file{skk-autoloads.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-foreword.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-isearch.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-leim.el}
@cindex @file{skk-look.el}
@cindex @file{skk-num.el}
@cindex @file{skk-obsolete.el}
@cindex @file{skk-server.el}
@cindex @file{skk-tut.el}
@cindex @file{skk-viper.el}
@cindex @file{skk-vars.el}
@cindex @file{skk.el}

SKK バージョン 10 では、応用機能を提供するプログラムのほとんどを 
@file{skk.el} とは別のファイルに収め、必要に応じオートロードするように設
計されている。各応用機能の概略と該当のファイル名について説明する。

@table @file

@item skk-auto.el

送り仮名の自動処理を行なうプログラムを集めたファイル。

@xref{送り仮名の自動処理}.

@item skk-autoloads.el

autoloadの設定を記述したファイル。XEmacsでpackage installされた場合は使
用しない。

@item skk-comp.el

見出し語の補完を行なうプログラムを集めたファイル。

@xref{見出し語の補完}.

@item skk-foreword.el

他のファイルで共通して使用するマクロなどを中心にまとめたファイル。各ファイ
ルの冒頭部分に、あまりユーザーに興味がないものが並んでいたのでは、ユーザー
フレンドリーではないので、このファイルに集中させる仕様となっている。

@item skk-gadget.el

プログラム実行変換を行なうプログラムを集めたファイル。

@xref{プログラム実行変換}.

@item skk-isearch.el

SKKを併用したインクリメンタリサーチ機能を提供するファイル。

@xref{I-search関連}.

@item skk-kakasi.el

KAKASIインターフェイスプログラムを集めたファイル。

@xref{リージョン一括変換}.
@xref{KAKASI}.

@item skk-kcode.el

漢字コードまたはメニューによる文字入力を行なうプログラムを集めたファイル。

@xref{漢字コードまたはメニューによる文字入力}.

@item skk-leim.el
LEIM関連プログラムファイル。

@item skk-look.el

lookインターフェイスプログラムを集めたファイル。
@c @xref{lookを使用した補完・変換}. XXX

@item skk-num.el

数値変換を行なうプログラムを集めたファイル。

@xref{数値変換}.

@item skk-obsolete.el

@file{.emacs} や @file{.skk} などのユーザー設定ファイル中の古い設定 (変
数、関数名など)の修正支援プログラム。
@c XXX

@item skk-server.el

SKKサーバーインターフェイスプログラムを集めたファイル。

@xref{サーバー関連}.

@item skk-tut.el

SKKチュートリアルプログラム。

@item skk-viper.el

VIPERインターフェイスプログラムを集めたファイル。

@item skk-vars.el

古い SKK 10 をダンプした XEmacs で SKK 10 を動かすためのダミーファイル。

@end table

なお、Elibより @file{queue-m.el} ファイルを収録している。

@node ユーザーオプションの設定方法, 辞書の形式, ファイル構成, 予備知識
@comment  node-name,  next,  previous,  up
@subsection ユーザーオプションの設定方法
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@cindex @file{skk-auto.el}
@cindex @file{skk-comp.el}
@cindex @file{skk-gadget.el}
@cindex @file{skk-kakasi.el}
@cindex @file{skk-kcode.el}
@cindex @file{skk-num.el}
@cindex @file{skk-server.el}
@cindex @file{skk-viper.el}
@cindex @file{~/.emacs}
@cindex @file{~/.skk}

SKKのカスタマイズは、@file{~/.emacs}あるいは@file{~/.skk}に記述すること
ができる。また、各ファイルの提供するフックを利用することができる。上記の
ファイルやフックを利用した設定がいつ有効になるのか、という点について下記
に述べる@footnote{以前のバージョンでは、どのようなカスタマイズが行なわれ
ている場合でもチュートリアル使用時に標準設定に戻す目的で、変数の宣言に
@code{defconst}を使用していたので、全てのカスタマイズは@file{~/.skk}で行
なう必要があったが、SKK 10では、@code{defcustom}を使用した宣言を行なって
いるので、この制限はなくなった。}。

@table @asis

@item @file{.emacs}

Emacsを起動したときに一度だけ評価される。

@xref{Init File, ,.emacs, emacs, GNU Emacs Manual}.

@item @file{.skk}

SKKを起動した最初の一度だけ評価される。ファイル名のディフォルト値は、OS
の種類によりEmacsの関数@code{convert-standard-filename}により加工される。
また、@file{~/.skk}のファイル名は@code{skk-init-file}で変更することがで
きる。また、このファイルを自動的にバイトコンパイルする機能がインプリメン
トされている。詳細は、

@ref{skk-init-fileのバイトコンパイル}

を参照のこと。

@end table

@vtable @code

@item skk-mode-hook

@kbd{C-x C-j}とタイプしてSKKモードに入る度にコールされる。バッファローカ
ルの設定などを行なう場合が多い。

@item skk-auto-fill-mode-hook

@kbd{C-x j}とタイプしてオートフィルモード付きでSKKモードに入る度にコール
される。バッファローカルの設定などを行なう場合が多い。

@item skk-load-hook

@file{skk.el}のロードを完了した時点でコールされる。@file{.skk}はSKKモー
ドを起動しなければロードされないのに対し、このフックは、@file{skk.el}を
ロードしたらSKKモードを起動しなくともコールされる点が違う。

@item skk-auto-load-hook
@itemx skk-comp-load-hook
@itemx skk-gadget-load-hook
@itemx skk-kakasi-load-hook
@itemx skk-kcode-load-hook
@itemx skk-num-load-hook
@itemx skk-server-load-hook
@itemx skk-viper-load-hook

@file{skk-auto.el}, @file{skk-comp.el}, @file{skk-gadget.el},
@file{skk-kakasi.el}, @file{skk-kcode.el}, @file{skk-num.el},
@file{skk-server.el}, @file{skk-viper.el}の各ファイルがロードを完了した
直後にコールされるフック。

@end vtable

@code{load-hook}が提供されていないプログラムであっても、ロード後に何らか
のカスタマイズを行ないたい場合は、@code{eval-after-load}を使用して、例え
ば、

@example
@group
(eval-after-load "skk-look"
  '(
    ...
    ))
@end group
@end example

@noindent
のように記述する。

@node 辞書の形式, 辞書に関する設定, ユーザーオプションの設定方法, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書の形式
@cindex ;; okuri-ari entries.
@cindex ;; okuri-nasi entries.
@cindex L辞書
@cindex M辞書
@cindex S辞書
@cindex エントリ[えんとり]
@cindex ローマ字プレフィックス[ろーましふれふいつくす]
@cindex 共有辞書[きようゆうししよ]
@cindex 個人辞書[こしんししよ]
@cindex 辞書のソート方法[ししょのそーとほうほう]
@cindex 送りありエントリ[おくりありえんとり]
@cindex 送りあり変換[おくりありへんかん]
@cindex 送りなしエントリ[おくりなしえんとり]
@cindex 送りなし変換[おくりなしへんかん]
@cindex @file{SKK-JISYO.L}
@cindex @file{SKK-JISYO.M}
@cindex @file{SKK-JISYO.S}
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-henkan-strict-okuri-precedence 
@vindex skk-initial-search-jisyo
@vindex skk-jisyo
@vindex skk-kakutei-jisyo
@vindex skk-process-okuri-early

辞書の種別は大きく分けて@b{「共有辞書」}と@b{「個人辞書」}の2つがある。

@table @asis

@item 共有辞書

付属の@file{SKK-JISYO.S}(@b{「S辞書」}), @file{SKK-JISYO.M}(@b{「M辞
書」}), @file{SKK-JISYO.L}(@b{「L辞書」}) などがあり、通常、個人辞書より
もサイズが大きく、省資源の面からユーザー間で共有して参照されるが、ユーザー
の変換により内容の変更は行なわれない。

@item 個人辞書

変数@code{skk-jisyo}で指定されるファイルであり、SKKを一番最初に使い始
めたときにホームディレクトリに自動的に作られ、その後の使用により日々刻々
とエントリーが追加され、更新されてゆく辞書である。

@end table

他には@code{skk-initial-search-jisyo}や@code{skk-kakutei-jisyo}など
があるが、これらは個人毎に持つものを使用しても良いし、ユーザー間で共有し
ているものを使用しても良く、共有辞書、個人辞書という区分にはいずれにも属
さない。その性格から、辞書内容の更新は行なわれず、参照のみ行なわれる。ま
た使用目的から通常はサイズが小さい。

個人辞書、@code{skk-initial-search-jisyo}, @code{skk-kakutei-jisyo}は
Emacsのバッファに読み込んで検索を行なう。共有辞書は設定によりEmacsの
バッファに読み込んで使用する方法と、サーバー経由で使用する方法とがある。

個人辞書の一例を挙げる。

@example
@group
;; okuri-ari entries.
たとe /例/[え/例/]/
もt /持/[つ/持/]/[って/持/]/[た/持/]/[て/持/]/[ち/持/]/[と/持/]/
たすk /助/[け/助/]/
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
ふくm /含/[め/含/]/[む/含/]/[ま/含/]/[み/含/]/[も/含/]/
@dots{}
;; okuri-nasi entries.
てん /点/・/天/
ひつよう /必要/
さくじょ /削除/
へんこう /変更/
じゅんじょ /順序/
ぐん /群/郡/
こうほ /候補/
いち /位置/一/壱/
@dots{}
@end group
@end example

@noindent
@samp{てん /点/・/天/}を例に取ると、@samp{てん}が見出し語であり、その候
補が、@samp{点}、@samp{・}、@samp{天}である。候補はそれぞれ、@samp{/}に
よって区切られている。SKKでは、見出し語と候補群を合わせた
@w{@samp{てん /点/・ /天/}}の一行を@b{「エントリ」}と呼ぶ。

辞書はプレーンなテキストファイルで、最低限下記の2つの行を持つ。

@example
@group
;; okuri-ari entries.
;; okuri-nasi entries.
@end group
@end example

@noindent
この2つの行は、それぞれ送り仮名あり、送り仮名なしのエントリの開始地点を
示すマークである。@samp{;; okuri-ari entries.}までの行で@samp{;}
を行頭に持つ行はコメント行として無視される。@samp{;; okuri-ari entries.}
以降にコメント行を含むことはできないので、注意すること。

@w{@samp{;; okuri-ari entries.}}と@w{@samp{;; okuri-nasi entries.}}の
間に囲まれた上半分の部分が送り仮名ありのエントリである。これを@b{「送り
ありエントリ」}と呼ぶ。@w{@samp{;; okuri-nasi entries.}}以下の下半分部
分が送り仮名なしのエントリである。これを@b{「送りなしエントリ」}と呼ぶ。
また送りありエントリを検索する変換を@b{「送りあり変換」}、送りなしエント
リを検索する変換を@b{「送りなし変換」}と呼ぶ。SKKでは送り仮名の有無が変
換方法の1つの種別となっているので、基本的には、送り仮名がある変換では送
りありエントリのみが検索され、送り仮名がない変換では送りなしエントリのみ
が検索される。

1つの見出し語についてのエントリは1行内に書かれる(2行以上にまたがることは
できない)。改行を含む候補については、@code{(concat "改\n行")}のように、
評価すると改行を該当個所に挿入するようなLispプログラム
(@pxref{プログラム実行変換})に候補を変換して辞書に収めている。

送りありエントリは、基本的には@samp{もt /持/}のようになっており、送り仮
名部分は、送り仮名をローマ字表現したときの1文字目(あるかな文字をローマ字
表現したときの1文字目を@b{「ローマ字プレフィックス」}と呼ぶ。)で表現され
ている。この1エントリで@samp{持た}、@samp{持ち}、@samp{持つ}、@samp{持
て}、@samp{持と}の5つの候補に対応している。その5つの候補の送り仮名をロー
マ字プレフィックスで表現すれば、いずれも@samp{t}になる。

さて、個人辞書の送りありエントリには@samp{[}と@samp{]}に囲まれたブロッ
クがあるが、これは、そのブロックの先頭にある平仮名を送り仮名に取る候補群
である。上記の例で見ると、見出し語@samp{たとe}の場合は@samp{え}を送り
仮名とする1つのブロックから構成されており、見出し語@samp{ふくm}の場合は、
@samp{ま}、@samp{み}、@samp{む}、@samp{め}、@samp{も}を送り仮名とする5ブ
ロックに分けられている。

この送り仮名毎のブロック部分は、@code{skk-henkan-okuri-strictly}あるい
は@*@code{skk-auto-okuri-process}のいずれかの変数が@code{non-nil}で
ある場合に、検索の際、見出し語としてはマッチしても、更に送り仮名もマッチ
するのかどうかをテストするために使用される。例えば、

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
というエントリがあれば、同じ見出し語@samp{おおk}であっても送り仮名が
@samp{き}であれば、候補は@samp{大}のみであって@samp{多}は無視される。
@xref{送り仮名の自動処理, , skk-henkan-okuri-strictly}.
@xref{送り仮名の厳密なマッチ, , skk-auto-okuri-process}.

現在のところ、付属の共有辞書では、@samp{[}と@samp{]}を使用した送り仮名毎
のブロックの形式に対応していない。個人辞書のみがこの形式で書き込まれてゆ
く。@code{skk-henkan-okuri-strictly}が@code{nil}であっても送り仮名のブロッ
ク形式で書き込まれる。但し@code{skk-process-okuri-early}の値が
@code{non-nil}であれば、送り仮名を決定する前に変換を開始することになるの
で、送り仮名を明示的に入力していても個人辞書には@samp{[}と @samp{]}に囲
まれた送り仮名毎のブロックは作られないので注意すること @footnote{変換開
始の直前に内部変数に送り仮名を保存するのだが、送り仮名の確定前に変換を開
始するので、個人辞書も送り仮名対応ブロックが作られない。ただ、確定時点で
は送り仮名が分っているので、確定時点で送り仮名を検索し直し、個人辞書に送
り仮名対応ブロックを作ることは可能だが、@code{skk-process-okuri-early}を
利用するユーザーにとっては、それは無駄なことなのであろう。}

@footnote{SKKバージョン8では、送り仮名毎のブロックが個人辞書内に既に作ら
れていても@*@code{skk-process-okuri-early}を@code{non-nil}にして確定する
と、該当する送りありエントリの送り仮名ブロックの部分が削除されていたが、
バージョン9より、既に存在する送り仮名ブロックを保存されるように改良した。
@code{skk-process-okuri-early}を常に@code{non-nil}で使用するユーザーにとっ
てはあまり有り難い話ではないのかもしれないが、色々なユーザーオプションを
試してみようとするユーザーにとっては、@code{skk-process-okuri-early}を一
時期@code{non-nil}にしたばっかりに個人辞書の送り仮名情報がことごとく破壊
されるのは酷であろう。ちなみにここで言う「送り仮名ブロックの保存」にかか
るコストは大したことはない。}。@xref{送りあり変換の変換開始のタイミング, ,
skk-process-okuri-early}.

共有辞書では、送りありエントリは@w{@samp{;; okuri-ari entries.}}から順に
下方向に、見出し語をキーとして降順に配置されている。送りなしエントリは、
@w{@samp{;; okuri-nasi entries.}}から順に下方向に、見出し語をキーとして
昇順に配置されている。降順、昇順に配置されているのは、辞書サイズが大きい
ことに配慮してバイナリサーチを行なうためである。なお、ソートする際には、
見出し語をunsigned-charと見なしている。この順序はEmacsが@code{string<}で
文字列を比較するときの順序であり、UNIXの@file{sort}コマンドでの標準の順
序とは異なるので注意が必要である。Emacsのコマンド@code{sort-lines}を用い
ればファイルをこの順序でソートすることができる@footnote{Emacsコマンドの
@code{sort-columns}は内部的にUNIXコマンドの@code{sort}を使っているので、
辞書のソートには使わないこと。}。

一方、個人辞書は上の例でも見たように、それぞれ@w{@samp{;; okuri-ari
entries.}}, @* @w{@samp{;; okuri-nasi entries.}}を基点として、一番最後に
変換を行なったものがそれぞれのミニマムポイント@footnote{正確に言えば、送
りあり変換では@w{@code{skk-okuri-ari-min}+ 1}の位置、送りなし変換では
@*@w{@code{skk-okuri-nasi-min}+ 1}の位置である。}に挿入され辞書が更新さ
れる。個人辞書は通常は共有辞書程はサイズが大きくないので、検索時にはそれ
ぞれの基点からリニアサーチが行なわれる。個人辞書で見つけられなかった候補
については共有辞書から検索され、そこで見つかり確定された場合はその候補が
個人辞書に取り込まれ、次に同じ見出し語の検索を行なった場合に同候補を最初
に出力すべく、それぞれのミニマムポイントに挿入される。

@node 辞書に関する設定,  , 辞書の形式, 予備知識
@comment  node-name,  next,  previous,  up
@subsection 辞書に関する設定
@cindex DBM
@cindex Perl
@cindex バイナリサーチ[はいなりさーち]
@cindex リニアサーチ[りにあさーち]
@cindex 確定変換[かくていへんかん]
@c @cindex @file{pskkserv}
@vindex skk-backup-jisyo
@vindex skk-kakutei-flag
@vindex skk-search-prog-list

@code{skk-search-prog-list}の各要素に辞書検索プログラム名、辞書名、引数
をセットにしたリストを埋め込むことにより、辞書ファイルの指定、検索方法、
検索される辞書の順序などを指定することができる。
@code{skk-search-prog-list}の具体例を示しながら更に詳しく説明する。

@lisp
@group
'((skk-search-kakutei-jisyo-file skk-kakutei-jisyo 10000 t)
  (skk-search-jisyo-file skk-initial-search-jisyo 10000 t)
  (skk-search-jisyo-file skk-jisyo 0 t)
  (skk-okuri-search)
  (skk-search-jisyo-file skk-large-jisyo 10000)
  (skk-search-server skk-aux-large-jisyo 10000))
@end group
@end lisp

@noindent
関数、@code{skk-search-kakutei-jisyo-file},
@code{skk-search-jisyo-file}, @code{skk-okuri-search}, @*
@code{skk-search-server}は辞書検索プログラムである。

@ftable @code

@item skk-search-kakutei-jisyo-file
@b{「確定変換」}を行なう検索プログラム。第1引数は検索対象辞書。第2引数は
リージョンの大きさを指定する。一つの見出し語に対する変換動作に対し、検索
対象のリージョンの大きさが第2引数に指定されたサイズより小さくなるまでは
バイナリサーチが行なわれ、最後にリニアサーチが1回行なわれる。第2引数に0
を指定すると常にリニアサーチのみが行なわれる。第3引数は辞書をバッファに
読み込むときにミニバッファに読み込んでいる旨のメッセージを出力するかどう
かを指定する。検索対象の辞書ファイルはEmacsのバッファに読み込む。検索対
象のファイルから候補を見つけると、内部変数@code{skk-kakutei-flag}を立
てて、いきなり確定する(ユーザーが確定する必要はない)。

@item skk-search-jisyo-file
通常の検索を行なうプログラム。個人辞書の検索や、共有辞書でサーバーを使わ
ない検索を行なう場合はこのプログラムを使用する。第1引数、第2引数、第3引
数はそれぞれ@code{skk-search-kakutei-jisyo-file}のそれと同じ。辞書ファ
イルはEmacsのバッファに読み込む。

@item skk-okuri-search
自動送り処理を行なうプログラム。引数はない。個人辞書の送りありエントリを
検索対象としているので、個人辞書のバッファを流用し、専用の辞書バッファは
作らない。@code{skk-auto-okuri-process}の値が@code{nil}であれば、
@code{skk-search-prog-list}に@code{(skk-okuri-search)}が含まれていて
も単に無視され、スキップされるので、@code{skk-okuri-search}を動かしたい
ときは必ず@code{skk-auto-okuri-process}の値を@code{non-nil}に設定す
る。

@item skk-search-server
サーバー経由で検索するプログラム。第1引数、第2引数、第3引数はそれぞれ 
@code{skk-search-kakutei-jisyo-file}のそれと同じ。サーバーが使用不能に
なると辞書ファイルをEmacsのバッファに読み込んで検索を行なう。第2引数及び
第3引数は、辞書ファイルをEmacsのバッファに読み込んだときのみ利用される。

@end ftable

変数、@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}, @code{skk-large-jisyo}, @code{skk-aux-large-jisyo}は
辞書ファイルである。

@vtable @code

@item skk-kakutei-jisyo
確定変換用@footnote{@xref{確定変換とそのアンドゥ, , 確定変換}.}の辞書。
候補は1つのみ許される(複数の候補を書いても良いが無視される)。見出し語の
配置は、サイズが大きければ共有辞書と同じ配置
@footnote{@xref{辞書の形式, , 共有辞書の配置}.}にしてバイナリサーチを
行ない、サイズが小さければ適当な配置でリニアサーチを行なうのが良い。この
辞書は、標準の配布パッケージには含まれていないので、使用するのであればユー
ザー側で用意する必要がある。

@item skk-initial-search-jisyo
@code{skk-jisyo}の前に検索を行なう辞書。@code{skk-jisyo}の前に検索が行な
われるので@code{skk-jisyo}にカバーを掛け、最初に出てくる候補を操作するこ
とができるので、例えば、複数の専門用語毎の辞書を用意しておいて 
@code{skk-initial-search-jisyo}の値を切り替えることにより、専門分野毎の
専門用語を切り替えて入力することができて便利かもしれない。見出し語の配置
は、サイズが大きければ共有辞書と同じ配置にしてバイナリサーチを行ない、サ
イズが小さければ適当な配置@footnote{使用頻度の高い候補から降順に配置する
ことができればリニアサーチを行なう場合最も効率が良いが、作業は楽ではない
だろう。例えば、@code{skk-initial-search-jisyo}を使って一定時間文章を書
いた後@code{skk-jisyo}に挿入されたエントリの内、
@code{skk-initial-search-jisyo}にあるものを@code{skk-jisyo}に挿入されて
いる順の配置で抜き出して@code{skk-initial-search-jisyo}の見出し語の配置
を変えてゆけば不可能ではないが、結構な労力になろう。}でリニアサーチを行
なうのが良い。この辞書は、標準の配布パッケージには含まれていないので、使
用するのであればユーザー側で用意する必要がある。

@item skk-jisyo
個人辞書。SKKを一番最初に起動したときにファイルがなければ自動的に作られ
る。個人辞書より先に検索するのは、確定辞書と
@code{skk-initial-search-jisyo}のみの設定とすべき。個人辞書の見出し語は、
常に一番最近に変換された語がミニマムポイントに挿入され、その配置はランダ
ムなものになるので、バイナリサーチを行なってはならない。

@item skk-large-jisyo
共有辞書。ユーザーの用途と資源に合わせて、S辞書、M辞書、L辞書の中から選
ぶ。@code{skk-search-jisyo-file}と対にすることを想定した辞書ファイル。

@item skk-aux-large-jisyo
共有辞書。ユーザーの用途と資源に合わせて、S辞書、M辞書、L辞書の中から選
ぶ。@code{skk-search-server}と対にして使用することを想定した辞書ファイ
ル。

@end vtable

また、@code{skk-search-prog-list}には含まれないが(勿論検索されない)、個
人辞書のバックアップ辞書として@code{skk-backup-jisyo}がある。

上記の例では、
@enumerate
@item
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo},
@code{skk-jisyo}の順に検索を行ない、

@item
次に個人辞書を使って送り仮名の自動処理を行ない、

@item
その後、@code{skk-large-jisyo}の検索を行ない、

@item
最後に@code{skk-aux-large-jisyo}にサーバー経由でアクセスしている。

@end enumerate
もし確定辞書で候補が見つかったらそのまま自動的に確定される。1回 
@key{SPC}を押す動作に対し、プログラム側では新たな候補を見つけるまで上記
の動作を進める。例えば、
@enumerate

@item
確定辞書では候補は見つけられなかったが@code{skk-initial-search-jisyo}
に候補があれば、そこで一旦止まりユーザーにその候補を表示する。

@item
更に@key{SPC}が押されると、次は個人辞書を検索する。そこで候補が見つか
り、しかもその候補が@code{skk-initial-search-jisyo}で見つけた候補とは
異るものであったときは、そこでまた一旦止まりその候補をユーザーに表示する。
以降、共有辞書についても同様の繰り返しを行なう。

@end enumerate
@code{skk-search-prog-list}の設定方法としては、例えば 
@code{skk-large-jisyo}にS辞書かM辞書を指定し、S辞書、M辞書はEmacsのバッ
ファに読み込んで検索し@code{skk-aux-large-jisyo}に L辞書を指定して、L
辞書にはサーバー経由でアクセスする、という選択肢もある。

@noindent
また、サーバー経由のアクセスも決して遅くはないので、

@lisp
(skk-search-jisyo-file skk-large-jisyo 10000)
@end lisp

@noindent
を削除するという選択肢もある。ちなみに辞書ファイルの値が@code{nil}であ
れば、そのファイルを引数とした検索プログラムが
@code{skk-search-prog-list}に指定されていても、その検索は行なわれない。

@file{skk-auto.el}をロードすると、

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストが@code{skk-search-prog-list}に自動的に追加される
(@code{skk-auto-okuri-process}を@code{non-nil}に設定すると 
@file{skk-auto.el}がオートロードされる。)。追加される位置は、
@code{skk-jisyo}を検索するリストの次である。あるいは

@lisp
(skk-okuri-search)
@end lisp

@noindent
というリストを@code{skk-search-prog-list}の任意の位置に明示的に指定す
ると、@code{skk-okuri-search}を使って最初に検索したときに 
@file{skk-auto.el}がオートロードされる。

@file{skk-server.el}をロードすると、

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストが@code{skk-search-prog-list}に自動的に追加される
あるいは@code{skk-server-host}もしくは@code{skk-servers-list}を設定
するとSKKモードを起動したときに@file{skk-server.el}がオートロードされ
る。これらの場合、追加される位置は、@code{skk-search-prog-list}の末尾で
ある。あるいは

@lisp
(skk-search-server skk-aux-large-jisyo 10000)
@end lisp

@noindent
というリストを@code{skk-search-prog-list}の任意の位置に明示的に指定す
ると@code{skk-search-server}を使って最初に検索を行なったときに 
@file{skk-server.el}がオートロードされる。

@node 入力モードの一時変更, ■モードにおける文字入力, 予備知識, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 入力モードの一時変更

日常の入力では、一般的に、かなモードを使用することが圧倒的に多いと考えら
れるが、ひらがなの中にカタカナ、全角アルファベットをちりばめて入力したい、
という要求も多いと考えられる。カタカナの入力にはカナモードを、全角アルファ
ベットの入力には全英モードを用いることは前述の通り
@footnote{@xref{入力モード, , カナモード、全英モード}.}であるが、一時的
にカナ文字、全英文字を入力して、また、かなモードに戻ることができる。

また、アスキー文字を見出し語として使用するために、かなモードから一時
的にアスキー文字を入力する機能が提供されている。▽モードの変種である 
@dfn{SKK abbrev mode}がそれである。この機能を使用することにより、
@samp{is}@result{}@samp{インクリメンタル・サーチ}のような変換を行なう
ことができる。

@menu
* ひらがな/カタカナの一時的入力::  
* 全英文字の一時的入力::        
@end menu

@node ひらがな/カタカナの一時的入力, 全英文字の一時的入力, 入力モードの一時変更, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection ひらがな/カタカナの一時的入力
@kindex @samp{q}
@cindex トグル変換[とくるへんかん]

かなモードもしくはカナモードで、@samp{/}キー以外で一旦▽モードにして文字
列を挿入し、その文字列の末尾で@samp{q}をタイプすることで 
@footnote{@samp{/}キーでSKK abbrev modeに入ってしまうと@samp{q}キー入力
が@samp{q}文字の入力として扱われてしまう。} @samp{▽}マークから@samp{q}
をタイプしたポイントまでの文字列が変換され確定される。変換は、@samp{▽}
とポイント間の文字列の種類@footnote{正確に言うと@samp{▽}の次の位置にあ
る文字列をもって文字種の判別を行なっているので、途中で文字種類の違う文字
が混在していても無視される。}をキーとして下記の規則に基づき行なわれる。
@itemize @bullet

@item
カタカナはひらがなへ

@item
ひらがなはカタカナへ

@item
全英文字はアスキー文字へ

@item
アスキー文字は全英文字へ

@end itemize
一例を挙げる。

@example
@kbd{K a t a k a n a}

@group
------ Buffer: foo ------
▽かたかな@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
カタカナ@point{}
------ Buffer: foo ------
@end group
@end example

このトグル変換を上手く利用することにより、かなモードのまま一時的にカタカ
ナを入力したり、またその逆が可能となるので、一々@samp{q}キーにより入力
モードを2度切り換える必要がなく、ひらがな/カタカナ混じり文を書くときには
非常に便利であろう。

全英文字とアスキー文字のトグルでの変換を行なうことができるので、少し混乱
があるかもしれないが、全英モードやアスキーモードでは@samp{Q}やその他の
大文字により▽モードに入ることができないので、上記のトグル変換は行なうこ
とができないので注意すること。かなモード/カナモードにおいて、既に入力さ
れた全英文字、アスキー文字に対して上記の変換を行なうことができるのみであ
る。

なお、上記の変換は、いずれもリージョンに対するコマンドにて行なうこともで
きる。@xref{リージョン一括変換}.

@node 全英文字の一時的入力,  , ひらがな/カタカナの一時的入力, 入力モードの一時変更
@comment  node-name,  next,  previous,  up
@subsection 全英文字の一時的入力
@kindex @samp{/}
@kindex C-q

@samp{/}をタイプした後、全角アルファベットとして入力したい文字列を挿入し、
その文字列の末尾で@kbd{C-q}@footnote{SKK abbrev modeに入っている。@kbd{C-q}は@code{skk-abbrev-map}にマッピングされたキーバインドである。@xref{アスキー文字を見出し語とした変換}.}
をタイプすることで、@samp{▽}マークから@kbd{C-q}をタイプしたポイントま
での文字列が全角アルファベットに変換され確定される。

@example
@kbd{/ f i l e}

@group
------ Buffer: foo ------
▽file@point{}
------ Buffer: foo ------
@end group

@kbd{q}

@group
------ Buffer: foo ------
ｆｉｌｅ@point{}
------ Buffer: foo ------
@end group
@end example

なお、この変換を行なうために、

@example
file /ｆｉｌｅ/
@end example

@noindent
のような辞書エントリを持つ必要がない。辞書を参照せず、アスキー文字を1文
字づつ全英文字に変換しているためである。

@node ■モードにおける文字入力, ポイントを戻して▽モードへ, 入力モードの一時変更, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ■モードにおける文字入力

@menu
* かなモード/カナモードにおける入力::  
* 全英モードにおける入力::      
* 1回のadvertised-undo(undo)の対象::  
* 対になる文字列の一括入力::    
@end menu

@node かなモード/カナモードにおける入力, skk-rom-kana-base-rule-listの具体例, ■モードにおける文字入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection かなモード/カナモードにおける入力

@menu
* ■モードにおける文字変換::    
* 数字や記号文字の入力::        
@end menu

@node ■モードにおける文字変換,  , かなモード/カナモードにおける入力, かなモード/カナモードにおける入力
@comment  node-name,  next,  previous,  up
@subsubsection ■モードにおける文字変換
@cindex T-code
@cindex TUT-code

@vtable @code
@item skk-rom-kana-base-rule-list
@item skk-rom-kana-rule-list
@end vtable

SKK の■モードにおける文字変換は、上記 2 変数を用いて行なわれる。

これらは、1 種の規則であり、「入出力の状態がいかに移り変わるべきか」を決
定する。その内容は、

@example
(入力される文字列 出力後に自動的に入力に追加される文字列 出力)
@end example

@noindent
という形のリストを列挙したものである。

@samp{入力される文字列} とは変換される前のASCII文字の文字列である。

@samp{出力} は次の入力状態に移るときにバッファに挿入される文字列の組み合
わせであり、 @w{("ア" . "あ")} のようなコンスセルである。

2 変数のうち、@code{skk-rom-kana-rule-list} は使用者が独自の規則を定義す
るために用意されており、@code{skk-rom-kana-base-rule-list} の規則より優
先される。

@menu
* skk-rom-kana-base-rule-listの具体例::
* skk-rom-kana-rule-listの利用例(その１)::
* skk-rom-kana-rule-listの利用例(その２)::
* ■モードに関連するその他の変数::
@end menu

@node skk-rom-kana-base-rule-listの具体例, skk-rom-kana-rule-listの利用例(その１), かなモード/カナモードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec skk-rom-kana-base-rule-listの具体例

@code{skk-rom-kana-base-rule-list} には

@example
("a" nil ("ア" . "あ"))
("ki" nil ("キ" . "き"))
("tt" "t" ("ッ" . "っ"))
("nn" nil ("ン" . "ん"))
("n'" nil ("ン" . "ん"))
@end example

のような規則がある。これは

@example
a @expansion{}あ
ki @expansion{}き
tt @expansion{}っt
nn @expansion{}ん
n' @expansion{}ん
@end example

のようになることを意味する。

@node skk-rom-kana-rule-listの利用例(その１), skk-rom-kana-rule-listの利用例(その２), skk-rom-kana-base-rule-listの具体例, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec skk-rom-kana-rule-listの利用例(その１)

@code{skk-rom-kana-base-rule-list} の規則に従うと

@example
hannou @expansion{}はんおう
han'ou @expansion{}はんおう
hannnou @expansion{}はんのう
@end example

のようになる。ここで

@lisp
@group
(setq rom-kana-rule-list
      (append rom-kana-rule-list
              '(("nn" "n" ("ン" . "ん"))
@end group
@end lisp

のような設定にすることで

@example
hannou @expansion{}はんのう
@end example

のようにローマ字かな変換が行われるようになる。

@node skk-rom-kana-rule-listの利用例(その２), ■モードに関連するその他の変数, skk-rom-kana-rule-listの利用例(その１), ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec skk-rom-kana-rule-listの利用例(その２)

@example
tp @expansion{}東北大学
skk @expansion{}skk
skK @expansion{}SKK
@end example

@noindent
といった変換は、

@lisp
@group
("tp" nil ("東北大学" . "東北大学"))
("sk" "sk" ("" . ""))
("skk" nil ("skk" . "skk"))
("skK" nil ("SKK" . "SKK"))
@end group
@end lisp

@noindent
のような規則を追加すれば可能である。自分の名前を入力することはよくあるの
で、適当な省略形を用いて、このリストに追加しておくと便利かもしれない。

更に@code{skk-rom-kana-rule-list}を用いればT-codeやTUT-codeによる日本
語入力を実現することもできる。例えば TUT-code による入力についてはソース
アーカイブの @samp{experimental/tut-code} ディレクトリに収録されているソー
スコードを参照されたい。

@node ■モードに関連するその他の変数, 全英モードにおける入力, skk-rom-kana-rule-listの利用例(その２), ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@unnumberedsubsec ■モードに関連するその他の変数

@vtable @code
@item skk-kana-input-search-function

ルールリストの中に記せない変換ルールを処理する関数。これは

@example
ohs @expansion{}おおs
@end example

のような変換を実現するために用意されている。これにより

@example
ohsaka @expansion{}おおさか
ohta @expansion{}おおた
@end example

のように変換されるが、一方

@example
ohhonn @expansion{}おっほん
ohhira @expansion{}おっひら
@end example

となる場合もある。これは @code{skk-rom-kana-rule-list} の既定値に

@example
("hh" "h" ("ッ" . "っ"))
@end example

が入っているためで、これを削除すれば

@example
ohhonn @expansion{}おおほん
ohhira @expansion{}おおひら
@end example

となる。
@end vtable

@node 数字や記号文字の入力,  , ■モードに関連するその他の変数, ■モードに関連するその他の変数
@comment  node-name,  next,  previous,  up
@subsubsection 数字や記号文字の入力

かなモード/カナモードにおける次のキーは、かつては @code{skk-self-insert} 
関数にバインドされていたが、現在は他のキーと同様に @code{skk-insert} 関
数にバインドされている。

@example
@group
!  #  %  &  '  *  +

-  0  1  2  3  4  5

6  7  8  9  :  ;  <

=  >  ?  "  (  )  [

]  @{  @}  ^  _  `  |

~
@end group
@end example

これらの数字や記号文字のキーに対応し挿入される文字は、ベクトル
@code{skk-input-vector}の値により決定されていたが、このバージョンの SKK 
ではこの変数は廃止された。カスタマイズするためには、代わりに変数
@code{skk-rom-kana-rule-list} を利用する。例えば、SKK 9.6 以前において、

@lisp
(aset skk-input-vector ?! nil)
(aset skk-input-vector ?, nil)
(aset skk-input-vector ?. nil)
(aset skk-input-vector ?: nil)
(aset skk-input-vector ?; nil)
(aset skk-input-vector ?? nil)
@end lisp

このような設定をしていた場合、本バージョンの SKK で同様の入力をするため
には、

@lisp
(setq skk-rom-kana-rule-list
      '(("!" nil "!")
        ("," nil ",")
        ("." nil ".")
        (":" nil ":")
        (";" nil ";")
        ("?" nil "?")))
@end lisp

のような設定に変更する必要がある。

@code{skk-insert}は、Emacsのオリジナル関数である 
@code{self-insert-command}をエミュレートしているので、引数を渡すことに
より同じ文字を複数、一度に挿入することが可能である
@footnote{かつては、@samp{▽あ}などを入力する場合には引数渡しができなかっ
たが、本バージョンでばこれもできるように拡張されている。}。

@example
@group

@kbd{C-u 2 !}

------ Buffer: foo ------
！！
------ Buffer: foo ------
@end group
@end example

@node 全英モードにおける入力, 1回のadvertised-undo(undo)の対象, ■モードに関連するその他の変数, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 全英モードにおける入力

全英モードにおける印字可能な全てのキーは@code{skk-jisx0208-latin-insert}に割
り付けられており@code{skk-jisx0208-latin-vector}の値により挿入される文字が決
定される。@code{skk-jisx0208-latin-vector}のディフォルト値は、下記の通り。

@lisp
@group
[nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 nil  nil  nil  nil  nil  nil  nil  nil
 "　"  "！" "”" "＃" "＄" "％" "＆" "’"
 "（" "）" "＊" "＋" "，" "−" "．" "／"
 "０" "１" "２" "３" "４" "５" "６" "７"
 "８" "９" "：" "；" "＜" "＝" "＞" "？"
 "＠" "Ａ" "Ｂ" "Ｃ" "Ｄ" "Ｅ" "Ｆ" "Ｇ"
 "Ｈ" "Ｉ" "Ｊ" "Ｋ" "Ｌ" "Ｍ" "Ｎ" "Ｏ"
 "Ｐ" "Ｑ" "Ｒ" "Ｓ" "Ｔ" "Ｕ" "Ｖ" "Ｗ"
 "Ｘ" "Ｙ" "Ｚ" "［" "＼" "］" "＾" "＿"
 "‘" "ａ" "ｂ" "ｃ" "ｄ" "ｅ" "ｆ" "ｇ"
 "ｈ" "ｉ" "ｊ" "ｋ" "ｌ" "ｍ" "ｎ" "ｏ"
 "ｐ" "ｑ" "ｒ" "ｓ" "ｔ" "ｕ" "ｖ" "ｗ"
 "ｘ" "ｙ" "ｚ" "｛" "｜" "｝" "〜" nil]
@end group
@end lisp

挿入される文字の変更方法等については、@ref{数字や記号文字の入力}を
参照のこと。

@code{skk-jisx0208-latin-insert}もEmacsオリジナルの関数 
@code{self-insert-command}をエミュレートしている関係から、引数を渡すこ
とにより同じ文字を複数、一度に挿入することができる。
@code{skk-insert}における動作と同じであるので、前述した例をご参照
いただきたい。@xref{数字や記号文字の入力}.

@node 1回のadvertised-undo(undo)の対象, 対になる文字列の一括入力, 全英モードにおける入力, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 1回のadvertised-undo(undo)の対象
@cindex @file{keyboard.c}
@findex self-insert-command
@findex skk-abbrev-comma
@findex skk-abbrev-period
@findex skk-kana-input
@findex skk-insert
@findex skk-set-henkan-point
@findex skk-jisx0208-latin-insert
@vindex skk-self-insert-non-undo-count

SKKモードになっていないEmacsオリジナルバッファでは、連続する20文字の挿入
が一度のアンドゥの対象となっている。かな・カナ・全英モードにおける入力も、
このオリジナルの動作をエミュレートしている 
@footnote{@code{buffer-undo-list}にEmacsが挿入したアンドゥの境目の目印を
取り除く方法でエミュレートしている。}。正確に言えば、
@code{skk-kana-input}, @code{skk-self-insert},
@code{skk-set-henkan-point}, @code{skk-jisx0208-latin-insert}
@footnote{SKK abbrevモードでは、アスキー文字入力がEmacsオリジナルの
@code{self-insert-command}により行なわれているので、エミュレートのための
内部変数である@code{skk-self-insert-non-undo-count}をインクリメントする
ことができず、アンドゥをエミュレートできない。しかも、カンマやピリオドを
挿入した時点で、@code{skk-abbrev-comma}や@code{skk-abbrev-period}を使う
ことになるので、オリジナルのアンドゥの機能も損なってしまう。ただ、現実問
題としては、元来SKK abbrevモードは省略形としての見出し語を挿入するための
モードであるので、長い見出し語を挿入することはあまりなく、問題も小さいと
考えられる。}の各関数にバインドされたキー入力については、連続して入力さ
れた20文字を1つのアンドゥの対象としている@footnote{`20'はEmacsのソースファ
イルの一部である@file{keyboard.c}に定められたマジックナンバーと一致する。}。

但し、上記のSKKの関数とEmacsのオリジナルの@code{self-insert-command}を織
り混ぜてキー入力した場合@footnote{かなモードでの入力中、アスキーモードに
移行してタイプした場合などがこれにあたるであろう。}は、このエミュレート
機能は正常に働かないので注意すること。このエミューレート機能は、Mule-2.3
添付の@file{egg.el}を参考にした。

@example
@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o}

------------------------- Buffer: foo -------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{連続する20文字。}
------------------------- Buffer: foo -------------------------
@end group
@group

@kbd{C-_}

------------------------- Buffer: foo -------------------------
                       ;@r{20文字全てがアンドゥの対象となる。}
------------------------- Buffer: foo -------------------------
@end group

@group
@kbd{a i u e o k a k i k u k e k o s a s i s u s e s o t a t i t u t e t o n a}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてとな ;@r{連続する21文字。}
-------------------------- Buffer: foo --------------------------
@end group
@group

@kbd{C-_}

-------------------------- Buffer: foo --------------------------
あいうえおかきくけこさしすせそたちつてと ;@r{最後の1文字のみがアンドゥの対象となる。}
-------------------------- Buffer: foo --------------------------
@end group
@end example

@node 対になる文字列の一括入力,  , 1回のadvertised-undo(undo)の対象, ■モードにおける文字入力
@comment  node-name,  next,  previous,  up
@subsection 対になる文字列の一括入力
@vindex skk-auto-insert-paren
@vindex skk-auto-paren-string-alist
@vindex skk-rom-kana-rule-list
@vindex yatex-mode
@vindex tex-mode-hook

@c @samp{「}や@samp{」}が上手く処理されない...。
例えば、`「' を入力したら、必ずと言って良いほど `」' を後で入力する必要
がでてくる。`「' の入力時点で、対になる文字を自動挿入してくれるとタイプ
数を減らすことができ、入力忘れの防止にもなる。
@code{skk-auto-insert-paren}の値を@code{non-nil}にすると、上記の自動
挿入を行なう。

@example
@group
------ Buffer: foo ------
彼はこう言った@point{}
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
彼はこう言った「@point{}」
------ Buffer: foo ------
@end group
@end example

@noindent
@c @samp{「}や@samp{」}が上手く処理されない...。
上記のように `「' の入力時点で対となる`」'を自動挿入し、`「'と`」'の間に
ポイントを再配置するので、その位置からかぎかっこに囲まれた文字列を即始め
ることができる。

自動挿入すべきペア文字列は、@code{skk-auto-paren-string-alist}で指定す
る。そのディフォルト値は下記の通り。

@lisp
@group
'(("「" . "」") ("『" . "』") ("(" . ")") ("（" . "）") ("@{" . "@}")
  ("｛" . "｝") ("〈" . "〉") ("《" . "》") ("[" . "]") ("［" . "］")
  ("〔" . "〕") ("【" . "】") ("\"" . "\"") ("“" . "”"))
@end group
@end lisp

@noindent
各リストの@code{car}に指定された文字列を挿入すると、@code{cdr}に指定
された文字列を自動挿入する。このリストの各要素の@code{car}に指定された
文字列は、対になる文字列の自動挿入のために、例えアスキー文字であっても 
@code{skk-rom-kana-rule-list}に指定する必要がある。既にSKKモードになっ
ているバッファで@code{skk-auto-paren-string-alist}を変更した場合は、
@kbd{C-x C-j}もしくは@kbd{C-x j}を2度タイプして@code{skk-mode}もし
くは@code{skk-auto-fill-mode}を起動し直す必要があるので注意すること。

キーとなる文字の挿入が行なわれても、その挿入後のポイントに自動挿入すべき
文字が既に存在している場合には、自動挿入は行なわれない。

@example
@group
------ Buffer: foo ------
@point{}」
------ Buffer: foo ------

@kbd{[}

------ Buffer: foo ------
「@point{}」
------ Buffer: foo ------

@end group
@end example

対になる文字を複数挿入したい場合は、引数を渡して文字を指定する。具体例を
述べる。

@example
@group

@kbd{C-u 2 [}

------ Buffer: foo ------
「「@point{}」」
------ Buffer: foo ------
@end group
@end example

@code{yatex-mode}など、既に同種の機能が付いているモードがある。そのよう
なモードにおいてもこの自動挿入の機能が邪魔になることはないと考えるが、そ
のモードにおいてのみこの機能をオフにしたい場合は、該当のモードに入ったと
きにコールされるフックを利用して設定を行なうことができる。

@lisp
@group
(add-hook 'yatex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (set (make-local-variable 'skk-auto-insert-paren) nil)))))
@end group
@end lisp

特定のモードにおいて、自動挿入すべき文字を変更したい場合にも同様にフック
を用いて操作できる。

@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (cons '("$" . "$") skk-auto-paren-string-alist)))))))
@end group
@end lisp

@noindent
特定のペアを削除したい場合は、例えば下記のように設定する@footnote{何故
@code{copy-sequence}を使用するのかについては、@ref{数字や記号文字の入力}
を参照。}。
@lisp
@group
(add-hook 'tex-mode-hook
          (function
           (lambda ()
             (if skk-auto-insert-paren
                 (progn
                   (make-local-variable 'skk-auto-paren-string-alist)
                   (setq skk-auto-paren-string-alist
                         (delete
                          '("$" . "$")
                          (copy-sequence skk-auto-paren-string-alist))))))))
@end group
@end lisp

@node ポイントを戻して▽モードへ, 確定変換とそのアンドゥ, ■モードにおける文字入力, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ポイントを戻して▽モードへ
@cindex ▽マークの付け忘れ[▽まーくのつけわすれ]
@kindex M-Q
@vindex skk-allow-spaces-newlines-and-tabs

見出し語の入力を大文字で開始することを忘れた場合の▽マークの付け方につい
ては前述したが@footnote{@xref{▽モード, , ▽マークの付け忘れ}.}、これを
簡略化し、ワンアクションで行なう方法について説明する。

@kbd{M-Q}@footnote{@samp{Q}は大文字で入力する必要がある。}とタイプすると
ポイントの直前の文字列について走査し、同種の文字@footnote{ひらがな、カタ
カナ、全角アルファベット、アルファベットの4種類のいずれか。}が続く限り
backward方向にポイントを戻して▽モードに入り、またポイントを@kbd{M-Q}入
力時の地点に戻す。

@example
@kbd{k a n j i}

@group
------ Buffer: foo ------
かんじ@point{}
------ Buffer: foo ------
@end group

@kbd{M-Q}

@group
------ Buffer: foo ------
▽かんじ@point{}
------ Buffer: foo ------
@end group
@end example

変換開始ポイントの走査時には、スペース文字、タブ文字、長音を表わす
@samp{ー}は無条件にスキップされる。但し、ひらがなの場合は@samp{を}の直前
で、カタカナの場合は@samp{ヲ}の直前で変換開始ポイントの走査を止め、▽モー
ドに入る。変換開始ポイントを@samp{を}、@samp{ヲ}の直前で止めるのは、文章
が@samp{事情を考慮する}のように@samp{×××を○○○}の形態になっており、
@samp{○○○}のみを変換の対象としたい場合が圧倒的に多いからである。

無引数で@kbd{M-Q}を実行した場合は上記のように文字の種類によりポイント
を必要数のみbackward方向へ戻すが、明示的に戻す文字数を指定するには 
@kbd{C-u 5 M-Q}のように引数を渡して実行する。この場合は文字種別を問わず、
与えられた文字数だけ無条件にポイントを戻す。

なお、backward方向にポイントを戻す途中で行頭に到達した場合は、更に上の行
について行末の文字列から同様の走査を行ない、必要があれば更にポイントを戻
す。@code{skk-allow-spaces-newlines-and-tabs}の値を@code{nil}にするこ
とで、行を超えての走査をやめることができる。

@node 確定変換とそのアンドゥ, 確定アンドゥ, ポイントを戻して▽モードへ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 確定変換とそのアンドゥ
@cindex 暗黙の確定[あんもくのかくてい]
@findex skk-search-kakutei-jisyo-file
@vindex skk-kakutei-jisyo

確定変換を行なうプログラム@code{skk-search-kakutei-jisyo-file}と 確定
辞書@code{skk-kakutei-jisyo}については前節で述べたが、ここではその動作
について具体的に説明する。例えば、

@example
せつめい /説明/
@end example

@noindent
というエントリが確定辞書にあったとすると、

@example
@group
@kbd{S e t u m e i}

@group
------ Buffer: foo ------
▽せつめい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
説明
------ Buffer: foo ------
@end group
@end group
@end example

@noindent
のように確定動作をすることなしに(暗黙の確定もなく) いきなり確定する。仮
に確定辞書に

@example
じしょ /辞書/
@end example

@noindent
というエントリを挿入してしまったが、@samp{自署}に変換したい場合は、確定
直後に@samp{x}をタイプすることにより確定変換をアンドゥして▽モードに戻
ることができ、次に@key{SPC}をタイプしたときは、確定辞書は検索を行なわ
ないので、個人辞書、あるいは共有辞書に

@example
じしょ /自署/
@end example

@noindent
のエントリがあれば@samp{自署}への変換を行なうことができる。


@example
@group
@kbd{Z i s y o @key{SPC}}

@group
------ Buffer: foo ------
辞書
------ Buffer: foo ------
@end group

@kbd{x}

@group
------ Buffer: foo ------
▽じしょ
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼自署
------ Buffer: foo ------
@end group

@end group
@end example

@node 確定アンドゥ, 見出し語関連, 確定変換とそのアンドゥ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 確定アンドゥ
@cindex 暗黙の確定[あんもくのかくてい]
@findex skk-undo-kakutei

一番最後に行なった変換についての確定をアンドゥして、再変換を行なうことが
できる。これを@b{「確定アンドゥ」}という。確定変換のアンドゥと混同しない
こと。

下記に例を示す。辞書エントリが

@example
こうこう /高校/孝行/航行/
@end example

@noindent
のようになっているとする。

@example
@kbd{K o u k o u @key{SPC}}

@group
------ Buffer: foo ------
▼高校
------ Buffer: foo ------
@end group

@kbd{s u r u}

@group
------ Buffer: foo ------
高校する@point{}
------ Buffer: foo ------
@end group

@kbd{M-x skk-undo-kakutei}

@group
------ Buffer: foo ------
▼孝行@point{}する
------ Buffer: foo ------
@end group
@end example

@noindent
@samp{高校}の確定についてアンドゥしたので、辞書の第一候補である@samp{高
校}をスキップして、次候補である@samp{孝行}の変換を行なっている。候補
@samp{孝行}について▼モードに入ったところで、▼モードにおいて通常の変換
で@samp{孝行}を得た時点と全く同一の状態にあるので、更に@key{SPC}を押し
てこの例での次候補である@samp{航行}を変換により求めたり、更にもう一度 
@key{SPC}を押して辞書登録モードに入ることもできる。

確定した直後(上記の例では、送り仮名である@samp{する}の入力のための 
@samp{s}の入力前) でなくともアンドゥが可能である。より正確には、次の新た
な確定@footnote{@kbd{C-j}をタイプして明示的に確定した場合は勿論、暗黙の
確定を行なった場合も同様である。}を行なうまではアンドゥに関する情報が保
持されているので、アンドゥが可能である。

変換、確定に関連しない文字列は、確定アンドゥを行なっても削除されない。上
記の例では、@samp{する}がそのままカレントバッファに残っていることに注意。

@node 見出し語関連, 送り仮名関連, 確定アンドゥ, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 見出し語関連

@menu
* 見出し語の補完::              
* 見出し語を補完しながら▼モードへ::  
* 空白・改行・タブを含んだ見出し語の変換::  
* カタカナの見出し語::          
@end menu

@node 見出し語の補完, 見出し語を補完しながら▼モードへ, 見出し語関連, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語の補完
@cindex 読みのコンプリーション[よみのこんふりーしよん]
@cindex 見出し語のコンプリーション[みたしこのこんふりーしよん]
@kindex @samp{,}
@kindex @samp{.}
@kindex @key{TAB}
@vindex skk-dabbrev-like-completion
@vindex skk-search-prog-list

▽モードで@key{TAB}を押すと、見出し語(▽モードにおける入力文字列)に対す
る補完が行われる。@key{TAB}を押す直前に▽モードで入力された文字列をσと
すると、個人辞書@footnote{共有辞書はサーチされない。共有辞書では一般的に
先頭の文字を共通にする見出し語が多すぎて、望みの補完が行なえる可能性が低
いからである。}の送りなしエントリの中で、先頭がσと一致し長さがσよりも
長い見出し語を捜して、そのようなτがもしあれば、σの代わりにτが表示され
る。見出し語の補完を上手に利用することで、タイプ数を減らすことができる。

▼モードで変換を行なった語の見出し語について、時間的に新しいものから先に
補完が行なわれる。例えば、@samp{斉藤}、@samp{佐藤}の順で変換した後、
@samp{さ}をキーにして見出し語の補完を行なうと、最初に@samp{さとう}が、そ
の次に@samp{さいとう}が補完される。補完が意図したものでなかったときには 
@key{TAB}の直後に@samp{.}(ピリオド)をタイプすると2番目の見出し語が表
示される。以下同様に@samp{.}を続けてタイプすると、見出し語の候補が順次
表示される。意図した見出し語を通りすぎたときは@samp{,}(コンマ)で前の候
補に戻る。

@example
@kbd{S a t o u @key{SPC}C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group

@kbd{S a}

@group
------ Buffer: foo ------
▽さ
------ Buffer: foo ------
@end group

@key{TAB}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@samp{.}

@group
------ Buffer: foo ------
▽さいとう@footnote{@samp{さとう}の次に補完される見出し語は、個人辞書の
内容に依存する。}
------ Buffer: foo ------
@end group

@samp{,}

@group
------ Buffer: foo ------
▽さとう
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼佐藤
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
佐藤
------ Buffer: foo ------
@end group
@end example

なお、個人辞書の検索は、見出し語を得るために行なわれるので、一旦 
@key{SPC}をタイプして▼モードに入れば@code{skk-search-prog-list}の順
に候補が検索される(@code{skk-search-prog-list}で個人辞書の前に検索を行
なうように設定されている検索もスキップせずに行なう)。例えば、
@code{skk-search-prog-list}で確定変換を行なう設定を行なっており、確定辞
書にその見出し語があれば、見出し語を補完した際にも確定変換が行なわれる。

@code{skk-dabbrev-like-completion}の値を@code{non-nil}にすることで、
@samp{.}で2番目以降の補完を行なったときに、最初に補完された語について補
完が行われる。つまり上記の例では@samp{さ}に対し、最初に補完された語は、
@samp{さとう}であるので、以後の補完は、@samp{さとう}を含む語(例えば、
@samp{さとうせんせい}など) について行なわれる。

@node 見出し語を補完しながら▼モードへ, 空白・改行・タブを含んだ見出し語の変換, 見出し語の補完, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 見出し語を補完しながら▼モードへ
@cindex 見出し語のコンプリーション[みたしこのこんふりーしよん]
@cindex 読みのコンプリーション[よみのこんふりーしよん]
@kindex M-@key{SPC}

前節で見出し語の補完について述べたが、その見出し語の補完動作を行なった後、
@key{SPC}をタイプし、▼モードに入るまでの動作をワンアクションで行なうこ
とができる。補完される見出し語が予め把握できている状況では、キータイプが
ワンアクション省略できる。長い見出し語の専門用語を連続して入力する場合な
どに威力を発揮する。

@example
@group
@kbd{K a s i t a n n p o s e k i n i n n}

@group
------ Buffer: foo ------
▽かしたんぽせきにん
------ Buffer: foo ------
@end group

@key{SPC}, @key{RET}

@group
------ Buffer: foo ------
瑕疵担保責任
------ Buffer: foo ------
@end group

@kbd{K a}

@group
------ Buffer: foo ------
▽か
------ Buffer: foo ------
@end group

@kbd{M-@key{SPC}}

@group
------ Buffer: foo ------
▼瑕疵担保責任
------ Buffer: foo ------
@end group

@end group
@end example

@node 空白・改行・タブを含んだ見出し語の変換, カタカナの見出し語, 見出し語を補完しながら▼モードへ, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection 空白・改行・タブを含んだ見出し語の変換
@vindex skk-allow-spaces-newlines-and-tabs

下記のようにオートフィルモードで折り返された文字列に対し、折り返された状
態のまま変換を行なうことができる。

@example
@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムをさ
くせいしました。@point{}
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 10 C-b Q}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽@point{}さ
くせいしました。
---------------- Buffer: foo ------------------
@end group

@kbd{C-u 5 C-f}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▽さ
くせい@point{}しました。
---------------- Buffer: foo ------------------
@end group

@key{SPC}

@group
---------------- Buffer: foo ------------------
仮名漢字変換プログラムを▼作成@point{}しました。
---------------- Buffer: foo ------------------
@end group
@end example

上記の例では改行だが、空白、タブ文字を中間に含む文字列に対しても変換を行
なうことができる。@code{skk-allow-spaces-newlines-and-tabs}の値を 
@code{nil}にすることで2行以上にまたがる文字列に対する変換を禁止すること
ができる。

@node カタカナの見出し語,  , 空白・改行・タブを含んだ見出し語の変換, 見出し語関連
@comment  node-name,  next,  previous,  up
@subsection カタカナの見出し語
@kindex C-u @key{SPC}

@samp{q}によりかなモード、カナモードを度々切り替えて入力を続けていると、
カナモードで誤って▼モードに入ってしまうことがあるので、カナモードで▼モー
ドに入ろうとすると、まず見出し語をひらがなに変換するように設計されている。

更に、送りあり変換で、送り仮名もカタカナにしたい場合については、
@ref{カナモードでの変換の送り仮名の処理}を参照のこと。

あまりないケースだとは思うが、見出し語をカタカナのまま残して変換を行ない
たい場合には@key{SPC}に代えて@kbd{C-u @key{SPC}}のように@kbd{SPC}
に数値引数を渡せば良い。

@node 送り仮名関連, 自動変換開始, 見出し語関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 送り仮名関連

@menu
* 送り仮名の厳密なマッチ::      
* 送り仮名の自動処理::          
* 送りあり変換の変換開始のタイミング::  
* カナモードでの変換の送り仮名の処理::  
@end menu

@node 送り仮名の厳密なマッチ, 送り仮名の自動処理, 送り仮名関連, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の厳密なマッチ
@vindex minibuffer-exit-hook
@vindex minibuffer-setup-hook
@vindex skk-henkan-okuri-strictly
@vindex skk-process-okuri-early

例えば、個人辞書に

@example
おおk /大/多/[く/多/]/[き/大/]/
@end example

@noindent
という送りありエントリがあれば@kbd{O o K i i @key{SPC}}とタイプした場
合、標準では@samp{大きい}と@samp{多きい}という 2 通りの候補が出力可能で
あるが、この内@samp{多きい}を選択することは有り得ない。送りあり変換で、
見出し語が同じ文字列であっても選択する可能性のある候補とない候補が混在し
ている場合が多く、更に候補の絞り込みをしたいという要請が出てくる。

変数@code{skk-henkan-okuri-strictly}の値を@code{non-nil}にすると、見
出し語がマッチするかどうかのチェックの上に、送り仮名がマッチするかどうか
のチェックが行なわれ、送り仮名がマッチしない候補を出力しない。上記の場合
では、送り仮名@samp{き}がマッチする@samp{大きい}のみを出力し、@samp{多き
い}を出力しない。個人辞書の送りありエントリが充実しておれば、標準の設定
よりも候補が絞り込まれるので変換効率がアップするが、個人辞書の送りありエ
ントリが充実していなければ、すぐに辞書登録モードに入ってしまい逆効果とな
る。

このユーザーオプションは@code{skk-process-okuri-early}の値を 
@code{non-nil}にした状態と共存できない。詳細は
@ref{送りあり変換の変換開始のタイミング}を参照のこと。メニューバーを使用
してこのユーザーオプションをオンにすると、自動的に 
@code{skk-process-okuri-early}の値を@code{nil}にすることができる。

変数@code{skk-henkan-okuri-strictly}の値を@code{non-nil}にすると、辞
書登録モードに入っても送り仮名のマッチが厳密に行なわれるので、辞書登録時
に漢字を得るのに一苦労する羽目になる。下記のようにフックを設定することで
辞書登録時のみ、一時的に送り仮名の厳密なマッチをしないようにすることがで
きる。 

@lisp
@group
(add-hook 'minibuffer-setup-hook
          (function
           (lambda ()
             (if (and (boundp 'skk-henkan-okuri-strictly)
                      skk-henkan-okuri-strictly
                      (not (eq last-command 'skk-purge-jisyo)))
                 (progn
                   (setq skk-henkan-okuri-strictly nil)
                   (put 'skk-henkan-okuri-strictly 'temporary-nil t))))))

@end group
@group
(add-hook 'minibuffer-exit-hook
          (function
           (lambda ()
             (if (get 'skk-henkan-okuri-strictly 'temporary-nil)
                 (progn
                   (put 'skk-henkan-okuri-strictly 'temporary-nil nil)
                   (setq skk-henkan-okuri-strictly t))))))
@end group
@end lisp

@noindent
下記のように設定できればもっと簡潔なのだが、
@code{skk-henkan-okuri-strictly}の値は辞書バッファで参照されるために、
ミニバッファのバッファローカル値を変更しても狙った効果は得られないので注
意すること。

@lisp
@group
(add-hook 'minibuffer-setup-hook
          (function
           (lambda ()
             (if (and (boundp 'skk-henkan-okuri-strictly)
                      skk-henkan-okuri-strictly )
                 (set (make-local-variable 'skk-henkan-okuri-strictly)
                      nil )))))
@end group
@end lisp

@noindent
将来のバージョンでは、これを改良し、辞書バッファでの動作に影響するユーザー
変数をバッファローカル化できるようにする予定である。@xref{拡張アイディア}.

@node 送り仮名の自動処理, 送りあり変換の変換開始のタイミング, 送り仮名の厳密なマッチ, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送り仮名の自動処理
@vindex skk-auto-okuri-process

@menu
* どのように変換されるか::      
* 辞書登録の際に注意すべきこと::  
@end menu

@node どのように変換されるか, 辞書登録の際に注意すべきこと, 送り仮名の自動処理, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection どのように変換されるか
@vindex skk-auto-okuri-process

変数@code{skk-auto-okuri-process}を@code{non-nil}にセットすると、文
法的な知識を用いない送り仮名の自動処理が行なわれる。送り仮名の最初のロー
マ字表現を大文字で始める必要がない
@footnote{@xref{▼モード, , 送り仮名の入力}.}という利点があるが、同時に
ユーザがシステムに与える情報が少なくなるので、意図しない変換をされる割合
が増えるという欠点がある。また下記に述べるようにこの自動処理は個人辞書に
依存しているので、個人辞書の送りありエントリが貧弱な場合は、自動処理がで
きない可能性が高い。ただ、@code{skk-auto-okuri-process}を 
@code{non-nil}にセットしていても、送り仮名の開始位置を大文字のキーをタ
イプして明示的に指定することも可能であり、かつ、送り仮名を明示した場合の
変換には影響を与えないので、送りなし変換で意図しないものまで拾う可能性が
ある他はデメリットもなく、むしろ送り仮名を正確に思い出せない場合に送り仮
名を指定しなくとも変換できるメリットがあるので、この変数の値を常に 
@code{non-nil}にするのも良い選択かもしれない@footnote{専ら補完的に自動
送り処理を利用するのであれば、@code{(skk-okuri-search)}を
@code{skk-search-prog-list}の最後にもってくるのが良いであろう。}。

例えば、@kbd{T a t i a g e r u @key{SPC}}とタイプした場合、@samp{たち
あげる}という見出し語に対し、送り仮名を明示されていないので、まず送りな
し変換として扱い辞書を検索する。このときは、通常の変換同様、個人辞書及び
指定された共有辞書他を検索する。通常はそのような見出し語はないので、今度
は個人辞書のみを検索の対象として、見出し語を最後尾から1文字づつ切り詰め、
「切り詰めの結果残った文字列」と、「切り捨てられた先頭の文字のローマ字プ
レフィックス」を連結した文字列を送りあり変換の見出し語として、検索する。
この例において検索される見出し語の変化を追うと、

@example
@samp{たちあげる}@result{}@samp{たちあげr}@result{}@samp{たちあg}
@result{}@samp{たちa}@result{}@samp{たt}
@end example

@noindent
のようになる。仮に個人辞書エントリが、

@example
@group
たちあg /立ち上/[げ/立ち上/]/[が/立ち上/]/
たt /建/断/経/立/[つ/建/断/経/立/]/[ち/建/断/経/立/]/[て/経/立/建/]/
@end group
@end example

@noindent
の2つのエントリを含むとすると、見出し語を後方から順に切り詰める過程で
@samp{たちあg}と@samp{たt}の2つの見出し語の検索時にこれらの辞書エントリ
がマッチする。

@noindent
次に、マッチしたエントリの各候補に対し、切り捨てられた先頭の文字を送り仮
名として取るかどうかをチェックする。@samp{たちあg}の場合の送り仮名チェッ
クの対象は、切り捨てられた最初の文字の@samp{げ}であるので、

@example
[げ/立ち上/]
@end example

@noindent
の部分のみに注目する。また、@samp{たt}の場合の送り仮名チェックの対象は、
@samp{ち}であるので、

@example
[ち/建/断/経/立/]
@end example

@noindent
のみに注目する。もうお分りのように、マッチする見出し語に対しチェックす
るのは送り仮名ブロック部分だけであり、送り仮名に対応していない全候補を含
む部分(@samp{たt}の場合は、候補の最初の@samp{/建/断/経/立/}の部分)は
単に無視される。

@noindent
送り仮名がマッチする候補@samp{立ち上}、@samp{建}、@samp{断}、@samp{経}、
@samp{立}の5つを文字列の長さ順に昇順にソートし、それぞれの候補と該当の見
出し語から切り捨てられた文字列と連結したもの(「該当の見出し語から切り捨
てられた文字列」を送り仮名とみなして処理している。)を、送り仮名の自動処
理の最終候補として返す。上記の例では、@samp{立ち上げる}、@samp{建ちあげ
る}、@samp{断ちあげる}、@samp{経ちあげる}、@samp{立ちあげる}の5つが最終
候補である。長さ順にソートするのは、変換された部分がより長い候補を先順位
として出力するためである。上記の例の@samp{立ち上げる}と@samp{建ちあげる}
とでは、@samp{立ち上げる}の方が変換された部分が長いので、@samp{立ち上げ
る}を@samp{建ちあげる}より先順位で出力する。

@node 辞書登録の際に注意すべきこと,  , どのように変換されるか, 送り仮名の自動処理
@comment  node-name,  next,  previous,  up
@subsubsection 辞書登録の際に注意すべきこと
@vindex skk-kana-rom-vector

個人辞書に見出し語@samp{わたs}についてのエントリが全くない場合、あるいは
個人辞書のエントリが

@example
わたs /渡/[し/渡/]/
@end example

@noindent
のような送り仮名のブロックを持たない場合、@kbd{W a t a s i t a
@key{SPC}}とタイプすると、送り仮名のマッチができないので、候補の選定が
できず辞書登録モードに入る。

@example
@group
@kbd{W a t a s i t a @key{SPC}}

------ Buffer: foo ------
▼わたした
------ Buffer: foo ------

------ Minibuffer -------
わたした@point{}
------ Minibuffer -------
@end group
@end example

@noindent
辞書登録モードで@kbd{W a t a S i t a @key{RET}}と送り仮名を明示的にタ
イプし、@samp{渡した}と変換し登録する。この場合、登録する語の最後が平仮
名で終るので、その最後の平仮名の文字列(上記の例では、@samp{した})が見出
し語の最後と一致するかを調べ、一致する場合には、辞書の登録を送りありエン
トリとして行なうのかどうかの確認を求めてエコーエリアにプロンプトを出す
@footnote{@code{y-or-no-p}はミニバッファを使用しているのではなく、エコー
エリアにプロンプトを表示して次の1文字を待っている。@code{yes-or-no-p}は
ミニバッファを使用している。}。

@example
@group
@kbd{W a t a S i t a}
------ Minibuffer -------
わたした 渡した
------ Minibuffer -------
@end group
@group

@key{RET}

-------------------------- Echo Area --------------------------
Shall I register this as okuri-ari entry: わたs /渡/ ? (y or n)
-------------------------- Echo Area --------------------------
@end group
@end example

@noindent
プロンプトに対し、@samp{y}と回答した場合は、

@example
わたs /渡/[し/渡/]/
@end example

@noindent
という辞書エントリが個人辞書の送りありエントリに書き込まれる。@samp{n}
で回答した場合は、個人辞書の送りなしエントリに

@example
わたした /渡した/
@end example

@noindent
というエントリが書き込まれてしまうので、この例では適当でない。

送り仮名部分をローマ字プレフィックスに分解する際には、ユーザー変数 
@code{skk-kana-rom-vector}の値が参照される。この変数のディフォルト値は、
下記の通り。

@example
@group
["x" "a" "x" "i" "x" "u" "x" "e" "x" "o" "k" "g" "k" "g" "k" "g"
 "k" "g" "k" "g" "s" "z" "s" "j" "s" "z" "s" "z" "s" "z" "t" "d"
 "t" "d" "x" "t" "d" "t" "d" "t" "d" "n" "n" "n" "n" "n" "h" "b"
 "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "h" "b" "p" "m" "m" "m"
 "m" "m" "x" "y" "x" "y" "x" "y" "r" "r" "r" "r" "r" "x" "w" "x"
 "x" "w" "n"]
@end group
@end example

このベクトルは、それぞれ下記のかな文字をそのローマ字プレフィックスで現わ
したものである。

@example
@group
ぁ  あ  ぃ  い  ぅ  う  ぇ  え  ぉ  お  か  が  き  ぎ  く  ぐ
け  げ  こ  ご  さ  ざ  し  じ  す  ず  せ  ぜ  そ  ぞ  た  だ
ち  ぢ  っ  つ  づ  て  で  と  ど  な  に  ぬ  ね  の  は  ば
ぱ  ひ  び  ぴ  ふ  ぶ  ぷ  へ  べ  ぺ  ほ  ぼ  ぽ  ま  み  む
め  も  ゃ  や  ゅ  ゆ  ょ  よ  ら  り  る  れ  ろ  ゎ  わ  ゐ
ゑ  を  ん
@end group
@end example

@noindent
従い、ディフォルトでは、例えば見出し語中の送り仮名の@samp{じ}は、
@samp{j}に、@samp{ち}は、@samp{t}に、@samp{ふ}は、@samp{h}のローマ字
プレフィックスに分解される。これらの送り仮名のローマ字プレフィックスをそ
れぞれ@samp{z}、@samp{c}、@samp{f}に変更したい場合は、該当の個所を "z"、
"c"、"f" とするようなベクトルを@file{.emacs}や@file{.skk}に書いてお
く。

@samp{ありがさつき}に対し@samp{有賀さつき}を登録したい場合は、上記と
同様に辞書登録をし、

@example
@group
Shall I register this as okuri-ari entry: ありがs /有賀/ ? (y or n)
@end group
@end example

@noindent
のプロンプトに対し@samp{n}と回答する。この結果、個人辞書の送りなしエン
トリには、

@example
ありがさつき /有賀さつき/
@end example

@noindent
というエントリが書き込まれる。

@node 送りあり変換の変換開始のタイミング, カナモードでの変換の送り仮名の処理, 送り仮名の自動処理, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換の変換開始のタイミング
@kindex C-x C-j
@kindex C-x j
@vindex skk-auto-okuri-process
@vindex skk-henkan-okuri-strictly
@vindex skk-jisyo
@vindex skk-kakutei-early
@vindex skk-process-okuri-early

@code{skk-process-okuri-early}の値を@code{non-nil}にすることで、送り
あり変換の変換開始のタイミングを早め、送り仮名のローマ字プレフィックスの
入力時点で変換を開始することができる。

@example
@group
@kbd{U g o K}

------ Buffer: foo ------
▼動k
------ Buffer: foo ------
@end group
@end example

送り仮名が分らないまま変換していることになるので@code{skk-jisyo}が送り
仮名に対応した形に成長しない。つまり@samp{うごk /動/}のような形態のま
まとなる。但し、

@example
@group
うごk /動/[く/動/]/[か/動/]/[け/動/]/[き/動/]/[こ/動/]/
@end group
@end example

@noindent
のようなエントリが既に@code{skk-jisyo}にあれば、それを破壊しない 
@footnote{@ref{辞書の形式}を参照のこと。}。このユーザーオプションを 
@code{non-nil}にしてSKKモードを起動すると、両立できないオプションである
下記オプションは@code{nil}にセットされる。

@example
@group
@code{skk-kakutei-early}, @c ここに footnote を持ってきても脚注が表われない...
@code{skk-auto-okuri-process}, @code{skk-henkan-okuri-strictly}
@end group
@end example

SKKモード起動後にこのオプションの設定を変更した場合で、カレントバッファ
では既にSKKモードに入っているときは、@kbd{C-x C-j}もしくは@kbd{C-x
j}を2回タイプしてSKKモードを起動し直すことで、これらのユーザーオプショ
ン間の衝突を調整できる。またはメニューバーからこのユーザーオプションをオ
ンにすると、自動的に上記の衝突を調整できる。
@xref{暗黙の確定のタイミング, , skk-kakutei-early}.
@xref{送り仮名の自動処理, , skk-auto-okuri-process}.
@xref{送り仮名の厳密なマッチ, , skk-henkan-okuri-strictly}.

@node カナモードでの変換の送り仮名の処理,  , 送りあり変換の変換開始のタイミング, 送り仮名関連
@comment  node-name,  next,  previous,  up
@subsection カナモードでの変換の送り仮名の処理
@vindex skk-convert-okurigana-into-katakana

カナモードのまま変換を行なうと、見出し語をひらがなに変換してから辞書の検
索を行なうことは前述の通りだが(@pxref{カタカナの見出し語})、カナモードで
送りあり変換を行なうと、

@example
@group
------ Buffer: foo ------
考えル。
------ Buffer: foo ------
@end group
@end example

@noindent
のように送り仮名の第1文字だけが、ひらがなのまま残ってしまう。カナモード
での変換が誤って行なわれた場合はこれで良いことが多いのだが、漢字・カナ混
じり文を書いているときは、送り仮名の第1文字もカタカナ変換された方が便利
である。@code{skk-convert-okurigana-into-katakana}の値を@code{non-nil}
にすることで、カナモードにて送りあり変換を行なった場合、送り仮名の第1文
字もカタカナに変換するようになる。

@node 自動変換開始, 特殊変換, 送り仮名関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 自動変換開始
@vindex skk-auto-henkan-start
@vindex skk-auto-henkan-start-keyword-list
@vindex skk-auto-okuri-process

▽モードで見出し語の入力中に、単語や文節の区切りとなるような文字を打鍵す
ると、▽マークからポイントの直前の文字までを見出し語とし(最後に入力され
た文字は見出し語には含まれない)、@key{SPC}を打鍵することなく自動的に変
換を開始し▼モードに入るようになっている@footnote{某メーカーのMSDOS上の
FEPの仕様を参考にした。}。単語や文節の区切りとなるような文字列は、
@code{skk-auto-henkan-start-keyword-list}にて指定する。

@example
@kbd{K a n j i}

@group
------ Buffer: foo ------
▽かんじ
------ Buffer: foo ------
@end group
@group

@kbd{w o}
------ Buffer: foo ------
▼漢字を
------ Buffer: foo ------
@end group
@end example

@code{skk-auto-okuri-process}を@code{non-nil}にして 送り仮名の自動処
理(@pxref{送り仮名の自動処理})を行なっている場合は、下記のような変換も可
能である(辞書に@samp{できr /出来/[る/出来/]/}というようなエントリがあ
るとして)。

@example
@kbd{D e k i r u n n d e s u}

@group
------ Buffer: foo ------
▽できるんです
------ Buffer: foo ------
@end group
@group

@kbd{.}
------ Buffer: foo ------
▼出来るんです。
------ Buffer: foo ------
@end group
@end example

@code{skk-auto-henkan-start-keyword-list}のディフォルト値は下記の通りで
ある。

@lisp
@group
'("を" "、" "。" "．" "，" "？" "」" "！" "；" "：" ")" ";" 
  ":" "）" "”" "】" "』" "》" "〉" "｝" "］" "〕" "@}"
  "]" "?" "." "," "!" )
@end group
@end lisp

この自動変換開始機能をオフにしたければ、@code{skk-auto-henkan-start}の
値を@code{nil}にする。

@node 特殊変換, 接頭辞・接尾辞, 自動変換開始, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 特殊変換

@menu
* 数値変換::                    数を含む文字列の変換。
* アスキー文字を見出し語とした変換::  アスキー文字を使った省略形からの変換。
* 今日の日付の入力::            今日の日付を一発入力。
* プログラム実行変換::          Emacs Lispプログラムを使った変換。
@end menu

@node 数値変換, アスキー文字を見出し語とした変換, 特殊変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 数値変換
@cindex #0
@cindex #1
@cindex #2
@cindex #3
@cindex #4
@cindex #5
@cindex 数をパラメータとする語の変換[かすをはらめーたとするこのへんかん]
@cindex 数値再変換[すうちさいへんかん]
@vindex skk-numeric-conversion-float-num
@vindex skk-use-numeric-conversion

数をパラメータ(引数)とする語には、@samp{４月１５日}、@samp{第１２回}など
がある。日本語ではこれらを@samp{四月一五日}や@samp{第12回}、@samp{第一二
回}、@samp{第十二回}などとも表現することができるが、これらに別々の辞書見
出しを与えていたのでは変換効率をダウンさせる要因となる。従いSKKでは
@samp{第１２回}というような変換を行ないたい場合には、その数字部分を 
@samp{#}で置き換えた見出し語@samp{第#回}を用いる。

これに対応する辞書のエントリとしては、例えば、

@example
だい#かい /第#0回/第#1回/第#2回/第#3回/
@end example

@noindent
のような文字列を与える。@samp{#}の文字に数字@samp{0}、@samp{1}、
@samp{2}、@samp{3}、@samp{4}、@samp{5}、@samp{9}を加えた文字列は、数字
をタイプ別に表わしたもので、その意味は下記の通りである。

@table @samp

@item #0
タイプ0。無変換。入力されたアスキー文字をそのまま出力する。アスキー文字
による数字のみが必要なのであれば、わざわざ変換することはないが、アスキー
文字の数字の前後に他の文字列をもった組合せ@footnote{例えば、@samp{第12
回}など。}を変換するときに必要となる。

@item #1
タイプ1。全角文字での数字。@samp{12}を@samp{１２}に変換する。

@item #2
タイプ2。漢数字で位取りなし。@samp{5500}は@samp{五五〇〇}に変換する。

@item #3
タイプ3。漢数字で位取りあり。@samp{5500}は@samp{五千五百}に変換する。

@item #4
タイプ4。数値再変換。見出し語中の数字そのもの@footnote{@samp{p125}とい
う見出し語であれば、その数値部分である@samp{125}が再変換の見出し語とな
る。}をキーとして辞書を再検索し@samp{#4}の部分を再検索の結果の文字列で
入れ替える。例を後述する。

@item #5
タイプ5。小切手や手形の金額記入の際用いられる標記で変換する。例えば、
@samp{1995}を@samp{壱阡九百九拾伍}に変換する。

@item #9
タイプ9。将棋の棋譜の入力用。@samp{全角数字 + 漢数字}に変換する。例を後
述する。

@end table
いくつか例を述べる。辞書に

@example
# /#3/
@end example

@noindent
というエントリがあるときに、

@example
@group
@kbd{Q 1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}@footnote{または@kbd{/
1 0 0 2 0 0 3 0 0 4 0 0 5 0 0 @key{SPC}}。}
@end group
@end example

@noindent
とタイプすれば、@samp{百兆二千三億四十万五百}と変換される@footnote{数字
を大文字で入力し始めるわけにはゆかないので@samp{Q}または@samp{/}で▽
モードに入る必要がある。}。

辞書エントリ

@example
#m#d /#0月#0日/
@end example

@noindent
に対し@kbd{/ 2 m 2 5 d @key{SPC}}とタイプすれば、@samp{2月25日}と変換
される@footnote{@samp{m}や@samp{d}などアスキー文字を見出し語として入
力したい場合は@samp{/}キーを最初にタイプしSKK abbrev modeで入力する必
要がある。@xref{アスキー文字を見出し語とした変換, , SKK abbrev mode}.}。

辞書エントリ

@example
#kin /#9金/
@end example

@noindent
に対し、@kbd{/ 3 4 k i n @key{SPC}}とタイプすれば、@samp{３四金}と変換
される。

辞書エントリ

@example
@group
p# /#4/
125 /東京都葛飾区/
@end group
@end example

@noindent
に対し、@kbd{/ p 1 2 5 @key{SPC}}タイプすれば、見出し語@samp{p125}の
候補が@samp{#4}であるので、見出し語の数字部分の@samp{125}に対し辞書
が再検索され、@samp{東京都葛飾区}と変換される。

辞書登録の例を1つ述べる。@samp{２月２５日}を得るために、

@example
@kbd{Q 2 g a t u 2 5 n i t i @key{SPC}}
@end example

@noindent
とタイプしたときに、辞書に見出し語

@example
#がつ#にち
@end example

@noindent
がないときは、辞書登録時のプロンプトは、@w{@samp{#がつ#にち}}となる。全
角数字のタイプは、@samp{#1}なので、@samp{２月２５日}の全角数字部分を 
@samp{#1}で置き換えた文字列@w{@samp{#1月#1日}}をミニバッファで作り登録
する。辞書エントリは、

@example
#がつ#にち /#1月#1日/
@end example

@noindent
となる。

なお、@code{skk-numeric-conversion-float-num}の値を@code{non-nil}にする
と、浮動小数点数を使った見出し語に対応して変換を行なう。但し、その場合は、

@example
#.# /#1．#1/#0月#0日/
@end example

@noindent
などの辞書見出しが使用できなくなるので、注意すること。

数値変換を行ないたくないときは、変数@code{skk-use-numeric-conversion}
の値を@code{nil}にする。

@node アスキー文字を見出し語とした変換, 今日の日付の入力, 数値変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection アスキー文字を見出し語とした変換
@cindex SKK abbrev mode

@dfn{SKK abbrev mode}では、アスキー文字を見出し語とした変換を行なうこと
ができる。

まず、かなモードで@samp{/}を入力することで、見出し語入力の間一時的にこ
のモードに入る。続けて入力する文字は、アスキー文字としてカレントバッファ
に挿入される。見出し語となるアスキー文字を入力し終った時点で@key{SPC}
を押せば、その見出し語についての変換が得られる。仮に、

@example
is /インクリメンタル・サーチ/
@end example

@noindent
というようなエントリが辞書にあるとして、

@example
@kbd{/}

@group
------ Buffer: foo ------
▽
------ Buffer: foo ------
@end group

@kbd{is}

@group
------ Buffer: foo ------
▽is
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼インクリメンタル・サーチ
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
インクリメンタル・サーチ
------ Buffer: foo ------
@end group
@end example

@noindent
のように変換が行なわれる。

入力したアスキー文字をそのまま全角アルファベットに変換したい場合について
は、@ref{全英文字の一時的入力, 全角アルファベットへの変換}を参照のこと。

なお、SKK abbrev modeにおいても見出し語の補完を行なうことができる。
@xref{見出し語の補完}.

@node 今日の日付の入力, プログラム実行変換, アスキー文字を見出し語とした変換, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection 今日の日付の入力
@kindex @@
@vindex skk-date-ad
@vindex skk-number-style
@cindex プログラム実行変換[ふろくらむしつこうへんかん]

かな/カナモードで@kbd{@@}をタイプすれば、今日の日付が入力される。

日付の形式は変数@code{skk-date-ad}と@code{skk-number-style}により決
定される。@code{skk-date-ad}の値が@code{non-nil}であれば西暦で、
@code{nil}であれば元号で表示する。@code{skk-date-ad}のディフォルト値は 
@code{nil}である。

また@code{skk-number-style}には下記の種類がある。

@table @code

@item 0
@itemx nil
半角数字。@samp{1996年7月21日(日)}のようになる。

@item 1
@itemx t
全角数字。@samp{１９９６年７月２１日(日)}のようになる。

@item 2
漢数字。@samp{一九九六年七月二一日(日)}のようになる。

@end table

上記の@samp{1996年}、@samp{１９９６年}、@samp{一九九六年}の例は、いず
れも@code{skk-date-ad}の値が@code{nil}であれば@samp{平成8年}のよう
に元号で表示される。@code{skk-number-style}のディフォルト値は、@samp{1}
である。

L辞書@footnote{@xref{辞書の形式, , L辞書}.}には, 見出し語@samp{today}の
もとに、@code{skk-date-ad}と@code{skk-number-style}の全ての組み合わせ
がプログラム実行変換機能@footnote{@xref{プログラム実行変換}.}を用いて登
録されている。従い、@kbd{/ t o d a y @key{SPC}}とタイプすれば、今日の日
付が上の形式で順次候補として表示される。

@kbd{@@}による日付けの変換入力を行ないたくない場合は、

@lisp
(setq skk-rom-kana-rule-tree
      (append skk-rom-kana-rule-tree
              '(("@@" nil "@@"))))
@end lisp

@noindent
のようにすることにより、アスキー文字の@samp{@@}が挿入されるようになる。
あるいは、全角文字の@samp{＠}を挿入したい場合は、

@lisp
(setq skk-rom-kana-rule-tree
      (append skk-rom-kana-rule-tree
              '(("@@" nil "＠"))))
@end lisp

@noindent
のようにする。

@node プログラム実行変換,  , 今日の日付の入力, 特殊変換
@comment  node-name,  next,  previous,  up
@subsection プログラム実行変換
@cindex @file{skk-gadget.el}
@findex skk-calc

辞書の候補にEmacs Lispのプログラムが書いてあれば、そのプログラムをEmacs
の機能で実行し、返り値をカレントバッファに挿入する。これを@b{「プログラ
ム実行変換」}という。例えば、辞書に

@example
now /(current-time-string)/
@end example

@noindent
というエントリがあるときに@kbd{/ n o w @key{SPC}}とタイプすれば、カレ
ントバッファには@code{current-time-string}の返値である 

@example
Sun Jul 21 06:40:34 1996
@end example

@noindent
のような文字列が挿入される。

実行変換プログラムの返り値は文字列である必要がある。プログラム実行変換の
辞書登録は通常の単語と同様に行なうことができるが、その中に改行を含んでは
ならない。@footnote{通常の単語は、物理的な改行を、評価するとその位置に改
行を挿入するような実行変換プログラムに変換して辞書に書き込んでいる
(@pxref{辞書の形式})が、実行変換プログラムは、そのプログラム中の改行だけ
を取り出して、上記のように改行を表現することができない。}。

今日の日付の入力@footnote{@xref{今日の日付の入力}.}で説明した 
@samp{today}の辞書エントリは下記のような実行変換プログラムとなっている。

@lisp
@group
today /(let ((skk-date-ad) (skk-number-style t)) (skk-today))/@dots{}/
@end group
@end lisp

@file{skk-gadget.el}@footnote{@samp{gadget}は「上手く工夫した道具」の
意味。「色々飛び出す気のきいたおもちゃ箱」というような意味で名付けられた。
余談だが、X Windowで使用される@samp{Widget}という言葉は、
@samp{window}+@samp{gadget}から作られた造語らしい。}には、西暦/元号変換
プログラムや、簡単な計算プログラムなど、実行変換プログラムが集められてい
る。その中の1つを説明する。下記は、引数としてoperatorを取り、見出し語の
数字に対しその演算を行なう簡単な計算プログラムである。

@lisp
@group
(defun skk-calc (operator)
  ;;@r{2つの引数を取って operator の計算をする。}
  ;;@r{注意: '/ は引数として渡せないので (defalias 'div '/) などとし、別の形で}
  ;;@r{skk-calc に渡す。}
  ;;@r{辞書見出し例; #*# /(skk-calc '*)/}
  (int-to-string (apply operator (mapcar 'string-to-int skk-num-list))))
@end group
@end lisp

数値変換@footnote{@xref{数値変換}.}で説明した通り、見出し語における数字
は@samp{#}で表わして辞書登録を行なうので@samp{111*45}のような乗算を
行ないたいときは、

@example
#*# /(skk-calc '*)/
@end example

@noindent
という辞書エントリを用意する。@kbd{Q 1 1 0 * 4 5 @key{SPC}}とタイプした
ときの@samp{111}と@samp{45}の2つの数字は、SKK内部では変換時に 
@code{skk-num-list}に@w{@code{("111" "45")}}のように文字列のリストと
して保存される。このリストの各要素に対し乗算を行ないたいので、各要素を一
旦数値に変換し、その数値にoperatorを適用し、その結果を文字列に変換して返
す、という作業を行なっている。

@node 接頭辞・接尾辞, 暗黙の確定のタイミング, 特殊変換, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 接頭辞・接尾辞
@cindex 接頭辞[せつとうし]
@cindex 接尾辞[せつひし]
@vindex skk-special-midashi-char-list

辞書の見出し語の一部に@samp{>}, @samp{<}, @samp{?}を用いることにより接
頭辞(prefix)、接尾辞(suffix)の入力をサポートしている。例えば、辞書に 

@example
>し /氏/
@end example

@noindent
というエントリーがあるとき、@samp{小林氏}を接尾辞入力を用いて、以下のよ
うに入力することができる(@point{}はポイントを表わす)。

@example
@kbd{K o b a y a s h i}

@group
------ Buffer: foo ------
▽こばやし@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼小林@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
小林▽>@point{}
------ Buffer: foo ------
@end group

@kbd{s i}

@group
------ Buffer: foo ------
小林▽>し@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
小林▼氏@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
小林氏@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
このように入力することで、見出し語@samp{し}に対応する語で、接尾辞になり
得ないものを候補に入れずに辞書が構成可能になるので、候補の絞り込みの点で
有利である。同様に辞書に

@example
ちょう> /超/
@end example

@noindent
というエントリーがあるとき、@samp{超大型}を接頭辞入力を用いて以下のよう
に入力することができる。

@example
@kbd{T y o u}

@group
------ Buffer: foo ------
▽ちょう@point{}
------ Buffer: foo ------
@end group

@kbd{>}

@group
------ Buffer: foo ------
▼超@point{}
------ Buffer: foo ------
@end group

@kbd{O o g a t a}

@group
------ Buffer: foo ------
超▽おおがた@point{}
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
超▼大型@point{}
------ Buffer: foo ------
@end group

@kbd{C-j}

@group
------ Buffer: foo ------
超大型@point{}
------ Buffer: foo ------
@end group
@end example

接頭辞・接尾辞の入力の指定に使用するキーは、
@code{skk-special-midashi-char-list}の値を変更することによりカスタマイ
ズできる。この変数のディフォルト値は、

@lisp
(?> ?< ??)
@end lisp

である。@samp{?}をタイプした時点で接頭辞・接尾辞入力に移行するのではな
く、全角文字@samp{？}を挿入したい場合には@samp{?}を 
@code{skk-special-midashi-char-list}から外して

@lisp
@group
(setq skk-special-midashi-char-list '(?> ?<))
@end group
@end lisp

@noindent
とする。

@node 暗黙の確定のタイミング, リージョン一括変換, 接頭辞・接尾辞, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 暗黙の確定のタイミング
@cindex 暗黙の確定[あんもくのかくてい]
@vindex skk-kakutei-early
@vindex skk-process-okuri-early

標準の設定では、▼モードにおいて印字可能な文字または@key{RET}をタイプ
すると、暗黙の確定が行なわれ直ちに確定する。具体的には下記のようになる。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
確定s
------ Buffer: foo ------
@end group

@kbd{u}

@group
------ Buffer: foo ------
確定す
------ Buffer: foo ------
@end group
@end example

@code{skk-kakutei-early}の値を@code{non-nil}にすることで、暗黙の確定
が行なわれるタイミングを、カッコ類(@samp{(}, @samp{)}, @samp{[},
@samp{]})や句読点(@samp{,}, @samp{.})の入力時、次の変換開始時(@samp{A}
から@samp{Z}までの大文字)、あるいは@key{RET}入力時まで後へずらすこと
ができる。

@example
@kbd{K a k u t e i}

@group
------ Buffer: foo ------
▽かくてい
------ Buffer: foo ------
@end group

@key{SPC}

@group
------ Buffer: foo ------
▼確定
------ Buffer: foo ------
@end group

@kbd{s}

@group
------ Buffer: foo ------
▼確定s
------ Buffer: foo ------
@end group

@kbd{u r u}

@group
------ Buffer: foo ------
▼確定する
------ Buffer: foo ------
@end group

@kbd{.}

@group
------ Buffer: foo ------
確定する。
------ Buffer: foo ------
@end group
@end example

@noindent
区切の良いところまで一気に入力しておき、後で候補を選択する、というような
使い方をするときには便利なユーザーオプションであろう。なおこのユーザーオ
プションは@code{skk-process-okuri-early}とは共存できないので、
@code{skk-process-okuri-early}の値を@code{nil}にしておく必要がある。
メニューバーからこのユーザーオプションをオンにしたときは、これらのユーザー
オプション間の衝突は自動的に調整される。

@node リージョン一括変換, 漢字コード関連, 暗黙の確定のタイミング, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section リージョン一括変換
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@cindex 逆引き[きやくひき]
@findex skk-ascii-region
@findex skk-gyakubiki-katakana-message
@findex skk-gyakubiki-katakana-region
@findex skk-gyakubiki-message
@findex skk-gyakubiki-region
@findex skk-hiragana-region
@findex skk-hurigana-katakana-message
@findex skk-hurigana-katakana-region
@findex skk-hurigana-message
@findex skk-hurigana-region
@findex skk-katakana-region
@findex skk-romaji-message
@findex skk-zenkaku-region
@kindex M-x skk-ascii-region
@kindex M-x skk-gyakubiki-katakana-message
@kindex M-x skk-gyakubiki-katakana-region
@kindex M-x skk-gyakubiki-message
@kindex M-x skk-gyakubiki-region
@kindex M-x skk-hiragana-region
@kindex M-x skk-hurigana-katakana-message
@kindex M-x skk-hurigana-katakana-region
@kindex M-x skk-hurigana-message
@kindex M-x skk-hurigana-region
@kindex M-x skk-katakana-region
@kindex M-x skk-romaji-message
@kindex M-x skk-zenkaku-region
@vindex skk-romaji-*-by-hepburn

下記のコマンドを@kbd{M-x}により呼ぶことでリージョン一括変換を行なうこ
とができる。変換の種類と対応するコマンドは以下の通り。

@table @asis

@item カタカナをひらがなへ変換。
@kbd{M-x skk-hiragana-region}

@item ひらがなをカタカナへ変換。
@kbd{M-x skk-katakana-region}

@item 全英文字をアスキー文字へ変換。
@kbd{M-x skk-ascii-region}

@item アスキー文字を全英文字へ変換。
@kbd{M-x skk-zenkaku-region}

@item 漢字をひらがなへ変換。
@kbd{M-x skk-gyakubiki-region}具体的な変換例をあげると、

@example
``漢字をひらがなへ変換。''@expansion{}``かんじをひらがなへへんかん。''
@end example

@noindent
のようになる。引数を渡して、@kbd{C-u M-x skk-gyakubiki-region}のように
することで、複数の候補がある場合は、`@{@}' でくくって表示する。例えば、

@example
``中島''@expansion{}``@{なかしま|なかじま@}''
@end example

@noindent
のようになる。送り仮名がある語は、送り仮名まで含めてリージョンに指定しな
いと誤変換の原因となる。例えば、@samp{五月蝿い}について、送り仮名
@samp{い}を含めずにこのコマンドを実行すると、@samp{ごがつはえ}に変換さ
れてしまう。

@item 漢字をカタカナへ変換。
@kbd{M-x skk-gyakubiki-katakana-region}具体的な変換例は上記を参照のこ
と。引数を渡して、@kbd{C-u M-x skk-gyakubiki-katakana-region}のようにす
ることで、複数の候補がある場合は、`@{@}' でくくって表示する。

@item 漢字にふりがなを付ける。
@kbd{M-x skk-hurigana-region}具体的には例えば、

@example
``漢字の脇に''@expansion{}``漢字[かんじ]の脇[わき]に''
@end example

@noindent
のようにふりがなが振られる。引数を渡して、@kbd{C-u M-x
skk-hurigana-region}のようにすることで、複数の候補がある場合は、
`@{@}' でくくって表示する。

@item 漢字にカタカナのふりがなを付ける。
@kbd{M-x skk-hurigana-katakana-region}変換例は、上記を参照のこと。引
数を渡して、@kbd{C-u M-x skk-hurigana-katakana-region}のようにすること
で、複数の候補がある場合は、`@{@}' でくくって表示する。

@item 漢字、ひらがな、カタカナ、全英文字を全てローマ字へ変換。
@kbd{M-x skk-romaji-region}ディフォルトでは、ローマ字への変換様式にヘ
ボン式を用いる。例えば、

@example
``し''@expansion{}``shi''
@end example

@noindent
@code{skk-romaji-*-by-hepburn}の値を@code{nil}にすると、訓令式(「日本
式」とも言うようだ)を用いる。例えば、

@example
``し''@expansion{}``si''
@end example

@noindent
昭和29年12月9日付内閣告示第一号によれば、原則的に訓令式(日本式)を用いる
かのように記載されているが、今日一般的な記載方法は、むしろ、ヘボン式であ
るように思う。

@end table

メニューバーが使用できる環境では、メニューバーを使ってこれらの一括変換コマ
ンドを起動することができる。
@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.

上記の内、最後の5つについては、KAKASIがインストールされていなければ使用
することができない。@xref{KAKASI}.

また、KAKASI関連コマンドと同様の変換を行なうが、リージョンの文字列を置き
換えるのではなく、変換結果をエコーエリアに表示するコマンドがある。コマン
ド名のみ紹介する。上述のリージョン一括変換コマンドの説明と下記のコマンド
名から容易に動作を想像することができるであろう。引数を渡してコールした場
合の動作も同様である。

@itemize @bullet

@item @kbd{M-x skk-gyakubiki-message}

@item @kbd{M-x skk-gyakubiki-katakana-message}

@item @kbd{M-x skk-hurigana-message}

@item @kbd{M-x skk-hurigana-katakana-message}

@item @kbd{M-x skk-romaji-message}

@end itemize

@node 漢字コード関連, ▼モードの特殊キー, リージョン一括変換, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 漢字コード関連

@menu
* 漢字コードまたはメニューによる文字入力::  
* 漢字コードを知る方法::        
@end menu

@node 漢字コードまたはメニューによる文字入力, 漢字コードを知る方法, 漢字コード関連, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードまたはメニューによる文字入力
@cindex JISコード
@cindex EUCコード
@kindex @samp{\}

@samp{\}キーをタイプすることにより、漢字コード(JISまたはEUCコード) ま
たはメニューによる文字入力が可能となる。ミニバッファには、
@w{@samp{JIS or EUC code (00nn or CR for Jump Menu): }}というプロンプト
が出る。

漢字コードが予め分っている場合にはそのプロンプトに対し、漢字コードを入力
する。例えば@samp{℃}の漢字コードは、JIS コードでは@samp{216e}、EUCコー
ドでは@samp{a1ee}なので、いずれかの漢字コードを入力すれば@samp{℃}がカレ
ントバッファに挿入される。

漢字コードが不明の文字の入力には2段階メニューを用いた入力が可能である。
プロンプトに対し@key{RET}キーをタイプすると、第1段階のメニューが次のよう
に表示される。

@example
@group
A:　  S:￣  D:〜  F:｝  G:＝  H:¢  Q:◆  W:  E:∩  R:  T:≡  Y:  
@end group
@end example

第1段階のメニューでは、JIS漢字をコードの順に16文字毎に1文字抽出し、ミニ
バッファに一度に12文字づつ表示される。上記の例では、JISコード 
@samp{2121}の全角スペースが@samp{A:　}として、以下@samp{2131}、
@samp{2141}、@samp{2151}@dots{}の文字がそれぞれ@samp{B:￣}、
@samp{C:〜}、@samp{D:｝}@dots{}として表示される。ここで@key{SPC}をタ
イプすると、漢字コードの値を@w{16x12 @equiv{}192}づつ増やし次の候補群
を表示する。@samp{x}により1つ前の候補群に戻ることができる。

メニューのキー@samp{a}, @samp{s}, @samp{d}, @samp{f}, @samp{g},
@samp{h}, @samp{q}, @samp{w}, @samp{e}, @samp{r}, @samp{t}, @samp{y}の
いずれかをタイプすれば@footnote{大文字でも小文字でも可。}、そのキーに対
応する文字から始まる16個の文字が漢字コード順に表示される。これを第2段階
のメニューという。例えば、第1段階のメニューが上記の状態のときに@samp{d}
をタイプすると第2段階のメニューは以下のようになる。

@smallexample
@group
A:〜 S:‖ D:｜ F:… G:‥ H:‘ J:’ K:“ L:” Q:（ W:） E:〔 R:〕 T:［ Y:］ U:｛ 
@end group
@end smallexample

第2段階のメニュー中のキーをでタイプすると、対応する文字がカレントバッファ
に挿入されてメニューによる入力が終了する。第2段階のメニューが表示されて
いるときも@key{SPC}と@samp{x}キーで第2段階のメニューを前進、後退させ
ることができる。また@samp{<}、@samp{>}によりメニューを1文字分だけずら
すことができる。例えば、第2段階のメニューが上記の状態のときに@samp{<}
をタイプすると、メニューは以下のようになる。

@smallexample
@group
A:＼ S:〜 D:‖ F:｜ G:… H:‥ J:‘ K:’ L:“ Q:” W:（ E:） R:〔 T:〕 Y:［ U:］
@end group
@end smallexample

第1段階あるいは第2段階のメニューが表示されているときに@samp{?}をタイプ
すると、そのときのキー@samp{A}に対応する文字(上記の例では、@samp{＼}) 
の文字コードが表示される。第1段階も第2段階もメニューのメニューのキーは、
ユーザーが変更することができる。これについては、@ref{候補の選択に用いる
キー}を参照のこと。

@node 漢字コードを知る方法,  , 漢字コードまたはメニューによる文字入力, 漢字コード関連
@comment  node-name,  next,  previous,  up
@subsection 漢字コードを知る方法
@kindex @samp{$}
@cindex JISコード
@cindex EUCコード

かな/カナモードで@samp{$}をタイプすれば、ポイントにある漢字コードをミ
ニバッファに表示する。例えば、カーソルを文字@samp{А}の上に置いて 
@samp{$}をタイプすると

@example
『А』  EUC: a7a1 (167, 161), JIS: 2721 ( 39,  33)
@end example

@noindent
がエコーエリアに表示され、この文字がロシア文字であることがわかる。

@node ▼モードの特殊キー, 辞書関連, 漢字コード関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section ▼モードの特殊キー

@menu
* 確定動作を行なうキー::        
* 候補の選択に用いるキー::      
* ▼モードでのRET::             
* ▼モードでのBS::              
* 送りあり変換中のC-g::         
@end menu

@node 確定動作を行なうキー, 候補の選択に用いるキー, ▼モードの特殊キー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 確定動作を行なうキー
@vindex skk-kakutei-key
@kindex C-j

明示的な確定動作は@code{skk-kakutei-key}の値により指定されるキーにより
行なわれる。標準設定ではその値は ``\C-j'' となっている。


@node 候補の選択に用いるキー, ▼モードでのRET, 確定動作を行なうキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 候補の選択に用いるキー
@vindex skk-henkan-show-candidates-keys
@vindex skk-input-by-code-menu-keys1
@vindex skk-input-by-code-menu-keys2

変換において、候補が5つ以上あるときは5番目以降の候補は7つずつまとめてエ
コーエリアに下記のように表示される@footnote{@xref{▼モード}.}。

@example
@group
-------------------- Echo Area --------------------
A:嘘  S:拒  D:拠  F:虚  J:挙  K:許  L:渠  [残り 2]
-------------------- Echo Area --------------------
@end group
@end example

この際、候補の選択に用いるキーは、
@code{skk-henkan-show-candidates-keys}に7つのchar typeのキーを持つリス
トを代入して変更できる。ディフォルト値は、下記の通りである。

@lisp
'(?a ?s ?d ?f ?j ?k ?l)
@end lisp

このリストには7つの小文字のchar typeのキーを含まなければならない。
@samp{x}, @key{SPC}及び@kbd{C-g}は、それぞれ候補選択中における前候補
群の表示、次候補群の表示、取り止めのために割り付けられているので、
@code{skk-henkan-show-candidates-keys}の中に含めてはならない。

メニューによる文字入力
@footnote{@xref{漢字コードまたはメニューによる文字入力}.}の際に候補の選
択に用いられるキーは、下記の2変数により変更することができる。

@table @code

@item skk-input-by-code-menu-keys1
第1段階のメニューにおける候補の選択キー。

@item skk-input-by-code-menu-keys2
第2段階のメニューにおける候補の選択キー。

@end table

@code{skk-input-by-code-menu-keys1}のディフォルト値は、

@lisp
'(?a ?s ?d ?f ?g ?h ?q ?w ?e ?r ?t ?y)
@end lisp

@noindent
である。このリストには12個の文字のchar typeのキーを含む必要がある。

また@code{skk-input-by-code-menu-keys2}のディフォルト値は、

@lisp
'(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u)
@end lisp

@noindent
である。このリストには16個の文字のchar typeのキーを含む必要がある。
@code{skk-input-by-code-menu-keys1}と 
@code{skk-input-by-code-menu-keys2}に共通であるが、このリストに小文字が
指定された場合は、候補の選択の際にユーザーにより該当の大文字キーが入力さ
れても候補の選択が可能となるようにSKK内部で処理されるが、このリストに大
文字が指定された場合、ユーザーにより該当の小文字キーが入力されても候補の
選択ができなくなってしまう。いずれのリストにも小文字で指定することをお勧
めする。

@node ▼モードでのRET, ▼モードでのBS, 候補の選択に用いるキー, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{RET}
@vindex skk-egg-like-newline

標準設定では、

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定
@point{}
------ Buffer: foo ------
@end group
@end example

@noindent
のように、▼モードで@key{RET}を入力すると、確定し、かつ改行を行なうが、
@code{skk-egg-like-newline}の値を@code{non-nil}にすると、確定するのみ
で改行しない。

@example
@kbd{K a k u t e i @key{SPC}}

@group
------ Buffer: foo ------
▼確定@point{}
------ Buffer: foo ------
@end group

@key{RET}

@group
------ Buffer: foo ------
確定@point{}
------ Buffer: foo ------
@end group
@end example

辞書登録モードにおいて▼モードであるとき、@key{RET}の入力により確定動作
と辞書登録動作が同時に行なわれたが、@code{skk-egg-like-newline}の値が 
@code{non-nil}であるときは、確定はするが改行しないので、結果的に辞書登
録動作のためにもう一度@key{RET}を入力する必要がある。辞書登録モードに
おけるディフォルトの確定、登録の動作については、@ref{辞書登録モード}を参
照のこと。

@node ▼モードでのBS, 送りあり変換中のC-g, ▼モードでのRET, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection ▼モードでの@key{BS}
@vindex skk-delete-implies-kakutei
@kindex @key{BS}

標準設定では、▼モードで@key{BS}を押すと、前の一文字を削除し確定する。

@example
@kbd{D e n k i y a @key{SPC}}

@group
------ Buffer: foo ------
▼電気屋
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
電気
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-implies-kakutei}の値を@code{non-nil}にすると、一つ前
の候補を表示する。例えば、

@example
でんき /電気/伝記/
@end example

@noindent
という辞書エントリがあったとすると、下記のようになる。

@example
@kbd{D e n k i @key{SPC}@key{SPC}}

@group
------ Buffer: foo ------
▼伝記
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▼電気
------ Buffer: foo ------
@end group

@key{BS}

@group
------ Buffer: foo ------
▽でんき
------ Buffer: foo ------
@end group
@end example

@node 送りあり変換中のC-g,  , ▼モードでのBS, ▼モードの特殊キー
@comment  node-name,  next,  previous,  up
@subsection 送りあり変換中の@kbd{C-g}
@kindex C-g
@vindex skk-delete-okuri-when-quit

送りありの変換中に@kbd{C-g}をタイプすると、▼モードを抜け、その見出し
語と送り仮名をカレントバッファに挿入し、■モードに入る。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
なく
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-okuri-when-quit}の値を@code{non-nil}にすれば 
@kbd{C-g}のタイプにより送り仮名を消す。例えば、下記のようになる。

@example
@kbd{N a K u}

@group
------ Buffer: foo ------
▼泣く
------ Buffer: foo ------
@end group

@kbd{C-g}

@group
------ Buffer: foo ------
▽な
------ Buffer: foo ------
@end group
@end example

@code{skk-delete-okuri-when-quit}の値を@code{non-nil}にすることにより
そのままの状態で送り仮名の再入力が可能となるので、送り仮名の入力間違いを
犯しやすい人には便利であろう。

@node 辞書関連, デコレーション, ▼モードの特殊キー, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section 辞書関連

@menu
* 個人辞書中の単語の削除::      
* 個人辞書の保存動作::          
* 変換及び個人辞書に関する統計::  
* 辞書エントリの数えあげ::      
* 辞書バッファの文字コードの設定::  
* 辞書バッファのメジャーモード::  
* 辞書バッファのbuffer-file-name::  
@end menu

@node 個人辞書中の単語の削除, 個人辞書の保存動作, 辞書関連, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書中の単語の削除
@cindex 個人辞書エントリの削除[こしんししよのえんとりのさくしよ]
@cindex 誤登録[ことうろく]

誤まって個人辞書@footnote{@xref{辞書の形式, 個人辞書}.}に登録した単語の
削除は、削除したい単語を変換により求め、その単語が得られた時点で@samp{X}
を入力する。ミニバッファに確認のプロンプトが出るので、それに対し@kbd{y
e s}とタイプしたとき個人辞書の対応するエントリが削除され、カレントバッ
ファに削除のために一旦変換した単語も削除される。

@example
さいきてき /再起的/
@end example

@noindent
というエントリを誤って登録したという仮定で、その誤登録を削除する場合を例
にとって説明する。

@example
@kbd{S a i k i t e k i @key{SPC}}

@group
------ Buffer: foo ------
▼再起的
------ Buffer: foo ------
@end group

@samp{X}

@group
------------------ MiniBuffer ------------------
Really purge ``さいきてき /再起的/''?(yes or no)
------------------ MiniBuffer ------------------
@end group

@kbd{y e s @key{RET}}

@group
------ Buffer: foo ------

------ Buffer: foo ------
@end group

@end example

@node 個人辞書の保存動作, 変換及び個人辞書に関する統計, 個人辞書中の単語の削除, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 個人辞書の保存動作
@cindex 個人辞書[こしんししよ]
@cindex 個人辞書のオートセーブ[こしんししよのおーとせーふ]
@kindex C-x C-c

個人辞書の保存動作について述べる。個人辞書の保存を行なうのは、次の 3 通
りの場合がある。

@enumerate

@item
@kbd{C-x C-c}(または@kbd{M-x save-buffers-kill-emacs}) によりEmacsを終
了させようとした場合。

@item
@kbd{M-x skk-save-jisyo}とタイプするか、メニューバーにより
@samp{Save Jisyo}を選択した場合。

@item
@code{skk-jisyo-save-count}で指定された回数辞書のアップデートを行なった
場合にオートセーブ機能が働くとき。

@end enumerate
保存動作を分解すると、まず Emacs に読み込んだ個人辞書が更新されているか
どうかを調べ、更新されていたら保存動作に入る。Emacs の個人辞書バッファを
一時ファイルに保存して、そのサイズが現存の(セーブ前の)@code{skk-jisyo}よ
り小さくないかどうかをチェックする。一時ファイルのサイズが0である場合は
直ちに保存動作を中止するので、

@lisp
@kbd{M-x skk-kill-emacs-without-saving-jisyo}
@end lisp

@noindent
でEmacsを終了させ@code{skk-jisyo}, @code{skk-backup-jisyo}をチェック
すべきである(@code{skk-jisyo}が既につぶれており、
@code{skk-backup-jisyo}につぶれる前の個人辞書が残っているかもしれない)。
一時ファイルのサイズが0でなく、かつ@code{skk-jisyo}のそれより小さいと
きはミニバッファにプロンプトを出して保存動作を継続するかどうかユーザーに
確認を求める。

@example
@group

--------------------------- Minibuffer -----------------------------
New ~/.skk-jisyo will be 11bytes smaller.  Save anyway?(yes or no)
--------------------------- Minibuffer -----------------------------

@end group
@end example

@noindent
ここで@kbd{n o @key{RET}}とタイプした場合は、そこで保存動作が中止され
るので@code{skk-jisyo}はセーブする前の状態のままである。@kbd{y e s
@key{RET}}とタイプした場合は@code{skk-backup-jisyo}を削除し、元の 
@code{skk-jisyo}を@code{skk-backup-jisyo}にリネームし、最後に一時ファ
イルに保存した新しい個人辞書を@code{skk-jisyo}にリネームする。

通常の使用の範囲では@kbd{M-x skk-purge-from-jisyo}した場合、あるいは個
人辞書をユーザーが意図的に編集した場合に、個人辞書が小さくなる可能性があ
るぐらいで、他の場合はバグ以外には考えにくい。

個人辞書の保存時のサイズ比較の機能は、主に開発者が新機能の追加したときの
バグで個人辞書を失なわないように自己防衛の目的で開発されたので、SKKが安
定している状態では不要な機能であるかもしれない。
@code{skk-compare-jisyo-size-when-saving}の値を@code{nil}にすると、一
時ファイルが0であるかどうかのみのチェックを行ない、セーブ前の 
@code{skk-jisyo}とのサイズ比較は行なわない。

個人辞書のオートセーブは@code{skk-jisyo-save-count}で指定された回数、
個人辞書のアップデートを行なった場合に行なわれる。個人辞書のアップデート
回数は確定回数でもある。同じ候補について確定した場合でもそれぞれ1回とカ
ウントされる。これは、個人辞書のミニマムポイント@footnote{送りあり変換
では@w{@code{skk-okuri-ari-min}+ 1}の位置、送りなし変換では
@w{@code{skk-okuri-nasi-min}+ 1}の位置がそれぞれミニマムポイントになる。}
に常に最後に変換を行なったエントリを移動させるために@footnote{厳密に言
えば、同じ見出し語、同じ候補について続けて2度以上確定した場合は、該当す
るエントリを移動させる必要はないのだが、現実の処理としては、移動させよう
とするエントリがミニマムポイントにあるかどうかのチェックを省いているので、
結果的には該当するエントリを一度削除してから同じ場所にそれを挿入している
こととなる。従い、アップデート回数としては、同じ見出し語、同じ候補につい
て続けて2度確定した場合は、それぞれ1回(合計2回)として数えている。同じ見
出し語、同じ候補について連続して変換する場合がそれほど頻度としては多くな
いこと、チェックをしようとした場合は、見出し語がミニマムポイントにあるか
どうかのチェックに加えて、移動しようとするエントリの候補群の並びが最後の
変換時のそれと変わらないかどうか---異なる場合は見出し語の位置は同じでも
候補群の順序を変更するために削除する必要がある---をチェックしなければな
らないこと、の2点から、個人辞書中の最後に変換した見出し語のエントリを削
除すべきかどうか、のチェックをしない方が全体的な効率が良いと考えている。}、
エントリ数、候補数が全く増えていなくとも、確定により個人辞書が更新されて
いるからである。@code{skk-jisyo-save-count}のディフォルト値は、50である。
@code{skk-jisyo-save-count}の値を@code{nil}にすることで、オートセーブ
を一切行なわないようにすることができる。

@node 変換及び個人辞書に関する統計, 辞書エントリの数えあげ, 個人辞書の保存動作, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 変換及び個人辞書に関する統計
@cindex skk-keep-record
@cindex skk-record-file
@vindex skk-count-private-jisyo-candidates-exactly

Emacsの終了時にSKKの変換及び個人辞書に関する統計が取られ、
@file{~/.skk-record}に保存される。保存される内容は下記のような形式であ
る。

@example
@group
Sun Jul 28 09:38:59 1996  登録:   4  確定:  285  確定率:  98%  語数:  3042
@end group
@end example

統計の保存のためのファイルは@code{skk-record-file}で指定できる。また、
統計を取るのをやめたければ@code{skk-keep-record}を@code{nil}にする。

なお、上記の「語数」の欄は1行を1語としてカウントしているので1つの見出し
語に対し複数のエントリを持っている場合、2つ目以降の候補を無視しているが 
@code{skk-count-private-jisyo-candidates-exactly}の値を@code{non-nil}
にすることで、その分余計に時間はかかるが、正確に語数をカウントすることが
できる。なお、この場合でも@samp{[}と@samp{]}に囲まれた送り仮名毎のブ
ロック内は数えない。

@node 辞書エントリの数えあげ, 辞書バッファの文字コードの設定, 変換及び個人辞書に関する統計, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書エントリの数えあげ
@cindex Menu Bars
@cindex メニューバー[めにゆーはー]
@findex skk-count-jisyo-candidates
@kindex M-x skk-count-jisyo-candidates
@vindex skk-large-jisyo

@kbd{M-x skk-count-jisyo-entries}により辞書エントリを数えることができる。

@example
@group

@kbd{M-x skk-count-jisyo-entries}

--------------- MiniBuffer --------------
File: (default: /your/home/.skk-jisyo) ~/
--------------- MiniBuffer --------------
@end group
@group

@kbd{. s k k - j i s y o @key{RET}}

-------------- Echo Area --------------
Counting jisyo candidates... 100% done
-------------- Echo Area --------------
@end group

@group

------ Echo Area ------ 
3530 entries
------ Echo Area ------
@end group
@end example

@samp{[}と@samp{]}に囲まれた送り仮名毎のブロック内は数えない。

メニューバーが使用できる環境では、メニューバーを使ってこのコマンドを起動
することができる。
@xref{Menu Bars, ,メニューバー, emacs, GNU Emacs Manual}.

@node 辞書バッファの文字コードの設定, 辞書バッファのメジャーモード, 辞書エントリの数えあげ, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの文字コードの設定
@vindex skk-jisyo-code

@code{skk-jisyo-code}の値により辞書ファイルの漢字コードを設定するこ
とができる。@w{``euc''}, @w{``ujis''}, @w{``sjis''}, @w{``jis''}などの
文字列の他@w{@code{*euc-japan*}}, @w{@code{*sjis*}}, @w{@code{*junet*}}
などのシンボルを指定することもできる。

@code{skk-jisyo-code}の値をディフォ値である@code{nil}にしておくと、
SKK側で辞書漢字コードの設定に関する動作は行なわない@footnote{Emacs側の機
能に依存する。}。

@node 辞書バッファのメジャーモード, 辞書バッファのbuffer-file-name, 辞書バッファの文字コードの設定, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファのメジャーモード
@cindex @file{dabbrev.el}
@cindex @samp{ *SKK-JISYO.L*}
@cindex fundamental-mode
@findex skk-search-jisyo-file
@findex skk-search-kakutei-jisyo-file
@findex skk-search-server
@vindex SKK辞書
@vindex mode-name
@vindex skk-jisyo-mode
@vindex skk-large-jisyo
@cindex 辞書バッファのネーミング規則[ししよはつふあのねーみんくきそく]

各辞書を@code{skk-search-kakutei-jisyo-file}もしくは 
@code{skk-search-jisyo-file}によりEmacsのバッファに辞書を取り込んだとき
(あるいは@code{skk-search-server}により検索していたが、サーバーと接続
できなってバッファに取り込んだとき)は、辞書バッファの名前は、空白
+@samp{*}+辞書ファイル名(ディレクトリ抜き)+@samp{*}という規則に基づき付
けられる。例えば、@code{skk-large-jisyo}に代入されているファイル名が 
@w{@file{/usr/local/libexec/emacs/19.33/etc/SKK-JISYO.L}}であると、これ
に対する辞書バッファ名は、@w{@samp{ *SKK-JISYO.L*}}となる。このバッファ
のメジャーモードの実体は@code{fundamental-mode}であるが、メジャーモー
ド名に@code{skk-jisyo-mode}、@code{mode-name}に``SKK辞書''を代入してい
る。

これは、@file{dabbrev.el}において、カレントバッファと同じモードの他のバッ
ファをサーチしてdabbrevを行なうように設定することができるのだが、仮に辞
書バッファが@code{fundamental-mode}のままであるとすると、
@code{fundamental-mode}においてdabbrevを行なったときに、dabbrevのために
辞書バッファを検索することになるためである。動的な補完を行なうこのパッケー
ジの主旨から言って、辞書バッファを検索することは適当でないと考えるからで
ある。

@code{mode-name}に``SKK辞書''を代入していることについては必然性がないが、
メジャーモードを@code{skk-jisyo-mode}に変更しているのに 
@code{mode-name}が@code{fundamental-mode}のままでは、辞書バッファをの
ぞく好奇心旺盛なユーザーにとって混乱の種になるのではないかと考えたからで
ある。

@node 辞書バッファのbuffer-file-name,  , 辞書バッファのメジャーモード, 辞書関連
@comment  node-name,  next,  previous,  up
@subsection 辞書バッファの@code{buffer-file-name}
@vindex buffer-file-name
@cindex save-some-buffers
@vindex skk-jisyo

個人辞書の保存は、前述した通り、一旦一時ファイルに保存し、そのサイズを古
い個人辞書のものと比較し、その後古い個人辞書をバックアップ辞書に退避して、
一時ファイルを個人辞書にリネームする、という複雑な一連の動作をしており、
単に@code{buffer-file-name}に依存して読み込んだファイルを保存するもの
ではない。@xref{個人辞書の保存動作}.

一方、@code{buffer-file-name}が@code{non-nil}になっている、特定のファ
イルと紐付きになっているバッファがあって、@kbd{M-x compile}など内部で 
@code{save-some-buffers}をコールしているコマンドを使ったとすると、一々
その未セーブのバッファをセーブするかどうかをユーザーに尋ねる機能がEmacs
には備えられている。仮に個人辞書のバッファが特定のファイルと紐付きになっ
ていると、@code{save-some-buffers}がコールされる度に個人辞書のバッファ
をセーブするかどうかを尋ねられてしまう。

SKKバージョン10では、@code{buffer-file-name}に@code{skk-jisyo}指定の
ファイルを代入していないので、個人辞書のバッファは、
@code{save-some-buffers}の対象でもなくなり、ユーザーがSKK以外のパッケー
ジから個人辞書バッファのセーブを尋ねられることはない。

この変更に従い、辞書バッファについては、特定のファイルとの関係がなくなっ
たので、辞書バッファを編集を行なうユーザーには注意すべき点がある。具体的
に言えば、辞書バッファに読み込まれた個人辞書以外の辞書
(@code{skk-large-jisyo}, @code{skk-aux-large-jisyo},
@code{skk-kakutei-jisyo}, @code{skk-initial-search-jisyo}) を、ユーザー
が辞書バッファに入り込んで編集した後、@kbd{C-x C-c}
(@code{save-buffers-kill-emacs})すると、Emacsからセーブするかどうかの確
認を求められることなく編集した辞書バッファが捨てられる(つまり辞書ファイ
ルは未編集のままの状態である)。どうしてもその編集した辞書バッファを保存
したければ、明示的に@kbd{C-x C-s}(@code{save-buffer}) か、もしくは 
@kbd{C-x C-w}(@code{write-file}) でファイル名指定してやれば保存すること
は可能だが、保存後そのバッファは、保存時に指定したファイルが新たに 
@code{buffer-file-name}に代入されるので、SKKの辞書バッファではなく、そ
のファイルそのものをオープンされている状態となる
(@pxref{辞書バッファのメジャーモード, , 辞書バッファのネーミング規則}。)。
従いその後、その辞書バッファを@code{skk-search-jisyo}で検索すると再び
読み込まれてしまう。再読み込みによる不都合は、メモリ消費以外には特にない。

@node デコレーション, VIP/VIPERとの併用, 辞書関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section デコレーション

@menu
* 仮名文字のローマ字プレフィックスのエコー::  
* 入力モードを示すモードラインの文字列の変更::  
* 入力モードを示すカーソル色に関する設定::  
* ▼モードにおける変換候補のハイライト表示::  
* エラーなどの日本語表示::      
@end menu

@node 仮名文字のローマ字プレフィックスのエコー, 入力モードを示すモードラインの文字列の変更, デコレーション, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 仮名文字のローマ字プレフィックスのエコー
@vindex skk-echo

@code{skk-echo}により仮名文字のローマ字プレフィックス
@footnote{@xref{辞書の形式, ローマ字プレフィックス}.}のエコーの有無を調
整できる。@code{skk-code}が@code{non-nil}であれば、仮名文字のローマ字
プレフィックスが入力時点で一旦カレントバッファに挿入され、続く母音の入力
により、かな文字に変換された時点でカレントバッファから消去される。

@example
@group
@kbd{t}

------ Buffer: foo ------
t
------ Buffer: foo ------

@end group
@group
@kbd{a}

------ Buffer: foo ------
た
------ Buffer: foo ------
@end group
@end example

@code{skk-echo}の値を@code{nil}にすると、仮名文字のローマ字プレフィッ
クスのエコーは行なわれなくなる。上記の例では@samp{t}がカレントバッファ
に挿入されることはなくなり、ローマ字1文字が完成する母音@samp{a}が入力
される直前にいきなり@samp{た}の文字が挿入される。

@node 入力モードを示すモードラインの文字列の変更, 入力モードを示すカーソル色に関する設定, 仮名文字のローマ字プレフィックスのエコー, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すモードラインの文字列の変更

下記の変数の値を変更することにより入力モードを示すモードラインの文字列を
変更することができる。

@vtable @code

@item skk-latin-mode-string
アスキーモードを示す文字列。ディフォルト値は、``--SKK:''。

@item skk-hirakana-mode-string
かなモードを示す文字列。ディフォルト値は、``--かな''。

@item skk-katakana-mode-string
カナモードを示す文字列。ディフォルト値は、``--カナ''。

@item skk-jisx0208-latin-mode-string
全英モードを示す文字列。ディフォルト値は、``--全英''。

@end vtable

@node 入力モードを示すカーソル色に関する設定, ▼モードにおける変換候補のハイライト表示, 入力モードを示すモードラインの文字列の変更, デコレーション
@comment  node-name,  next,  previous,  up
@subsection 入力モードを示すカーソル色に関する設定
@vindex minibuffer-setup-hook
@vindex skk-report-set-cursor-error

カラーディスプレイを使用し、カラー表示をサポートしているWindow System下
で対応するEmacsを使用している場合には、入力モードの変更に合わせてカーソ
ル色が変更される@footnote{@samp{-nw}オプションを指定してEmacsを起動した場
合は、この機能が使えない。}。この機能を使用したくない場合は、
@code{skk-use-color-cursor}の値を@code{nil}にする。

@code{skk-use-color-cursor}の値が@code{non-nil}の場合は、入力モードを
示すカーソル色は、下記の変数によって決定されるので、これらの変数の値を変
更することにより、カーソル色を変更することができる。

@vtable @code

@item skk-default-cursor-color
SKKモードがオフであることを示すカーソル色。カーソルのある該当フレームに
おけるディフォルトのカーソル色が代入される。

@item skk-hiragana-cursor-color
かなモードであることを示すカーソル色。ディフォルト値は、reverseVideoが
offのときは``coral4''onのときは``pink''。

@item skk-katakana-cursor-color
カタカナモードであることを示すカーソル色。ディフォルト値は、reverseVideo
がoffのときは``forestgreen''onのときは``green''。

@item skk-jisx0208-latin-cursor-color
全角英字モードを示すカーソル色。ディフォルト値は、``gold''。

@item skk-latin-cursor-color
アスキーモードを示すカーソル色。ディフォルト値は、reverseVideoがoffのと
きは``ivory4''onのときは``gray''。

@end vtable

カーソル色の変更の際、カラーマップ切れが起きた場合にはエラーメッセージを
表示し、ディフォルトのカーソル色を使う。このエラーメッセージの表示を止め
るには、@code{skk-report-set-cursor-error}の値を@code{nil}にする。

@node ▼モードにおける変換候補のハイライト表示, エラーなどの日本語表示, 入力モードを示すカーソル色に関する設定, デコレーション
@comment  node-name,  next,  previous,  up
@subsection ▼モードにおける変換候補のハイライト表示
@cindex @file{canna.el}
@cindex @file{rgb.txt}
@cindex Overlays
@cindex Extent
@cindex Text Properties
@cindex face
@findex hilit-lookup-face-create
@vindex canna:attribute-alist
@vindex skk-henkan-face
@vindex skk-use-face

@c XEmacs の extent について言及する。
@code{skk-use-face}が@code{non-nil}の場合、@code{skk-henkan-face}に
指定されたface属性をもって変換候補をハイライト表示する。このハイライト表
示はEmacsのOverlaysの機能を使っている@footnote{以前のバージョンではText
Propertiesを使用していたが、@file{egg.el}, @file{canna.el},
@file{wnn-egg.el}を参考にしてOverlaysを使用するように変更した。Overlays
は、テキストの一部ではないので、Overlaysのかかったテキストから文字を切り
出してもコピーの対象にならないし、アンドゥ時も無視されるので、変換された
候補の表示を一時的に変更するにはText Propertiesよりも好都合なためであ
る。}。@code{skk-henkan-face}のディフォルト値は、@code{highlight}であ
る。Emacs標準フェイスの@samp{default}, @samp{modeline}, @samp{region},
@samp{secondary-selection}, @samp{highlight}, @samp{underline},
@samp{bold}, @samp{italic}, @samp{bold-italic}@footnote{@samp{default}
以外のface上で変換を行なっている場合は、変換によりfaceを@samp{default}
に変更しても意味があろうが、通常はそのようなケースは稀であるので、
@samp{default}faceを利用することはまずないであろう。}の他、新たにfaceを
作り、利用することも可能。

新たな face を作り指定するには skk-make-face を利用して、

@example
@group
(setq skk-henkan-face (skk-make-face 'DimGray/PeachPuff1))
@end group
@end example

のようにするのが手軽。この例では、foreroundがDimGrayで、background
がPeachPuff1であるfaceを作り@footnote{この配色は私が日常使用しているお
気に入りのものである。少なくとも表現力乏しい私のノートパソコンの液晶では、
過激な配色でなくやわらかい色に見えるため、目の疲れも少ないので重宝してい
るが、他の方のディスプレイ上ではどんな感じに映るのであろうか。ひょっとし
て恐ろしく趣味の悪い色に見えているかと想像すると少し不安である。}、この
faceをもって変換候補の部分に色名を指定している。foregroundの色のみを変更
するためのfaceを作りたい場合は、

@lisp
(skk-make-face 'RosyBrown1)
@end lisp

@noindent
のようにする。foregroundとbackgroundの色指定だけでない凝ったfaceを作る場
合は、@code{skk-make-face}では対応できないので、Emacsの@file{hilit19.el}
の@code{hilit-lookup-face-create}などを利用する。色名については、X
Windowに添付されている@file{rgb.txt}を参照のこと。配色として参考になる
ものは、Mule-2.3標準添付である@file{canna.el}の 
@code{canna:attribute-alist}などがある。

@node エラーなどの日本語表示,  , ▼モードにおける変換候補のハイライト表示, デコレーション
@comment  node-name,  next,  previous,  up
@subsection エラーなどの日本語表示
@vindex skk-japanese-message-and-error

ディフォルトでは、エラー・メッセージ・ミニバッファプロンプトを英語表示す
る。@code{skk-japanese-message-and-error}の値を@code{non-nil}にするこ
とで、これを日本語で表示する。

@node VIP/VIPERとの併用, I-search関連, デコレーション, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section VIP/VIPERとの併用
@cindex VIP
@cindex VIPER
@cindex @file{vip.el}
@cindex @file{viper.el}
@vindex skk-use-viper

@code{skk-use-viper}の値を@code{non-nil}にすることで、VIPERと併
用することができる。@xref{Top, , VIPER, viper}. 

@c XXX VIP 3.7 について言及する。
VIPは、正式に対応しているバージョンは3.5のみである@footnote{Mule-2.3 に
標準添付のもの。ちなみにVIP3.5の作者は、SKKの原作者でもある佐藤雅彦
@w{<masahiko@@kuis.kyoto-u.ac.jp>}である。なおVIP 3.5は、その発展バージョ
ンがVIPERと名を変え現在もメンテナンスされている。Emacs 19, 20には、
VIP/VIPER のいずれもが標準添付されている。}。

@node I-search関連, skk-init-fileのバイトコンパイル, VIP/VIPERとの併用, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section I-search関連
@cindex I-search
@cindex Incremental search
@cindex @file{~/.skk}

@menu
* 起動時の入力モードの指定:: 
* 間に空白等を含む文字列の検索::
@end menu

@node 起動時の入力モードの指定, 間に空白等を含む文字列の検索, I-search関連, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 起動時の入力モードの指定
@vindex skk-isearch-start-mode
@vindex skk-isearch-use-previous-mode

@code{skk-isearch-start-mode}の値を指定することで、インクリメンタル・サー
チを起動した元のバッファの入力モードにかかわらず、インクリメンタル・サー
チの起動時の入力モードを指定することができる(但し、
@code{skk-isearch-use-previous-mode}の値は@code{nil}にしておく必要が
ある)。

@table @samp

@item ascii
アスキーモード

@item kana
@itemx hirakana
かなモード

@item eiji
全英モード

@end table

一方@code{skk-isearch-use-previous-mode}の値を@code{non-nil}にする
ことで、直前のインクリメンタル・サーチでの入力モードを用いるよう指定する
こともできる。

@node 間に空白等を含む文字列の検索,  , 起動時の入力モードの指定, I-search関連
@comment  node-name,  next,  previous,  up
@subsection 間に空白等を含む文字列の検索
@cindex Incremental regexp search
@kindex M-C-r
@kindex M-C-s
@vindex skk-isearch-whitespace-regexp

@samp{検索}という文字列をインクリメンタル・サーチによりマッチさせたい場
合に、バッファが下記のような状態になっていることがある。

@example
@group
-------- Buffer: foo --------
この行末から始まる文字列を検
索して下さい。
-------- Buffer: foo --------
@end group
@end example

正規表現を用いたインクリメンタル・サーチ@footnote{ディフォルトのキーバ
インドは@kbd{M-C-s}と@kbd{M-C-r}。}を行なうことにより、上記のように文
字列の間に@samp{-}, タブ文字、改行文字、復帰文字、@samp{^L}等が含まれ
ていてもインクリメンタル・サーチによりマッチさせることができる。

変数@code{skk-isearch-whitespace-regexp}の値が、検索の対象となる文
字列の連続した日本語文字の間に挿入され、その結果が正規表現で表現され、検
索の対象となる。@code{skk-isearch-whitespace-regexp}のディフォルト値は

@example
"\\(\\s \\|[ \t\n\r\f]\\)*"
@end example

@noindent
である。@code{skk-isearch-whitespace-regexp}の値を

@example
"\\(\\s \\|[ \t\n\r\f<>|]\\)*"
@end example

@noindent
のようにすることで、文字列が@samp{>>}や@samp{|}等で引用されており、
文字間に引用文字を含む場合であってもマッチするようにすることができる。

@node skk-init-fileのバイトコンパイル, picture-modeとの併用, I-search関連, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section @code{skk-init-file}のバイトコンパイル
@vindex skk-byte-compile-init-file
@vindex skk-init-file

@code{skk-byte-compile-init-file}の値を@code{non-nil}にすることで、
@code{skk-mode}起動時に@code{skk-init-file}(ディフォルト値は、
@file{~/.skk}。) をチェックして、

@enumerate
@item
@code{skk-init-file}をバイトコンパイルしたファイルがないか、

@item
@code{skk-init-file}とそのバイトコンパイル済ファイルを比較して、前者の
方が新しいとき
@end enumerate

@noindent
に@code{skk-init-file}を自動的にバイトコンパイルする。@code{nil}であ
れば、@code{skk-init-file}とそのバイトコンパイル済みファイルを比較して 
@code{skk-init-file}の方が新しいときは、そのバイトコンパイル済ファイル
を(誤ってロードされることのないように)消す。

なお、@code{skk-byte-compile-init-file}は@code{skk-init-file}のロード
前に参照されるので、この変数の設定の変更を@code{skk-init-file}に書いて
も効果がない。@file{~/.emacs}などを利用すること。

@node picture-modeとの併用, サーバー関連, skk-init-fileのバイトコンパイル, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section @code{picture-mode}との併用
@cindex @key{BS}
@cindex move-to-column
@cindex move-to-column-force
@cindex @file{picture.el}
@cindex picture-mode

SKKモードを@code{picture-mode}において使用した場合は、下記の問題点があ
るが、これについては、@code{picture-mode}の側の問題であるので、現在のと
ころ、SKK側では対処していない。
@enumerate

@item
SKKモードで全角文字を入力した場合に、@key{BS}で全角文字が消せないこと。
現状では、backward 方向にある文字を消したい場合は、その文字にポイントを
合わせ、@kbd{C-c C-d}で一文字づつ消すしか方法はない。

@item
@code{picture-movement-up}や@code{picture-movement-down}により上下に全
角文字を挿入した場合にカラムがずれる場合があること。

@end enumerate

いずれも@code{move-to-column-force}関数の中で使用している 
@code{move-to-column}で全角文字を無視したカラム数が与えられたときにカー
ソル移動ができないことが原因である。

@node サーバー関連,  , picture-modeとの併用, 便利な応用機能とユーザーオプション
@comment  node-name,  next,  previous,  up
@section サーバー関連

@menu
* skk-server.elのオプション::   
* うまく起動できないときは::    
@end menu

@c @node skkservの起動オプション, skk-server.elのオプション, サーバー関連, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection @file{skkserv}の起動オプション
@c
@c @file{skkserv}の起動時のオプションにより、ディフォルト辞書名の変更、ディ
@c バッグ・モードの指定などができる。オプションの指定方法は下記の通り。
@c
@c @example
@c skkserv [-d] [-p NNNN] [JISHO]
@c @end example
@c
@c また、各オプションの意味はそれぞれ下記の通り。
@c
@c @table @var
@c
@c @item -d
@c ディバッグ・モード。
@c
@c @item -p NNNN
@c 通信用のポート番号として@var{NNNN}を使う。
@c
@c @item JISHO
@c @var{JISHO}を辞書として利用する。
@c
@c @end table
@c
@c オプションなしで起動すると、通常モード(ディバッグ・モードでない)で、サー
@c バのコンパイル時に指定した辞書とポートを利用する。@file{skkserv}は、サー
@c バとなるべき子プロセスを作った後、直ちに終了する。エラーがあっても何のメッ
@c セージも出さない。
@c
@c ディバッグ・モードで走らせると、@file{skkserv}はそのままforegroundで走
@c り、メッセージを出力する。キーボードから割りこみをかけることもできる。
@c
@c @file{skkserv}の起動はスーパーユーザが行う必要はない。
@c

@node skk-server.elのオプション, うまく起動できないときは, サーバー関連, サーバー関連
@comment  node-name,  next,  previous,  up
@subsection @file{skk-server.el}のオプション

@vtable @code

@c @item skk-server-debug
@c @code{non-nil}であれば、辞書サーバープログラムをディバッグモードで起動
@c する。ディバッグ・モードで@file{skkserv}を走らせると、そのまま
@c foregroundで走り、メッセージを出力する。キーボードから割りこみをかけるこ
@c ともできる。

@item skk-servers-list
辞書サーバー毎の情報リスト。複数のマシーンで動いているサーバにアクセスで
きる場合には、以下のように、リストの各要素に順にホスト名、フルパスでのサー
バー名、サーバーに渡す辞書名、サーバーが使用するポート番号を書き、設定を
することもできる。下記に例を示す。
@lisp
@group

(setq skk-servers-list
      '(("host1 "/your/path/to/skkserv" nil nil)
        ("host2 "/your/path/to/skkserv" nil nil)))

@end group
@end lisp

@noindent
この場合最初に指定したサーバにアクセスできなくなると、自動的に順次リスト
にある残りのサーバにアクセスするようになる。なおサーバーに渡す辞書および
サーバーが使用するポート番号で、サーバーをコンパイル時の値を使用する場合
は@code{nil}を指定する。

@item skk-report-server-response
@code{non-nil}であれば、変換時サーバーの送出する文字を受け取るまでに 
@code{accept-process-output}を何回実行したかを報告する。

@item skk-server-remote-shell-program
リモートシェルのプログラム名。ディフォルト値は下記の通り。
@lisp
@group

(or (getenv "REMOTESHELL")
    (and (boundp 'remote-shell-program) remote-shell-program)
    (cond
     ((eq system-type 'berkeley-unix)
      (if (file-exists-p "/usr/ucb/rsh") "/usr/ucb/rsh" "/usr/bin/rsh"))
     ((eq system-type 'usg-unix-v)
      (if (file-exists-p "/usr/ucb/remsh") "/usr/ucb/remsh" "/bin/rsh"))
     ((eq system-type 'hpux) "/usr/bin/remsh")
     ((eq system-type 'EWS-UX/V) "/usr/ucb/remsh")
     ((eq system-type 'pcux) "/usr/bin/rcmd")
     (t "rsh")))

@end group
@end lisp

@end vtable

@node うまく起動できないときは,  , skk-server.elのオプション, サーバー関連
@comment  node-name,  next,  previous,  up
@subsection うまく起動できないときは

@file{skkserv}とうまく接続できないときは、

@example
% ps ax | grep skkserv
@end example

@noindent
などとして@file{skkserv}が走っていることを確かめた上で、Emacsの 
@code{lisp-interaction-mode}で以下のフォームを順次評価する。

@lisp
@r{;; network streamをopen。``foobar''の個所には@file{skkserv}を動かし}
@r{;; ているホスト名を書くこと。}
(open-network-stream "skkservd-debug" (current-buffer) "foobar" "skkserv")
@r{;; 初期設定}
(let ((code (cdr (assoc "euc" skk-coding-system-alist)))
      (proc (get-process "skkservd-debug")))
  (cond ((eq skk-emacs-type 'xemacs)
	 (set-process-input-coding-system proc code)
	 (set-process-output-coding-system proc code))
	((memq skk-emacs-type '(mule4 mule3 mule2))
	 (set-process-coding-system proc code code))))
@r{;; 変換すべき文字列として `かんじ' を送信する。}
(process-send-string "skkservd-debug" "1かんじ ")
@r{;; 成功すると、カレントバッファに、}
@r{;; 1/漢字/幹事/完治/完爾/寛治/感じ/}
@r{;; などとSKK-JISYO.Lに含まれる候補が挿入される。}
@r{;; 先頭の数字 `1' は `skkserv' が候補の検索に成功したことを示す。}
@r{;;serverをdisconnectする。}
(process-send-string "skkservd-debug" "0")
@end lisp

@c @node サーバー起動後の辞書の再読み込み, 限界・改良の余地, うまく起動できないときは, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection サーバー起動後の辞書の再読み込み
@c
@c @file{skkserv}起動後に@file{skkserv}の参照している辞書の内容を変更し
@c たい場合、単純に@file{skkserv}のプロセスをkillしてしまうとその時に同じ 
@c @file{skkserv}を利用してskkを使っているすべてのユーザに悪影響がある。
@c
@c そこで@file{skkserv}を走らせたまま辞書を再読みこみする方法を付加した。
@c なお、辞書のファイル名を変更するときはできない。つまり、コンパイル時また
@c は起動時に指定されたファイル名の位置に、新しい辞書を上書きする必要がある。
@c
@c @enumerate
@c
@c @item
@c 新しい辞書を@file{skkserv}の所定の場所に置く(@file{cp}の各引数は適当
@c な文字列に直す)。
@c
@c @example
@c % cp NEW-JISHO /usr/local/mule/etc/SKK-JISYO.L 
@c @end example
@c
@c @item
@c @file{skkserv}のプロセス番号を求める。
@c
@c @example
@c % ps ax | grep skkserv
@c @end example
@c
@c @item
@c @file{skkserv}に辞書再読み込みを指定するシグナルを送る。
@c
@c @example
@c % kill -INT NNNN
@c @end example
@c
@c @noindent
@c ここで@var{NNNN}は上記で求めた@file{skkserv}のプロセス番号とする。な
@c お、signalを送ることができるのはスーパーユーザのみ(個人で@file{skkserv}
@c を起動した場合は、スーパーユーザまたは起動した人のみ)である。
@c
@c @end enumerate
@c
@c
@c なお、下記の点に注意すること。
@c @itemize @bullet
@c @item
@c 上記手順で1と3の間(辞書ファイルの中身が書きかわったのに、まだ 
@c @file{skkserv}がそのことを知らないとき)では、@file{skkserv}は変な動作
@c をすることがある。特に、辞書のサイズを小さくしたときには死んでしまうかも
@c しれない。
@c
@c @item
@c 動作は、SparcStation-2/SunOS 4.1.1上でのみテストした。signalの取り扱いが
@c 異なるマシン上では動作しない可能性がある。
@c
@c @end itemize
@c
@c @node 限界・改良の余地,  , サーバー起動後の辞書の再読み込み, サーバー関連
@c @comment  node-name,  next,  previous,  up
@c @subsection 限界・改良の余地
@c
@c @file{skkserv}がディバッグ・モードでないときに合法的に殺す手段はない。
@c killする。
@c
@c 一つの計算機の上で使用できる同じ番号のTCPソケットは、一つしか存在できな
@c い。従い標準ポート番号を使う@file{skkserv}も一つしか動かない。ディバッ
@c グやテストの際に@file{skkserv}を殺してすぐに起動すると、ポートが使われて
@c いる、という趣旨のエラーが起きる。この場合は、少し待ってから再度起動する。
@c
@c 一つのサーバが受けつけられるクライアントの数の上限は、関数 
@c @code{getdtablesize}により決まる。もし上限を越えた数のクライアントがコ
@c ネクト要求をしてきた時はサーバは異常終了する。
@c
@c 本来のSKK辞書には, 見出し語の長さの上限はないが、@file{skkserv}では 512
@c バイトに限っている(@file{skkserv.h}の@var{BUFSIZE}の値)。なお、変換文
@c 字列の長さに制限はない。
@c
@c @c バイナリサーチパッチを採用しているなら削除する。
@c 辞書検索は、読みの第1文字目による場合分けを行った後は、線型探索を行なっ
@c ている。現在の状況ではこれで十分であるが、場合によってはより高速な探索方
@c 法を検討する必要があるかもしれない。
@c

@node  辞書ユーティリティプログラム, 拡張アイディア, 便利な応用機能とユーザーオプション, Top
@comment  node-name,  next,  previous,  up
@chapter 辞書ユーティリティプログラム

SKK辞書に関するユーティリティプログラムには、Perl, C の各言語により書か
れたものがある。

@menu
* Cによるユーティリティプログラム::  
* Perlによるユーティリティプログラム::  
@end menu

@node Cによるユーティリティプログラム, Perlによるユーティリティプログラム, 辞書ユーティリティプログラム, 辞書ユーティリティプログラム
@comment  node-name,  next,  previous,  up
@section Cによるユーティリティプログラム

@c XXX別ディストリビューション
Cで書かれたユーティリティプログラムはjisyo-toolsと総称され、SKKの
distributionではディレクトリ@file{jisyo-tools}の下にある。

@menu
* プログラム作成方法::          
* skkdic-expr::                 
* skkdic-sort::                 
* skkdic-count::                
@end menu

@node プログラム作成方法, skkdic-expr, Cによるユーティリティプログラム, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection プログラム作成方法

@c XXX configure
@file{Makefile}を見て、必要があれば中の@var{CC}と@var{CFLAGS}の内容
を変更してから@code{make}を実行する。

なお@code{skkdic-expr}では作業用のファイルとして辞書の2倍程度の大きさ
のものを作成する。このファイルが作成されるディレクトリは実行時に指定でき
るが、ディフォルトとして@file{/tmp}を指定してる。もしも明らかに不足す
る場合には、

@example
-DTMPDIR=\".\"
@end example

@noindent
を@var{CFLAGS}に追加すると、@file{/tmp}が溢れるといった災害を防
ぐことができる。

@node skkdic-expr, skkdic-sort, プログラム作成方法, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-expr}
@cindex @file{skkdic-expr}

複数のSKK辞書をマージしたり、他の辞書と同じ内容を引くのに使う。例えば、
次のようにして使う。

@example
% skkdic-expr @var{jisyo1}+@var{jisyo2}-@var{jisyo3}>@var{result}
@end example

@noindent
上記の例では、@var{jisyo1}と@var{jisyo2}にある@var{jisyo1}と重複し
ない候補を加え、その後、@var{jisyo3}と同じ候補があれば削除する。

また、次のオプションが使用できる。引数の辞書の直前に指定する。

@table @var

@item -d
作業用ディレクトリ。

@item -o
出力ファイル。

@end table

その他の使用例をあげる。
@enumerate

@item
複数の辞書を@code{cat}でつないだものを整理する。

@example
% skkdic-expr @var{olddict1}>@var{newdict1}
@end example

@noindent
このように使用すると、重複する候補を削除したり、同じ読みが別々の行に複数
存在していても一行のエントリにまとめる。例えば、

@example
じしょ /辞書/
じしょ /璽書/
じしょ /字書/
@end example

@noindent
のような辞書を

@example
じしょ /辞書/璽書/字書/
@end example

@noindent
と、一行にまとめることができる。候補の配列(候補が出力される際の優先順位)
は上から順になる。
@c この行の意味が良く分りません。-- 中島
@c また、同じ読みの並び順を変更するのにも使える。

@item
個人辞書にある分だけを取り出す。

@example
% skkdic-expr ~/.skk-jisyo - SKK-JISYO.L >@var{private}
@end example

@noindent
この差分を将来のSKK辞書に反映させる方法については@ref{謝辞とお願い}を
参照のこと。

@item
2つの辞書の共通部分を取り出す。

@example
@group
% skkdic-expr @var{jisyo-a}-@var{jisyo-b}>@var{jisyo-tmp}
% skkdic-expr @var{jisyo-a}-@var{jisyo-tmp}>@var{jisyo-common}
@end group
@end example

@end enumerate


@node skkdic-sort, skkdic-count, skkdic-expr, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-sort}
@cindex @file{skkdic-sort}

ソートされていない辞書を通常のSKK辞書の形式にソートし、
@w{@samp{;; okuri-ari entries.}}と@w{@samp{;; okuri-nasi entries.}}を
適切な位置に挿入する。入力は標準入力のみ、出力は標準出力のみが指定できる。
例をあげる。

@example
% skkdic-expr @var{jisyo-a}+@var{jisyo-b}| skkdic-sort >@var{newdict}
@end example

@noindent
一時的に使用するswapを小さくするためにあえて@file{skk-jisyo-expr}とは
別のプログラムとしてある。

@node skkdic-count,  , skkdic-sort, Cによるユーティリティプログラム
@comment  node-name,  next,  previous,  up
@subsection @file{skkdic-count}
@cindex @file{skkdic-count}

SKK辞書の中の候補の数を数える。@samp{[}と@samp{]}で囲まれた送り仮名毎
のブロックも一つの候補として数える。

@node Perlによるユーティリティプログラム,  , Cによるユーティリティプログラム, 辞書ユーティリティプログラム
@comment  node-name,  next,  previous,  up
@section Perlによるユーティリティプログラム
@cindex @file{adddummy}
@cindex @file{codeconv.pl}
@cindex @file{jis2sjis}
@cindex @file{jis2ujis}
@cindex @file{kana2roma}
@cindex @file{kana2roma.pl}
@cindex @file{list2skk}
@cindex @file{pubdic2list}
@cindex @file{removedummy}
@cindex @file{roma2kana}
@cindex @file{roma2kana.pl}
@cindex @file{sjis2jis}
@cindex @file{skk2list}
@cindex @file{skkconv}
@cindex @file{sub}
@cindex @file{ujis2jis}

@c XXX distributionはjisyo-toolsとmergeしてしまおうか...。
Perlで書かれたユーティリティプログラムはskktoolsと総称され、SKKの
distributionではディレクトリ@file{contrib/skktools}の下にある。

skktoolsは、辞書をマージしたり、pubdic辞書をSKK辞書の形式に変換したりす
るためのツール群である。SKK辞書は読みに対応する複数の漢字が@samp{/}で
区切られた構造をしているが、このツールでは読みと漢字が1対1に対応した形式
(これを@b{「リスト形式」}と呼ぶ)のファイルを中間形式として取り扱う。

skktoolsには以下のプログラムがある。

@table @file

@item skk2list
SKK辞書をリスト形式に変換する。

@item pubdic2list
pubdic辞書の名詞エントリをリスト形式に変換する。

@item list2skk
リスト形式をSKK辞書に変換する。

@item adddummy
SKK辞書ソートのためにダミー文字を加える。

@item removedummy
加えたダミー辞書を取り除く。

@item sub
二つのリスト形式の辞書の差分を計算する。

@item skkconv
漢字検索コマンド。

@end table

例えば、既存のSKK辞書とpubdic辞書をマージして新しいSKK辞書を作成するには
次のように行なう。

@example
@group
% (skk2list skk-jisyo ; pubdic2list kihon.u) \@r{; リスト形式を連結}
      | adddummy \@r{; ダミー文字追加}
      | sort -u \@r{; ソート}
      | removedummy \@r{; ダミー文字削除}
      | list2skk \@r{; SKK辞書に変換}
      > skk-jisyo.new
@end group
@end example

これらのツールではEUCの辞書のみ取り扱い可能である。それ以外の文字コード
の辞書を使うときは後述の@file{jis2ujis}などのコマンドを加える必要がある。

二つのリスト形式の辞書の差分を計算するには、

@example
% sub 旧リスト 新リスト
@end example

@noindent
とする。比較する二つのファイルはあらかじめソートされていなければならない。

@file{skkconv}はSKKサーバを使用してコマンドラインでかな漢字変換するため
のコマンドである。例えば@samp{かんじ}という読みをもつ漢字を以下のように
検索できる。

@example
@group
% skkconv kanji
漢字
幹事
感じ
......
%
@end group
@end example

この他に以下のPerlライブラリとコマンドがある。

@table @file

@item codeconv.pl
JIS, EUC, SJIS相互変換ライブラリ。

@item roma2kana.pl
ローマ字@expansion{}平仮名変換ライブラリ。

@item kana2roma.pl
平仮名@expansion{}ローマ字変換ライブラリ。

@item jis2sjis
JIS @expansion{}SJIS変換コマンド。

@item sjis2jis
SJIS @expansion{}JIS変換コマンド。

@item jis2ujis
JIS @expansion{}EUC変換コマンド。

@item ujis2jis
EUC @expansion{}JIS変換コマンド。

@item roma2kana
ローマ字@expansion{}かな(EUC)変換コマンド。

@item kana2roma
かな(EUC)@expansion{}ローマ字変換コマンド。

@end table

@node 拡張アイディア, SKKメーリングリスト, 辞書ユーティリティプログラム, Top
@comment  node-name,  next,  previous,  up
@chapter 拡張アイディア

将来のバージョンに託された拡張アイディアを、実現可能かどうかは別にして、
順不同で述べる。これ以外にも要望、拡張の具体的アイディアがあれば、
開発者用メーリングリストに投稿するなどの方法で、開発者までご連絡いただき
たい。@xref{開発者用メーリングリスト}.

@itemize @bullet

@item
辞書の個々の見出し語、候補に属性を持たせて、例えば、下記のような機能をイ
ンプリメントする。

@enumerate
@item
その属性の内容により、変換の際に候補の絞り込み条件を指定できるようにする。
また、絞り込み条件はユーザーの任意に変更できるようにする。一例をあげれば、
サ変動詞になり得る名詞に適当な属性を持たせ、@samp{〜する}という送り仮名
がタイプされた場合には、そのサ変動詞属性を持った名詞のみを候補として出力
する、など活用の幅は非常に広い。サ変動詞の問題については、
@ref{辞書登録モード}も参照のこと。

@item
候補に最終の変換時刻などを属性として持たせ、辞書のメンテナンスに利用する
(一定期間アクセスのない候補を個人辞書から削除するなど)。

@item
候補に関する意味を属性として持たせ、意味を調べるような拡張変換を行なえる
ようにする。

@end enumerate

@c XXX 今まで実験してきたことを記述する。
@noindent
言うは易しだが、色々な未解決の問題がある。多数の見出し語や候補に属性を持
たせて、通常の変換効率をできる限り落さないで、かつ効率良く属性のメンテナ
ンスを行なう方法を模索することがまず大変。Emacsのバッファに読み込む辞書
とサーバー経由でアクセスしている辞書とがあることも検討事項。Emacs側の機
能で対応した場合にサーバー経由の辞書属性をどうやって得るか、またはその逆
が課題である。コーディング抜きであってもアイディアをいただけたら幸いであ
る。

@c こりゃ無理か？
@c @item
@c @kbd{C-x C-j}, @kbd{C-x j}など、SKKモードの起動に使用されるキーに元々割
@c り付けられているEmacsのオリジナルのコマンドの自動退避。意外と難しい？ 
@c @xref{基本的設定}.

@item
CannaやWnnのサーバーと接続して検索が可能になるようにする@footnote{Tamago4では、
Emacs Lispベースでサーバーと接続できる。@samp{http://www.m17n.org/tamago/}}。

@item
いかなるユーザーオプション変数をバッファローカル化しても動作するようにす
ること。辞書バッファで参照されるユーザーオプションを、変換を行なっていた
バッファの指定値から受け渡しして辞書バッファで参照するなどの配慮が必要か。
@xref{送り仮名の厳密なマッチ}.

@item
送り仮名の厳密なマッチなしの送り仮名の自動処理を行なうオプションを作るこ
と。現状の送り仮名の自動処理では、送り仮名のプレフィックスがマッチするだ
けでは候補として出力せず、更に送り仮名全体が厳密にマッチするかどうかを
チェックしている。これは候補の絞り込みのためには有効に作用するが、個人辞
書の内容が貧弱な場合は、逆にこれがあだとなってすぐに辞書登録モードに入っ
てしまう。オプション設定することにより、いずれの場合にも対応できるように
する。@xref{送り仮名の自動処理}.@xref{送り仮名の厳密なマッチ}.

@c @item
@c @code{query-replace}などのコマンドで、SKKの入力モードを認識するようなプ
@c ロンプトを出す。こりゃ無理か？

@item
部首変換プログラムと辞書を作ること。

@item
辞書毎にコーディングシステムを別々に設定できるようにすること。

@end itemize

@node SKKメーリングリスト, SKKの入手方法, 拡張アイディア, Top
@comment  node-name,  next,  previous,  up
@chapter SKKメーリングリスト

@menu
* SKK Ring Server Openlab メーリングリスト::
* ユーザーメーリングリスト::    
* 開発者用メーリングリスト::    
@end menu

@node SKK Ring Server Openlab メーリングリスト, ユーザーメーリングリスト, SKKメーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section SKK Ring Server Openlab メーリングリスト
@cindex メーリングリスト[めーりんくりすと]

SKK 10 は、 Ring Server Openlab にて CVS を用いて開発されています。
このメーリングリストでは、利用者と開発者で分かれていません。バグレポートや
開発における議論など様々な話題が流れます。

@table @asis

@item メーリングリストに参加する場合
@samp{skk-request@@ring.gr.jp} 宛てのメールに本文に (@samp{Subject} ではあり
ません) @samp{subscribe} とだけ書いて送って下さい。機械的に処理され、講読が
開始されます。

@item メーリングリストから脱会する場合
@samp{skk-request@@ring.gr.jp} 宛てのメールに本文に (@samp{Subject} ではあり
ません) @samp{unsubscribe} とだけ書いて送って下さい。機械的に処理され、講読
が中止されます。

@item 登録したアドレスの変更する場合
古いアドレスについて一旦 unsubscribe して、新しいアドレスから再度 subscribe
して下さい。

@item 記事の投稿 

@samp{skk@@ring.gr.jp} へ送ります。メーリングリストに登録されている人全員に
メールが配信されます。

@end table

Ring Server Openlab では、ニュースサーバに接続してメーリングリストの記事を
読むことができます。NNTP クライアントで @samp{news.ring.gr.jp} に接続します。
ニュースグループ名は、 @samp{ring.openlab.skk} です。


@node ユーザーメーリングリスト, 開発者用メーリングリスト, SKK Ring Server Openlab メーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section ユーザーメーリングリスト
@cindex メーリングリスト[めーりんくりすと]

SKKに関する意見交換の場としてSKKメーリングリストが開設されている。これま
でメーリングリストで話題になったこととしては、SKKの虫の報告/修正、
質問/回答、SKK改良のための提案等がある。また、最新のSKKもメイリングリス
トを通して配布し、参加者の協力を得て、テスト、改良を重ねている。

@table @asis

@item メーリングリストへ参加したいとき。
@samp{skk-join@@kuis.kyoto-u.ac.jp}へメールを送れば、自動的に発信者のメー
ルアドレス(@samp{From:}のアドレス)が登録される。

@item メーリングリストへの記事の投稿を行なうとき。
@samp{skk@@kuis.kyoto-u.ac.jp}へ送れば自動的に全ての登録者に送付される。

@item メーリングリストに登録したアドレスを変更したいとき。
新しいメールアドレスから@samp{skk-change@@kuis.kyoto-u.ac.jp}宛に、本
文の1行目に下記の書式で旧アドレスを書いたメールを送付する。
@example
@samp{Old:@var{your-old-address}}
@end example

@item メーリングリストから抜けたいとき。
@samp{skk-leave@@kuis.kyoto-u.ac.jp}へメールを送る。

@end table

@samp{skk-source@@kuis.kyoto-u.ac.jp}宛にメールを送付することで、過去の
SKKメーリングリストへの投稿記事を入手することができる。入手したい記事の
@samp{Mailinglist-ID:}に従い、下記の要領で@samp{Subject:}を指定し、メー
ルを送付することで、指定された内容のメールが返送される。

@table @asis

@item @samp{Mailinglist-ID:}が134の記事を入手する場合。
@samp{Subject: 134}

@item @samp{Mailinglist-ID:}が100番から199番の記事を全部入手する場合。
@samp{Subject: ml-contents-01}

@end table

@noindent
ただし、0〜99番の場合は@samp{ml-contents-00}と指定する。なお、
Mailinglist-ID:が欠番の部分もある。

@node 開発者用メーリングリスト,  , ユーザーメーリングリスト, SKKメーリングリスト
@comment  node-name,  next,  previous,  up
@section 開発者用メーリングリスト
@cindex SKKの開発[SKKのかいはつ]
@cindex メーリングリスト[めーりんくりすと]

SKKの開発に関する情報交換、及びテスト版の配布などを行う場としてSKK開発者
用メーリングリストが開設されている。

@table @asis

@item メーリングリストへ参加したいとき。
@samp{skk-develop-join@@kuis.kyoto-u.ac.jp}へメールを送れば、自動的に発
信者のメールアドレスが登録される。

@item メーリングリストへの記事の投稿を行なうとき。
@samp{skk-develop@@kuis.kyoto-u.ac.jp}へ送れば自動的に全ての登録者に送
付される。

@item メーリングリストに登録したアドレスを変更したいとき。
新しいメールアドレスから@samp{skk-develop-change@@kuis.kyoto-u.ac.jp}宛に、本
文の1行目に下記の書式で旧アドレスを書いたメールを送付する。
@example
@samp{Old:@var{your-old-address}}
@end example

@item メーリングリストから抜けたいとき。
@samp{skk-develop-leave@@kuis.kyoto-u.ac.jp}へメールを送る。

@end table

@node SKKの入手方法, SKK関連ソフトウェア, SKKメーリングリスト, Top
@comment  node-name,  next,  previous,  up
@chapter SKKの入手方法

@menu
* WWWを利用して入手する方法::
* CVSによる入手方法::
@end menu

@node WWWを利用して入手する方法, CVSによる入手方法, SKKの入手方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section WWWを利用して入手する方法

SKK OpenLab のホームページでは、SKK の最新版を配布するためのページを設け
ています。

@table @asis
@item 日本語版URL

@samp{http://openlab.ring.gr.jp/skk/maintrunk-ja.html}
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item 英語版URL

@samp{http://openlab.ring.gr.jp/skk/maintrunk.html}

@end table

@node CVSによる入手方法,  , WWWを利用して入手する方法, SKKの入手方法
@comment  node-name,  next,  previous,  up
@section CVSによる入手方法

CVS を利用すれば、SKK OpenLab のホームページにて公開されているものよりも
新しい開発版の SKK を入手できます。ここではまず、CVS の入手とインストー
ルについて説明し、次に CVS を使って SKK を取得する方法を述べます。


@menu
* CVSの入手先::
* CVSによるSKKの取得::
@end menu

@node CVSの入手先, CVSによるSKKの取得, CVSによる入手方法, CVSによる入手方法
@comment  node-name,  next,  previous,  up
@subsection CVSの入手先

CVS は 以下のサイトで配布されています。
 
@samp{ftp://ftp.cvshome.org/pub/}

また、少し更新が遅れ気味のようですが、 GNU のミラーサイトからも入手でき
ます。マスターサイトは

@samp{ftp://ftp.gnu.org/gnu/non-gnu/cvs/}

ですが、日本から入手する場合は

@table @samp
@item ftp://ftp.ring.gr.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.win.ne.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.iij.ad.jp/pub/GNU/non-gnu/cvs/ 
@item ftp://ftp.tokyonet.ad.jp/pub/GNU/non-gnu/cvs/ 
@end table

等の日本のサイトを利用します。上記は安定した正式リリース版ですが、最新の
開発版を利用したい人は

@samp{http://www.cvshome.org/dev/source.html}

をご覧ください。また、Windows の binary が欲しい方は、

@samp{ftp://ftp.cvshome.org/pub/cvs-1.10/windows/cvs-1.10-win.zip}

に正式版 cvs-1.10 のバイナリーが、

@samp{ftp://ftp.cvshome.org/pub/cvs-1.10.5/windows/cvs.exe}

に開発版 cvs-1.10.5 のバイナリーが置かれています。また、Mac 用 CVS は

@samp{http://www.maccvs.org/}

から入手可能です。CVS に関する情報は

@table @samp
@item http://www.loria.fr/~molli/cvs-index.html}
@item http://www.cvshome.org/
@item http://www.race.u-tokyo.ac.jp/~moro/cvs/
@item http://www.itojun.org/hack/cvs/tut-kernel.html
@item http://www-vox.dj.kit.ac.jp/nishi/cvs/
@item http://duff.kuicr.kyoto-u.ac.jp/~okuji/gnujdoc.html
@end table

などから得られます。

@node CVSによるSKKの取得, , CVSの入手先, CVSによる入手方法
@comment  node-name,  next,  previous,  up
@subsection CVSによるSKKの取得

@samp{cvs} コマンドで SKK を取得する場合、「ログイン」と「チェックアウト」
の 2 つの操作が必要になります。

まず guest アカウントで openlab.ring.gr.jp の CVS server に「ログイン」
します。

@example
$ cvs -d :pserver:guest@@openlab.ring.gr.jp:/circus/cvsroot login
@end example

プロンプトが出るので、パスワードに `guest' を入れ、CR します。

@example
CVS password: guest (CR)
@end example

~/.cvspass というファイルに password が記録され、次からは明示的な
ログイン は不要になります。

次に「チェックアウト」 して CVS server からソースをもらってきます (この
ファイルをワーキングコピーといいます)。

@example
$ cvs -d :pserver:guest@@openlab.ring.gr.jp:/circus/cvsroot checkout skk/main
@end example

これで @file{skk/main} というディレクトリにワーキングコピーが作られます。

@node SKK関連ソフトウェア, 最新情報など, SKKの入手方法, Top
@comment  node-name,  next,  previous,  up
@chapter SKK関連ソフトウェア
@cindex @file{kakasi}
@c @cindex @file{pskkserv}
@cindex @file{skkfep}
@cindex @file{skkinput}

@menu
* dbskkd-cdb ::                 
* skkfep内蔵jvim::              
* KAKASI::                      逆引プログラム
* skkfep::                      SKKクローンFEP
* SKK on Jed::                  Jedで動くSKK
* skkinput::                    X上のSKK入力プログラム
* SKKIME::                      skkinput for Microsoft Windows
* SKK95::                       Windowsで動くSKK like IME
@end menu

@node dbskkd-cdb , skkfep内蔵jvim, SKK関連ソフトウェア, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section dbskkd-cdb 
@cindex dbskkd-cdb 
@cindex cdb

このセクションは、dbskkd-cdbの開発者である力武健次氏により書かれた。

@table @asis

@item 正式名称
dbskkd-cdb

@item どのようなソフトウェアか
SKK用のシステム辞書サーバ。

@item 使用するために要求される環境
Linux, FreeBSD, Solaris 2.6上での動作を確認している。現状では使用するSKK
システム辞書と比べ、cdb形式の辞書のサイズは2倍弱になる。セキュリティ向上
のため、inetdからtcp_wrapperなどを経由して起動することを前提とする。
Daniel J. Bernstein氏の開発した同様のソフトウェアucspi-tcpの使用を推奨す
る。高速化のため、Daniel J. Bernstein氏の開発した固定データベース用ライ
ブラリcdbを使っているのでcdbのインストールが必要。

@item 最新バージョン、release の日付
1.00, 1999年6月16日

@item 開発者
力武 健次 @w{<kenji.rikitake@@acm.org>}

@item 配布条件
GPLに準拠。

@item 入手方法
一次配布先は@w{@samp{http://www.ne.jp/asahi/bdx/info/software/jp-dbskkd.html}}
から参照できる。

@item bug report,質問のためのアドレス
@w{@samp{kenji-dbskkd-cdb@@k2r.org}}

@item その他
さまざまなUNIX系OSの上での動作レポートを希望しています。
@end table

@node skkfep内蔵jvim, KAKASI, dbskkd-cdb , SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep内蔵jvim
@cindex skkfep
@cindex jvim

このセクションは、skkfep内蔵jvimの開発者である木原英人氏により書かれた。
@table @asis

@item 正式名称
skkfep内蔵jvim

@item どのようなソフトウェアか
jvim(viクローンのエディタvimを日本語化したもの)にskkfepを組み込んだもの
です。vi系のエディタでSKK風の日本語入力ができます。

@item 使用するために要求される環境
UNIX, Windows 95/98/NT, DOS

@item 最新バージョン、release の日付
jvim, skkfep, ariそれぞれに対するパッチとして提供しています。
@w{jvim3.0-j1.7-skk1.2.8.patch} 1999/8/30,
@w{skkfep0.86c-kh1.2.6.patch}, 1999/9/28,
@w{ari1.00a-kh1.2.1.patch} 1999/1/29

@item 開発者
木原 英人

@item 配布条件
skkfep, jvim, ariそれぞれに対するパッチとして提供しているので、それぞれ
の配布条件に従います。

@item 入手方法
@w{@samp{http://hiroshima.cool.ne.jp/deton/jvim-skk/}}

@item bug report,質問のためのアドレス
@w{@samp{deton@@m1.interq.or.jp}}

@end table

@node KAKASI, skkfep, skkfep内蔵jvim, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section KAKASI
@cindex Kanji Kana Simple Inverter

KAKASIとは、高橋裕信氏@w{<takahasi@@tiny.or.jp>}による「漢字かなまじり文
をひらがな文やローマ字文に変換することを目的として作成したプログラムと辞
書の総称」である。KAKASIは、Kanji Kana Simple Inverterにちなんで、また
SKKの逆言葉として名付けられた。KAKASI は現在、Namazu (@samp{http://www.namazu.org/})
のサイトにて開発が継続されている。

@table @asis

@item 入手方法
@w{@samp{http://kakasi.namazu.org/}}

@end table


@node skkfep, SKK on Jed, KAKASI, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkfep
@cindex @file{skkfep}

skkfepは、伊藤彰則、渡辺雅俊、金子裕の各氏による、SKKと似た入力方式の漢
字入力フロントエンドプロセッサである。

現在サポートされているOSは、下記の通り。
@display
SunOS 4.x, AIX3.x, Linux, 386BSD, AIX/ESA, DOMAIN-IX SR9.x, HP-UX 8.x,
SEIUX 3.x, EWS-UX/V Rel4.0, NEWS-OS 4.x, NEWS-OS 3.3
@end display

@c @node pskkserv, SKK on Jed, skkfep, SKK関連ソフトウェア
@c @comment  node-name,  next,  previous,  up
@c @section pskkserv
@c @cindex DBM
@c @cindex Perl
@c @cindex @file{makedbmdic}
@c @cindex @file{pskkserv}
@c @vindex exec-directory
@c
@c pskkservは佐藤正章氏@w{<msatoh@@mrit.mei.co.jp>}による@file{skkserv}
@c 代替ソフトである。Perlスクリプトとしてインプリメントされており、サーバー
@c プログラムである@file{pskkserv}と、辞書のDBM化の際使用する 
@c @file{makedbmdic}がある。
@c
@c @file{pskkserv}は、SKK辞書をDBM化し、Perlの連想配列を用いて検索を行なう。
@c Perlの連想配列のインデクスキーは、内部的にハッシュテーブルに登録されてお
@c り、連想配列に登録されているエントリの個数に影響を受けることなく、一定時
@c 間で高速な検索を行なうことができる。DBM関連の関数が使えるPerlであれば、
@c バージョン4でも5でも動作可能である(Perl4専用プログラムとPerl5専用プログ
@c ラムとに分れている)。
@c
@c @file{pskkserv}を利用するには、まず@file{makedbmdic}によりSKK辞書をDBM
@c 化する必要がある。Berkeley DB形式の場合は、@file{makedbmdic}に@samp{-B}
@c オプションを、GDBMの場合は@samp{-G}オプションを渡す。
@c
@c @example
@c @cartouche
@c % makedbmdic -G SKK-JISYO.L
@c
@c makedbmdic by msatoh@@mrit.mei.co.jp
@c Make dbm format dic from SKK dic.
@c The numbers mean how many lines have processed.
@c A dot mean 20 lines, as you see.
@c
@c ..................................................1000[ 0.97%]
@c ..................................................2000[ 1.95%]
@c ..................................................3000[ 2.92%]
@c @dots{}
@c ..................................................101000[98.34%]
@c ..................................................102000[99.32%]
@c ................................... done
@c @end cartouche
@c @end example
@c
@c @noindent
@c @file{makedbmdic}により@file{SKK-JISYO.L}を処理すると、Berkeley DB形
@c 式の場合は、@file{SKK-JISYO.L.db}、GDBMの場合は@file{SKK-JISYO.L.gdbm}
@c というDBM形式の辞書が生成される@footnote{拡張子が違うので要注意。}。この
@c 辞書は、元の@file{SKK-JISYO.L}の4倍弱のファイルサイズになる。
@c
@c 次に@file{pskkserv}をEmacsの@code{exec-directory}などに置き、下記の
@c ようなシェルスクリプト@footnote{もちろん@file{pskkserv}のパスはご自分
@c のマシンに合ったものをご指定いただきたい。}を@file{rc.local}などに追加
@c して再起動する。
@c
@c @example
@c @group
@c echo Starting up pskkserv...
@c if [ -x /your/path/to/pskkserv ]; then
@c         /your/path/to/pskkserv -G /your/path/to/SKK-JISYO.L.gdbm &
@c fi
@c @end group
@c @end example
@c
@c また、下記のようなフォームを@file{~/.emacs}などに設定する。
@c
@c @lisp
@c (setq skk-server-prog "/your/path/to/pskkserv")
@c @end lisp
@c
@c @noindent
@c ディレクトリが、@code{exec-directory}と同一ならば、下記のように指定する
@c こともできる。
@c @lisp
@c (setq skk-server-prog (concat exec-directory "pskkserv"))
@c @end lisp
@c
@c @noindent
@c @file{pskkserv}を使用する場合でも、設定は@file{skkserv}を使用するとき
@c と変りない。@xref{共通の設定}.
@c @xref{スーパーユーザの権限を持たない人の場合}.

@node SKK on Jed, skkinput, skkfep, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK on Jed
@cindex Jed
@cindex S-Lang

このセクションは、SKK on Jedの開発者である豊福親信氏により書かれた。

@table @asis

@item 正式名称
SKK on Jed

@item どのようなソフトウェアか
Jed(Emacs系の軽いエディタ。C言語風の拡張言語S-Langを持つ)に移植された
SKKです。

@item 使用するために要求される環境
日本語版Jedが動いていればその上で動きます。現在、多くのUNIX、MSDOS、
Win95/NT、OS2上で日本語版Jedは動いています。

@item 最新バージョン、release の日付
version 0.1.1(1996年12月15日)

@item 開発者
豊福 親信

@item 配布条件
SKKと同じです。

@item 入手方法

@table @asis
@item メールによる入手方法
@samp{unbound@@papaya.juice.or.jp}にメールで連絡して下さい。

@item WWWを利用して入手する方法
WWWクライアントを利用して
@w{@samp{http://www.juice.or.jp/~toyofuku/jed.html}}から入手できます。
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@end table

@item bug report,質問のためのアドレス
@w{@samp{unbound@@papaya.juice.or.jp}}

@item その他
まだいくつか未実装機能がありますがSKKの全機能実装を目指しています。
@end table

@node skkinput, SKKIME, SKK on Jed, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section skkinput
@cindex @file{skkinput}

このセクションは、skkinputの開発者である阪本崇氏により書かれた。

@table @asis

@item 正式名称
skkinput

@item どのようなソフトウェアか
日本語テキスト入力を要求するX11のアプリケーションのための入力サーバ。現
在はKinput Protocolにしか対応していませんが、将来的にはXIMやKinput2
Protocolに対応させる予定です。

@item 使用するために要求される環境
UNIX + X11R5またはX11R6(R6.1)

@item 最新バージョン ,release の日付
2.03, 

@item 開発者
阪本 崇(@w{@samp{sakamoto@@yajima.kuis.kyoto-u.ac.jp}}, @*
@w{@samp{PXG01715@@niftyserve.or.jp}})

@item 配布条件
ありません。

@item 入手方法
@smallexample
@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkinput.htm}}
@end smallexample
@noindent
から入手できます。
@c Texinfo 3.9 has a @url command.  For the time being, we shuould use
@c @samp instead of @url for compatibility purpose.  Moreover, @url
@c command does not have a special effect other than the one which @samp
@c has until Texinfo supports HTML conversion.

@item bug report、質問のためのアドレス
@w{sakamoto@@yajima.kuis.kyoto-u.ac.jp}もしくは
@w{PXG01715@@niftyserve.or.jp}まで御願い致します。

@item その他
SKK 8.6にはかなり近付けたと思うのですが、まだまだ異なる部分が残っていま
す。特に操作体系で異なると感じられた方は私までレポートを御願い致します。
@end table

@node SKKIME, SKK95, skkinput, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKKIME
@cindex SKKIME

@table @asis

@item  開発者
skkinput と同じく 阪本崇氏

@item 最新バージョン
SKKIME 1.0

@item 入手先
@w{@samp{http://member.nifty.ne.jp/Tatari_SAKAMOTO/skkime.htm}}

@end table

@node SKK95,  , SKKIME, SKK関連ソフトウェア
@comment  node-name,  next,  previous,  up
@section SKK95
@cindex SKK95

@c @table @asis
@c @item 正式名称
@c @item どのようなソフトウェアか
@c @item 使用するために要求される環境
@c @item 最新バージョン、release の日付
@c @item 開発者
@c @item 配布条件
@c @item 入手方法
@c @item bug report,質問のためのアドレス
@c @item その他
@c @end table

このセクションは、京大マイコンクラブ川崎進一郎氏によって書かれた。

@table @asis

@item 正式名称
SKK95

@item どのようなソフトウェアか
Windows95, WindowsNT, Windows98 上で SKK ライクなかな漢字入力を実現する
IME。

@item 使用するために要求される環境
上記のOS(もちろん日本語版)。

@item 最新バージョン、release の日付
最新バージョンα13。1999年6月9日。

@item 開発者
京大マイコンクラブ

@item 配布条件
SKK95はフリーウェアです。商業目的以外の目的のためならば自由にコピーして
いただいて構いません。SKK95を使用したことによるいかなる被害に対しても、
SKK95 の作者は責任を負いません。

@item 入手方法
下記のウェッブページから入手して下さい。
@w{@samp{http://www.kuis.kyoto-u.ac.jp/~kmc/proj/skk95/}}

@item bug report,質問のためのアドレス
@w{@samp{skk95-bugs@@kmc.kyoto-u.ac.jp}}

@item その他
1999年9月現在、SKK95はαバージョンであり、動作が安定していないところもあ
ります。WindowsNTでは比較的安定して動作するようです。

@end table

@node 最新情報など, 事項索引, SKK関連ソフトウェア, Top
@comment  node-name,  next,  previous,  up
@chapter 最新情報など

@menu
* 最新情報::
* SKK 9 と SKK 10 の違い::
* 謝辞::                    
* お願い::
* SKKの作者::
* このマニュアルについて::
@end menu

@node 最新情報, SKK 9 と SKK 10 の違い, 最新情報など, 最新情報など
@comment  node-name,  next,  previous,  up
@section 最新情報

SKK 10 についての最新情報は、

@ftable @code
@w{@samp{http://openlab.ring.gr.jp/skk/}}
@end ftable

から得ることができます。

SKK Openlab では、開発者、文章の整備にご協力いただける方、テスター、よろず
ものを言う人などなど、常に募集しています(@xref{SKK Ring Server Openlab メーリングリスト})。

また、SKK の開発は、 CVS によってなされています。CVS を使って最新の SKK を
取得する場合、CVS account を取得して開発に参加される場合は、付属の
@samp{READMEs/CVS_digest} ファイルを参照して下さい。

@node SKK 9 と SKK 10 の違い, 謝辞, 最新情報, 最新情報など
@comment  node-name,  next,  previous,  up
@section SKK 9 と SKK 10 の違い

SKK 10 は SKK 9 と比べて、重要な変更がいくつかあります。そこで、SKK 9 の
ユーザーが SKK 10 に以降するに際して注意すべき点について本節で説明します。

@table @asis
@item 対応する Emacs のバージョン

Emacs 20 と XEmacs 21 をサポートしたことが最も重要な変更点です。同時に 
Mule 2.3 (Emacs 19.28 または 19.34) もサポートします。ただし、Nemacs や 
Mule 1.1 など、Emacs 18 はもはやサポートされません。

@item APEL ライブラリの使用

様々な Emacsen の上で動作するようにすると保守が難しくなります。SKK 10 は
 APEL ライブラリを各種 Emacs の差異を吸収する目的で使用し、この問題に対
処しています。

一方で、SKK をインストールする前に APEL をインストールする必要があるため、
管理者にとってはひとつ手間が増えることになります。

@item @code{skk-input-vector} の廃止
@vindex skk-input-vector

SKK 9 のころは、「？」や「；」などの記号をいわゆる半角で入力するために、
@code{skk-input-vector} という変数の設定を各ユーザが行っていました。
SKK 10 では、この変数は廃止されましたが、代わりに
@code{skk-rom-kana-rule-list} という変数を使って、同様の設定がてきるので
問題ありません。その設定方法を知りたい場合は

@xref{数字や記号文字の入力}

を参照してください。
@end table


@node 謝辞, お願い, 最新情報, 最新情報など
@comment  node-name,  next,  previous,  up
@section 謝辞

SKKの設計方針はTAO/ELIS上の日本語入力システムKanzenの影響を受けています。
Kanzenのデモを行ってくださり、またKanzenを使う機会を与えてくださったNTT
の竹内郁雄さんに感謝します。

第1版の辞書作成のための読みの入力を行ってくださった東北大学電気通信研究
所佐藤研究室の 安藤大君、猪岡美紀さん、奥川淳一君、佐々木昭彦君、佐藤克
志君、山岸信寛君に感謝します。

SKK辞書第2, 3, 4, 5, 6, 7, 8版作成のためのデータを提供してくださった方々
に感謝します。

SKK辞書第6, 7版作成にあたり協力してくださった高橋裕信氏に感謝します。

その他、SKK への貢献者については、ソース配布の

@file{READMEs/Contributors}

というファイルに記載されています。すべての貢献者のみなさんに感謝いたしま
す。

@node お願い, SKKの作者, 謝辞, 最新情報など
@comment  node-name,  next,  previous,  up
@section お願い

SKK辞書は多くのユーザの方々から提供された辞書によりコピーフリーの辞書と
しては最大規模の辞書になっています。今後もこの方式によりSKK辞書をより充
実したものにしていきたいと思います。毎年1月頃を目途にアナウンスしますが、
SKK辞書の充実にご協力いただける方は、随時以下のアドレスまで個人辞書と 
@file{SKK-JISYO.L}との差分をお送りください。お送りいただいた辞書を整理
して次年度の辞書に含めさせていただきます。差分ファイルの作成方法について
は@ref{skkdic-expr}をご参照下さい。

また, @file{SKK-JISYO.L}の誤りを発見された方は多少にかかわらず、下記の
アドレスまでお知らせください。

@example
@samp{skk-dic@@maid.ne.jp}
@samp{skk@@ring.gr.jp}
@end example

@node SKKの作者, このマニュアルについて, お願い, 最新情報など
@comment  node-name,  next,  previous,  up
@section SKKの作者

SKK の原作者は、現京都大学の佐藤雅彦教授 @w{<masahiko@@kuis.kyoto-u.ac.jp>}
です。

現在の SKK は、大勢のボランティアの貢献により成立しています。以下は確認
されている貢献者名です。ここに入っていない貢献者がおられる場合には、修正
しますので、SKK OpenLab メーリングリスト @w{<skk@@ring.gr.jp>} までご一
報ください。

@itemize @asis
@item 小関 吉則 @w{<kose@@wizard.tamra.co.jp>}
@item 小野 孝男 @w{<takao@@hirata.nuee.nagoya-u.ac.jp>}
@item 進藤裕志 @w{<shindo@@super.ees.saitama-u.ac.jp>}
@item 中津山 恒 @w{<hisashi@@rst.fujixerox.co.jp>}
@item 沈志勇 @w{<jshen@@cas.org>}
@item 柘植 正大 @w{<ma-tsuge@@kdd.co.jp>}
@item Chikanobu Toyofuku @w{<unbound@@papaya.juice.or.jp>}
@item FUKANO Masaaki @w{<fukano-m@@alp.cs.uec.ac.jp>}
@item Fukaya Shigeru @w{<SFUKAYA@@oracle.co.jp>}
@item FURUE Hideyuki @w{<furue@@kke.co.jp>}
@item GUNJI Takao @w{<gunji@@lisa.lang.osaka-u.ac.jp>}
@item Haru Mizuno @w{<mizu@@cs3.cs.oki.co.jp>}
@item Haru'yasu Ueda @w{<hal@@sics.se>}
@item Hideki Sakurada @w{<sakurada@@kuis.kyoto-u.ac.jp>}
@item Hisao Kuroda @w{<kuroda@@msi.co.jp>}
@item Hitoshi SUZUKI @w{<h-suzuki@@ael.fujitsu.co.jp>}
@item IIDA Yosiaki @w{<iida@@secom-sis.co.jp>}
@item Jun-ichi Nakamura @w{<nakamura@@pluto.ai.kyutech.ac.jp>}
@item Katuya Tomioka @w{<tomioka@@culle.l.chiba-u.ac.jp>}
@item Kazuo Hirokawa @w{<hirokawa@@rics.co.jp>}
@item Kazushi Marukawa @w{<kazushi@@kubota.co.jp>}
@item Keisuke Nishida @w{<kxn30@@po.cwru.edu>}
@item Kenji Rikitake @w{<kenji@@reseau.toyonaka.osaka.jp>}
@item Kenji Yamashita @w{<kenji@@cs.titech.ac.jp>}
@item Kimura Chikahiro @w{<kimura@@oa1.kb.nec.co.jp>}
@item Kiyotaka Sakai @w{<ksakai@@netwk.ntt-at.co.jp>}
@item Koichi MORI @w{<kmori@@onsei2.rilp.m.u-tokyo.ac.jp>}
@item Koji Uchida @w{<uchida@@cfd.tytlabs.co.jp>}
@item Makoto MATSUSHITA @w{<matusita@@ics.es.osaka-u.ac.jp>}
@item Manabu Kawashima @w{<kaw@@lp.nm.fujitsu.co.jp>}
@item Masahiko Sato @w{<masahiko@@kuis.kyoto-u.ac.jp>}
@item Masahiko Suzuki @w{<suzmasa@@sm.sony.co.jp>}
@item Masahiro Doteguchi @w{<xdote@@rp.open.cs.fujitsu.co.jp>}
@item Masakazu Takahashi @w{<masaka-t@@ascii.co.jp>}
@item Masatake YAMATO @w{<masata-y@@is.aist-nara.ac.jp>}
@item Mikio Nakajima @w{<minakaji@@osaka.email.ne.jp>}
@item MINOURA Itsushi @w{<minoura@@uni.zool.s.u-tokyo.ac.jp>}
@item MIYOSHI Tsutomu @w{<minkov@@fuzzy.or.jp>}
@item Motohiko Mouri @w{<mouri@@jaist.ac.jp>}
@item Murata Shuuichirou @w{<mrt@@notwork.org>}
@item NAMBA Seiich @w{<pi9s-nnb@@asahi-net.or.jp>}
@item Naoki HAMADA @w{<nao@@mimo.jaist-east.ac.jp>}
@item Naoki Wakamatsu @w{<naoki-w@@ht-net21.ne.jp>}
@item NEMOTO Takashi @w{<tnemoto@@mvi.biglobe.ne.jp>}
@item NISHIDA Keisuke @w{<knishida@@nn.iij4u.or.jp>}
@item Rei FURUKAWA @w{<furukawa@@tcp-ip.or.jp>}
@item Ryoichi Hashimoto @w{<gnu@@ipri.go.jp>}
@item Satoshi Harauchi
@item Sekita Daigo @w{<sekita@@mri.co.jp>}
@item Shuhei KOBAYASHI @w{<shuhei@@aqua.ocn.ne.jp>}
@item Shuji Ashizawa @w{<ashizawa@@zuken.co.jp>}
@item SL Baur @w{<steve@@altair.xemacs.org>}
@item sphere @w{<sphere@@pop12.odn.ne.jp>}
@item Stephen Turnbull  @w{<turnbull@@sk.tsukuba.ac.jp>}
@item Takao KAWAMURA @w{<kawamura@@ike.tottori-u.ac.jp>}
@item Takeshi OHTANI @w{<ohtani@@iias.flab.fujitsu.co.jp>}
@item Thierry Emery @w{<Thierry.Emery@@nmu.alcatel.fr>}
@item TOKUYA Junichi @w{<tokuya@@crab.fuji-ric.co.jp>}
@item Tomotaka SUWA @w{<cooper@@saitama.fujimic.fujisankei-g.co.jp>}
@item Tomoyuki Hiro @w{<hiro@@momo.it.okayama-u.ac.jp>}
@item Toyonobu Yoshida @w{<toyono-y@@is.aist-nara.ac.jp>}
@item Tsugutomo Enami @w{<enami@@ptgd.sony.co.jp>}
@item Tsukamoto Tetsuo  @w{<czkmt@@remus.dti.ne.jp>}
@item Tsuyoshi AKIHO @w{<akiho@@media.osaka-cu.ac.jp>}
@item TSUMURA Tomoaki @w{<tsumura@@kuis.kyoto-u.ac.jp>}
@item Wataru Matsui @w{<matsui@@atr-rd.atr.co.jp>}
@item Wataru Matsui @w{<matsui@@gf.hm.rd.sanyo.co.jp>}
@item Yoshida Toyonobu @w{<toyono-y@@is.aist-nara.ac.jp>}
@item Yukiyoshi Kameyama @w{<kameyama@@kuis.kyoto-u.ac.jp>}  
@item Yuh Ohmura @w{<yutopia@@t3.rim.or.jp>}
@end itemize

@node このマニュアルについて,  , SKKの作者, 最新情報など
@comment  node-name,  next,  previous,  up
@section このマニュアルについて

本マニュアルは、SKK オープンラボの有志の貢献により、従来のマニュアルを
SKK バージョン 10 に合わせて加筆修正したものです。

@node 事項索引, 変数索引, 最新情報など, Top
@comment      node-name, next,       previous, up
@unnumbered 事項索引

@printindex cp

@node 変数索引, 関数索引, 事項索引, Top
@comment    node-name,         next,       previous, up
@unnumbered 変数索引

@printindex vr

@node 関数索引, キー索引, 変数索引, Top
@comment      node-name, next,       previous, up
@unnumbered 関数索引

@printindex fn

@node キー索引,  , 関数索引, Top
@comment      node-name, next,       previous, up
@unnumbered キー索引

@printindex ky

@summarycontents
@contents
@bye

@c Local Variables:
@c End:
